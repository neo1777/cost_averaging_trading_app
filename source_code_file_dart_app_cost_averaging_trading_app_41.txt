./lib/main.dart:
```
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/app.dart';
import 'package:cost_averaging_trading_app/core/providers/app_providers.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await dotenv.load(fileName: ".env");

  if (!kIsWeb) {
    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;
  }

  // Inizializza il database
  final databaseService = DatabaseService();
  await databaseService.initDatabase();

  runApp(
    const AppProviders(
      child: App(),
    ),
  );
}

```

./lib/routes.dart:
```
// lib/routes.dart
import 'package:flutter/material.dart';

import 'package:cost_averaging_trading_app/features/dashboard/ui/pages/dashboard_page.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/pages/portfolio_page.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/pages/settings_page.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/pages/strategy_page.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/pages/trade_history_page.dart';
import 'package:cost_averaging_trading_app/ui/layouts/main_layout.dart';

class Routes {
  static const String dashboard = '/';
  static const String portfolio = '/portfolio';
  static const String strategy = '/strategy';
  static const String tradeHistory = '/trade-history';
  static const String settings = '/settings';

  static Route<dynamic> generateRoute(RouteSettings setting) {
    switch (setting.name) {
      case dashboard:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: DashboardPage()));
      case portfolio:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: PortfolioPage()));
      case strategy:
        return MaterialPageRoute(
          builder: (_) => const MainLayout(child: StrategyPage()),
        );
      case tradeHistory:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: TradeHistoryPage()));
      case settings:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: SettingsPage()));
      default:
        return MaterialPageRoute(
          builder: (_) => Scaffold(
            body: Center(
              child: Text('No route defined for ${setting.name}'),
            ),
          ),
        );
    }
  }
}

```

./lib/app.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/theme/app_theme.dart';
import 'package:cost_averaging_trading_app/routes.dart';

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Cost Averaging Trading App',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      initialRoute: Routes.dashboard,
      onGenerateRoute: Routes.generateRoute,
    );
  }
}
```

./lib/ui/widgets/responsive_text.dart:
```
import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';

class ResponsiveText extends StatelessWidget {
  final String text;
  final TextStyle? style;
  final int maxLines;
  final TextAlign textAlign;

  const ResponsiveText(
    this.text, {
    super.key,
    this.style,
    this.maxLines = 1,
    this.textAlign = TextAlign.start,
  });

  @override
  Widget build(BuildContext context) {
    return AutoSizeText(
      text,
      style: style,
      maxLines: maxLines,
      textAlign: textAlign,
      overflow: TextOverflow.ellipsis,
    );
  }
}
```

./lib/ui/layouts/custom_page_layout.dart:
```
// lib/ui/layouts/custom_page_layout.dart

import 'package:flutter/material.dart';
import 'package:responsive_builder/responsive_builder.dart';

class CustomPageLayout extends StatelessWidget {
  final String title;
  final List<Widget> children;
  final Widget? floatingActionButton;
  final bool useSliver;

  const CustomPageLayout({
    super.key,
    required this.title,
    required this.children,
    this.floatingActionButton,
    this.useSliver = false,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: ResponsiveBuilder(
        builder: (context, sizingInformation) {
          if (useSliver) {
            return _buildSliverLayout(context, sizingInformation);
          } else {
            return _buildStandardLayout(context, sizingInformation);
          }
        },
      ),
      floatingActionButton: floatingActionButton,
    );
  }

  Widget _buildSliverLayout(
      BuildContext context, SizingInformation sizingInformation) {
    return CustomScrollView(
      slivers: [
        SliverAppBar(
          title: Text(title),
          floating: true,
          snap: true,
          pinned: true,
        ),
        SliverPadding(
          padding: EdgeInsets.all(sizingInformation.isMobile ? 8.0 : 16.0),
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
              (BuildContext context, int index) {
                return Padding(
                  padding: const EdgeInsets.only(bottom: 16.0),
                  child: children[index],
                );
              },
              childCount: children.length,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildStandardLayout(
      BuildContext context, SizingInformation sizingInformation) {
    return Column(
      children: [
        AppBar(
          title: Text(title),
        ),
        Expanded(
          child: SingleChildScrollView(
            padding: EdgeInsets.all(sizingInformation.isMobile ? 8.0 : 16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: children
                  .map((child) => Padding(
                        padding: const EdgeInsets.only(bottom: 16.0),
                        child: child,
                      ))
                  .toList(),
            ),
          ),
        ),
      ],
    );
  }
}

```

./lib/ui/layouts/main_layout.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/routes.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class MainLayout extends StatelessWidget {
  final Widget child;

  const MainLayout({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    final bool isDesktop = MediaQuery.of(context).size.width >= 600;

    return Scaffold(
      // Rimuoviamo l'AppBar
      // appBar: AppBar(
      //   title: const ResponsiveText(
      //     'Cost Averaging Trading App',
      //     style: TextStyle(fontSize: 20),
      //   ),
      //   automaticallyImplyLeading: !isDesktop,
      //   actions: [
      //     BlocBuilder<SettingsBloc, SettingsState>(
      //       builder: (context, state) {
      //         if (state is SettingsLoaded && state.isDemoMode) {
      //           return const Chip(
      //             label: Text('Demo Mode'),
      //             backgroundColor: Colors.orange,
      //           );
      //         }
      //         return const SizedBox.shrink();
      //       },
      //     ),
      //   ],
      // ),
      drawer: isDesktop ? null : const AppDrawer(),
      body: SafeArea(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (isDesktop) const AppDrawer(),
            Expanded(child: child),
          ],
        ),
      ),
    );
  }
}

class AppDrawer extends StatelessWidget {
  const AppDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    return Drawer(
      child: ListView(
        children: [
          const DrawerHeader(
            child: ResponsiveText(
              'Menu',
              style: TextStyle(fontSize: 24),
            ),
          ),
          _buildMenuItem(context, 'Dashboard', Routes.dashboard),
          _buildMenuItem(context, 'Strategy', Routes.strategy),
          _buildMenuItem(context, 'Portfolio', Routes.portfolio),
          _buildMenuItem(context, 'Trade History', Routes.tradeHistory),
          _buildMenuItem(context, 'Settings', Routes.settings),
        ],
      ),
    );
  }

  Widget _buildMenuItem(BuildContext context, String title, String route) {
    return ListTile(
      title: ResponsiveText(
        title,
        style: const TextStyle(fontSize: 18),
      ),
      onTap: () {
        Navigator.pushReplacementNamed(context, route);
      },
    );
  }
}

```

./lib/features/trade_history/ui/widgets/trade_stats.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class TradeStats extends StatelessWidget {
  final Map<String, dynamic> stats;

  const TradeStats({super.key, required this.stats});

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Trade Statistics',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildStatRow(
              'Total Trades', stats['totalTrades']?.toString() ?? 'N/A'),
          _buildStatRow(
              'Profit Trades', stats['profitableTrades']?.toString() ?? 'N/A'),
          _buildStatRow(
              'Loss Trades',
              ((stats['totalTrades'] ?? 0) - (stats['profitableTrades'] ?? 0))
                  .toString()),
          _buildStatRow('Total Profit',
              '\$${(stats['totalProfit'] ?? 0).toStringAsFixed(2)}'),
          _buildStatRow('Win Rate',
              '${((stats['winRate'] ?? 0) * 100).toStringAsFixed(2)}%'),
          _buildStatRow('Average Profit',
              '\$${(stats['averageProfit'] ?? 0).toStringAsFixed(2)}'),
          _buildStatRow('Average Loss',
              '\$${(stats['averageLoss'] ?? 0).toStringAsFixed(2)}'),
          const SizedBox(height: 16),
          Text('Asset Volumes:',
              style: Theme.of(context).textTheme.titleMedium),
          ..._buildAssetVolumes(),
        ],
      ),
    );
  }

  Widget _buildStatRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label),
          Text(value, style: const TextStyle(fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  List<Widget> _buildAssetVolumes() {
    final assetVolumes = stats['assetVolumes'] as Map<dynamic, dynamic>? ?? {};
    return assetVolumes.entries
        .map(
          (entry) => _buildStatRow(entry.key.toString(),
              '\$${(entry.value as num).toStringAsFixed(2)}'),
        )
        .toList();
  }
}

```

./lib/features/trade_history/ui/widgets/trade_filters.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_text_field.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_button.dart';

class TradeFilters extends StatefulWidget {
  final Function(DateTime?, DateTime?, String?) onFilterApplied;

  const TradeFilters({super.key, required this.onFilterApplied});

  @override
  TradeFiltersState createState() => TradeFiltersState();
}

class TradeFiltersState extends State<TradeFilters> {
  DateTime? _startDate;
  DateTime? _endDate;
  String? _selectedAssetPair;

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Filters',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Expanded(
                child: CustomTextField(
                  label: 'Start Date',
                  readOnly: true,
                  onTap: () => _selectDate(context, true),
                  value: _startDate != null ? _formatDate(_startDate!) : '',
                  icon: Icons.calendar_today,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: CustomTextField(
                  label: 'End Date',
                  readOnly: true,
                  onTap: () => _selectDate(context, false),
                  value: _endDate != null ? _formatDate(_endDate!) : '',
                  icon: Icons.calendar_today,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          DropdownButtonFormField<String>(
            decoration: const InputDecoration(
              labelText: 'Asset Pair',
              border: OutlineInputBorder(),
            ),
            value: _selectedAssetPair,
            items: ['BTC/USDT', 'ETH/USDT', 'XRP/USDT']
                .map((pair) => DropdownMenuItem(value: pair, child: Text(pair)))
                .toList(),
            onChanged: (value) => setState(() => _selectedAssetPair = value),
          ),
          const SizedBox(height: 16),
          CustomButton(
            label: 'Apply Filters',
            onPressed: () => widget.onFilterApplied(_startDate, _endDate, _selectedAssetPair),
            icon: Icons.filter_list,
          ),
        ],
      ),
    );
  }

  Future<void> _selectDate(BuildContext context, bool isStartDate) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: isStartDate ? _startDate ?? DateTime.now() : _endDate ?? DateTime.now(),
      firstDate: DateTime(2000),
      lastDate: DateTime.now(),
    );
    if (picked != null) {
      setState(() {
        if (isStartDate) {
          _startDate = picked;
        } else {
          _endDate = picked;
        }
      });
    }
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }
}
```

./lib/features/trade_history/ui/widgets/trade_list.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:intl/intl.dart';

class TradeList extends StatelessWidget {
  final List<CoreTrade> trades;

  const TradeList({super.key, required this.trades});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: trades.length,
      itemBuilder: (context, index) {
        final trade = trades[index];
        return Card(
          child: ListTile(
            leading: Icon(
              trade.type == CoreTradeType.buy ? Icons.arrow_downward : Icons.arrow_upward,
              color: trade.type == CoreTradeType.buy ? Colors.green : Colors.red,
            ),
            title: Text('${trade.type.name.toUpperCase()} ${trade.amount} ${trade.symbol}'),
            subtitle: Text('Price: ${trade.price} | ${DateFormat.yMd().add_Hms().format(trade.timestamp)}'),
            trailing: Text(
              '${trade.type == CoreTradeType.buy ? '-' : '+'}${(trade.amount * trade.price).toStringAsFixed(2)}',
              style: TextStyle(
                color: trade.type == CoreTradeType.buy ? Colors.red : Colors.green,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        );
      },
    );
  }
}
```

./lib/features/trade_history/ui/pages/trade_history_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_bloc.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_state.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_event.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/widgets/trade_list.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/widgets/trade_filters.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/widgets/trade_stats.dart';
import 'package:cost_averaging_trading_app/ui/layouts/custom_page_layout.dart';

class TradeHistoryPage extends StatelessWidget {
  const TradeHistoryPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<TradeHistoryBloc, TradeHistoryState>(
      builder: (context, state) {
        return CustomPageLayout(
          title: 'Trade History',
          useSliver: true,
          children: _buildTradeHistoryContent(context, state),
        );
      },
    );
  }

  List<Widget> _buildTradeHistoryContent(
      BuildContext context, TradeHistoryState state) {
    if (state is TradeHistoryInitial) {
      context.read<TradeHistoryBloc>().add(LoadTradeHistory());
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is TradeHistoryLoading) {
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is TradeHistoryLoaded) {
      return [
        _buildFilters(context),
        const SizedBox(height: 16),
        _buildTradeStats(state),
        const SizedBox(height: 16),
        _buildTradeList(state),
        const SizedBox(height: 16),
        _buildPagination(context, state),
      ];
    } else if (state is TradeHistoryError) {
      return [Center(child: Text('Error: ${state.message}'))];
    }
    return [const Center(child: Text('Unknown state'))];
  }

  Widget _buildFilters(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TradeFilters(
          onFilterApplied: (startDate, endDate, assetPair) {
            context.read<TradeHistoryBloc>().add(
                  FilterTradeHistory(
                    startDate: startDate,
                    endDate: endDate,
                    assetPair: assetPair,
                  ),
                );
          },
        ),
      ),
    );
  }

  Widget _buildTradeStats(TradeHistoryLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TradeStats(stats: state.statistics),
      ),
    );
  }

  Widget _buildTradeList(TradeHistoryLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: TradeList(trades: state.trades),
      ),
    );
  }

  Widget _buildPagination(BuildContext context, TradeHistoryLoaded state) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        IconButton(
          icon: const Icon(Icons.chevron_left),
          onPressed: state.currentPage > 1
              ? () => context
                  .read<TradeHistoryBloc>()
                  .add(ChangePage(state.currentPage - 1))
              : null,
        ),
        Text('Page ${state.currentPage}'),
        IconButton(
          icon: const Icon(Icons.chevron_right),
          onPressed: state.currentPage < state.totalPages
              ? () => context
                  .read<TradeHistoryBloc>()
                  .add(ChangePage(state.currentPage + 1))
              : null,
        ),
      ],
    );
  }
}
```

./lib/features/trade_history/blocs/trade_history_state.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

abstract class TradeHistoryState {}

class TradeHistoryInitial extends TradeHistoryState {}

class TradeHistoryLoading extends TradeHistoryState {}

class TradeHistoryLoaded extends TradeHistoryState {
  final List<CoreTrade> trades;
  final Map<String, dynamic> statistics;
  final int currentPage;
  final int totalPages;

  TradeHistoryLoaded({
    required this.trades,
    required this.statistics,
    required this.currentPage,
    required this.totalPages,
  });
}

class TradeHistoryError extends TradeHistoryState {
  final String message;

  TradeHistoryError(this.message);
}

```

./lib/features/trade_history/blocs/trade_history_event.dart:
```
abstract class TradeHistoryEvent {}

class LoadTradeHistory extends TradeHistoryEvent {}

class FilterTradeHistory extends TradeHistoryEvent {
  final DateTime? startDate;
  final DateTime? endDate;
  final String? assetPair;

  FilterTradeHistory({this.startDate, this.endDate, this.assetPair});
}

class ChangePage extends TradeHistoryEvent {
  final int pageNumber;

  ChangePage(this.pageNumber);
}

```

./lib/features/trade_history/blocs/trade_history_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_event.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_state.dart';
import 'package:cost_averaging_trading_app/features/trade_history/repositories/trade_history_repository.dart';

class TradeHistoryBloc extends Bloc<TradeHistoryEvent, TradeHistoryState> {
  final TradeHistoryRepository _repository;

  TradeHistoryBloc(this._repository) : super(TradeHistoryInitial()) {
    on<LoadTradeHistory>(_onLoadTradeHistory);
    on<FilterTradeHistory>(_onFilterTradeHistory);
    on<ChangePage>(_onChangePage);
  }

  Future<void> _onLoadTradeHistory(
    LoadTradeHistory event,
    Emitter<TradeHistoryState> emit,
  ) async {
    emit(TradeHistoryLoading());
    try {
      final result = await _repository.getTradeHistory();
      emit(_createLoadedState(result, 1));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error loading trade history', e, stackTrace);
      emit(TradeHistoryError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }

  Future<void> _onFilterTradeHistory(
    FilterTradeHistory event,
    Emitter<TradeHistoryState> emit,
  ) async {
    emit(TradeHistoryLoading());
    try {
      final result = await _repository.getFilteredTradeHistory(
        startDate: event.startDate,
        endDate: event.endDate,
        assetPair: event.assetPair,
      );
      emit(_createLoadedState(result, 1));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error filtering trade history', e, stackTrace);
      emit(TradeHistoryError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }

  Future<void> _onChangePage(
    ChangePage event,
    Emitter<TradeHistoryState> emit,
  ) async {
    if (state is TradeHistoryLoaded) {
      final currentState = state as TradeHistoryLoaded;
      emit(TradeHistoryLoading());
      try {
        final result = await _repository.getTradeHistoryPage(event.pageNumber);
        emit(_createLoadedState(
            result, event.pageNumber, currentState.totalPages));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error changing page', e, stackTrace);
        emit(TradeHistoryError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }


  TradeHistoryLoaded _createLoadedState(
      TradeHistoryResult result, int currentPage,
      [int? totalPages]) {
    return TradeHistoryLoaded(
      trades: result.trades,
      statistics: {
        'totalTrades': result.statistics['totalTrades'] ?? 0,
        'profitableTrades': result.statistics['profitableTrades'] ?? 0,
        'totalProfit': result.statistics['totalProfit'] ?? 0.0,
        'winRate': result.statistics['winRate'] ?? 0.0,
        'averageProfit': result.statistics['averageProfit'] ?? 0.0,
        'averageLoss': result.statistics['averageLoss'] ?? 0.0,
        'assetVolumes':
            (result.statistics['assetVolumes'] as Map<dynamic, dynamic>?)?.map(
                  (key, value) =>
                      MapEntry(key.toString(), (value as num).toDouble()),
                ) ??
                {},
      },
      currentPage: currentPage,
      totalPages: totalPages ?? result.totalPages,
    );
  }

}

```

./lib/features/trade_history/repositories/trade_history_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class TradeHistoryResult {
  final List<CoreTrade> trades;
  final Map<String, dynamic> statistics;
  final int totalPages;

  TradeHistoryResult({
    required this.trades,
    required this.statistics,
    required this.totalPages,
  });
}

class TradeHistoryRepository {
  Future<TradeHistoryResult> getTradeHistory() async {
    // Implementa la logica per ottenere la cronologia delle operazioni
    // Questo è un esempio, dovresti implementare la logica reale
    await Future.delayed(const Duration(seconds: 1)); // Simula una chiamata API

    return TradeHistoryResult(
      trades: [
        CoreTrade(
          id: '1',
          symbol: 'BTC/USDT',
          amount: 0.1,
          price: 50000,
          timestamp: DateTime.now().subtract(const Duration(days: 1)),
          type: CoreTradeType.buy,
        ),
        // Aggiungi altre operazioni di esempio
      ],
      statistics: {
        'totalTrades': 1,
        'totalVolume': 5000,
        'profitLoss': 500,
      },
      totalPages: 1,
    );
  }

  Future<TradeHistoryResult> getFilteredTradeHistory({
    DateTime? startDate,
    DateTime? endDate,
    String? assetPair,
  }) async {
    // Implementa la logica per filtrare la cronologia delle operazioni
    // Questo è un esempio, dovresti implementare la logica reale
    await Future.delayed(const Duration(seconds: 1)); // Simula una chiamata API

    return TradeHistoryResult(
      trades: [
        CoreTrade(
          id: '2',
          symbol: assetPair ?? 'BTC/USDT',
          amount: 0.2,
          price: 48000,
          timestamp: DateTime.now().subtract(const Duration(days: 2)),
          type: CoreTradeType.sell,
        ),
        // Aggiungi altre operazioni filtrate di esempio
      ],
      statistics: {
        'totalTrades': 1,
        'totalVolume': 9600,
        'profitLoss': -400,
      },
      totalPages: 1,
    );
  }

  Future<TradeHistoryResult> getTradeHistoryPage(int pageNumber) async {
    // Implementa la logica per ottenere una specifica pagina della cronologia delle operazioni
    // Questo è un esempio, dovresti implementare la logica reale
    await Future.delayed(const Duration(seconds: 1)); // Simula una chiamata API

    return TradeHistoryResult(
      trades: [
        CoreTrade(
          id: '3',
          symbol: 'ETH/USDT',
          amount: 1.5,
          price: 3000,
          timestamp: DateTime.now().subtract(const Duration(days: 3)),
          type: CoreTradeType.buy,
        ),
        // Aggiungi altre operazioni per questa pagina
      ],
      statistics: {
        'totalTrades': 1,
        'totalVolume': 4500,
        'profitLoss': 300,
      },
      totalPages: 5, // Esempio: supponiamo ci siano 5 pagine in totale
    );
  }
}

```

./lib/features/trade_history/models/trade_history_model.dart:
```
class TradeHistoryTrade {
  final String id;
  final String assetPair;
  final double amount;
  final double price;
  final DateTime timestamp;
  final String type; // 'buy' o 'sell'

  TradeHistoryTrade({
    required this.id,
    required this.assetPair,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  factory TradeHistoryTrade.fromJson(Map<String, dynamic> json) {
    return TradeHistoryTrade(
      id: json['id'],
      assetPair: json['assetPair'],
      amount: json['amount'].toDouble(),
      price: json['price'].toDouble(),
      timestamp: DateTime.parse(json['timestamp']),
      type: json['type'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'assetPair': assetPair,
      'amount': amount,
      'price': price,
      'timestamp': timestamp.toIso8601String(),
      'type': type,
    };
  }
}

class TradeHistoryModel {
  final List<TradeHistoryTrade> trades;

  TradeHistoryModel({required this.trades});

  factory TradeHistoryModel.fromJson(Map<String, dynamic> json) {
    var tradeList = json['trades'] as List;
    List<TradeHistoryTrade> trades =
        tradeList.map((i) => TradeHistoryTrade.fromJson(i)).toList();
    return TradeHistoryModel(trades: trades);
  }

  Map<String, dynamic> toJson() {
    return {
      'trades': trades.map((trade) => trade.toJson()).toList(),
    };
  }
}

```

./lib/features/strategy/ui/widgets/backtest_result_view.dart:
```
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_event.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/backtest_progress_chart.dart';
import 'package:provider/provider.dart';

class BacktestResultView extends StatelessWidget {
  final BacktestResult result;

  const BacktestResultView({super.key, required this.result});

  @override
  Widget build(BuildContext context) {
    final spots = result.investmentOverTime
        .asMap()
        .entries
        .map((entry) => FlSpot(entry.key.toDouble(), entry.value['value']))
        .toList();

    final minY = spots.map((spot) => spot.y).reduce((a, b) => a < b ? a : b);
    final maxY = spots.map((spot) => spot.y).reduce((a, b) => a > b ? a : b);

    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Backtest Results',
                style: Theme.of(context).textTheme.headlineSmall),
            const SizedBox(height: 16),
            BacktestProgressChart(spots: spots, minY: minY, maxY: maxY),
            const SizedBox(height: 16),
            Text('Performance Metrics:',
                style: Theme.of(context).textTheme.titleLarge),
            Text(
                'Total Profit: \$${result.performance.totalProfit.toStringAsFixed(2)}'),
            Text(
                'Total Return: ${(result.performance.totalReturn * 100).toStringAsFixed(2)}%'),
            Text(
                'Max Drawdown: ${(result.performance.maxDrawdown * 100).toStringAsFixed(2)}%'),
            Text(
                'Win Rate: ${(result.performance.winRate * 100).toStringAsFixed(2)}%'),
            Text(
                'Sharpe Ratio: ${result.performance.sharpeRatio.toStringAsFixed(2)}'),
            const SizedBox(height: 16),
            ElevatedButton(
              child: const Text('Back to Strategy'),
              onPressed: () =>
                  context.read<StrategyBloc>().add(LoadStrategyData()),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/risk_info_card.dart:
```
import 'package:flutter/material.dart';

class RiskInfoCard extends StatelessWidget {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  const RiskInfoCard({
    super.key,
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Risk Management Settings',
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            _buildInfoRow('Max Loss Percentage',
                '${maxLossPercentage.toStringAsFixed(2)}%'),
            _buildInfoRow(
                'Max Concurrent Trades', maxConcurrentTrades.toString()),
            _buildInfoRow('Max Position Size',
                '${maxPositionSizePercentage.toStringAsFixed(2)}%'),
            _buildInfoRow('Daily Exposure Limit',
                '\$${dailyExposureLimit.toStringAsFixed(2)}'),
            _buildInfoRow('Max Allowed Volatility',
                '${(maxAllowedVolatility * 100).toStringAsFixed(2)}%'),
            _buildInfoRow('Max Rebuy Count', maxRebuyCount.toString()),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),
          Text(value),
        ],
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_monitor.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:fl_chart/fl_chart.dart';

class StrategyMonitor extends StatelessWidget {
  final double totalInvested;
  final double currentProfit;
  final int tradeCount;
  final double averageBuyPrice;
  final double currentMarketPrice;
  final List<CoreTrade> recentTrades;

  const StrategyMonitor({
    super.key,
    required this.totalInvested,
    required this.currentProfit,
    required this.tradeCount,
    required this.averageBuyPrice,
    required this.currentMarketPrice,
    required this.recentTrades,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Strategy Monitor',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildOverview(context),
          const SizedBox(height: 16),
          _buildPriceChart(context),
          const SizedBox(height: 16),
          _buildRecentTrades(context),
        ],
      ),
    );
  }

  Widget _buildOverview(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Total Invested: \$${totalInvested.toStringAsFixed(2)}'),
        Text('Current Profit/Loss: \$${currentProfit.toStringAsFixed(2)}'),
        Text('Number of Trades: $tradeCount'),
        Text('Average Buy Price: \$${averageBuyPrice.toStringAsFixed(2)}'),
        Text('Current Market Price: \$${currentMarketPrice.toStringAsFixed(2)}'),
      ],
    );
  }

  Widget _buildPriceChart(BuildContext context) {
    final priceData = recentTrades.map((trade) => FlSpot(
      trade.timestamp.millisecondsSinceEpoch.toDouble(),
      trade.price,
    )).toList();

    return SizedBox(
      height: 200,
      child: LineChart(
        LineChartData(
          gridData: const FlGridData(show: false),
          titlesData: const FlTitlesData(show: false),
          borderData: FlBorderData(show: true),
          minX: priceData.first.x,
          maxX: priceData.last.x,
          minY: priceData.map((e) => e.y).reduce((a, b) => a < b ? a : b),
          maxY: priceData.map((e) => e.y).reduce((a, b) => a > b ? a : b),
          lineBarsData: [
            LineChartBarData(
              spots: priceData,
              isCurved: true,
              color: Theme.of(context).primaryColor,
              dotData: const FlDotData(show: false),
              belowBarData: BarAreaData(show: false),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRecentTrades(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Recent Trades',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        const SizedBox(height: 8),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: recentTrades.length > 5 ? 5 : recentTrades.length,
          itemBuilder: (context, index) {
            final trade = recentTrades[index];
            return ListTile(
              title: Text(
                '${trade.type == CoreTradeType.buy ? 'Buy' : 'Sell'} ${trade.amount.toStringAsFixed(8)} ${trade.symbol}',
              ),
              subtitle: Text('Price: \$${trade.price.toStringAsFixed(2)}'),
              trailing: Text(trade.timestamp.toString().split(' ')[0]),
            );
          },
        ),
      ],
    );
  }
}
```

./lib/features/strategy/ui/widgets/strategy_status.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_button.dart';

enum StrategyStatus { inactive, active, paused }

class StrategyStatusWidget extends StatelessWidget {
  final StrategyStatus status;
  final VoidCallback onStart;
  final VoidCallback onStop;
  final VoidCallback onSellEntirePortfolio;

  const StrategyStatusWidget({
    super.key,
    required this.status,
    required this.onStart,
    required this.onStop,
    required this.onSellEntirePortfolio,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Strategy Status',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Current Status: ${status.toString().split('.').last}',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: _getStatusColor(status),
            ),
          ),
          const SizedBox(height: 16),
          Wrap(
            spacing: 8.0,
            runSpacing: 8.0,
            children: [
              CustomButton(
                label: 'Start Strategy',
                onPressed: status == StrategyStatus.inactive ? onStart : null,
                icon: Icons.play_arrow,
              ),
              CustomButton(
                label: 'Stop Strategy',
                onPressed: status == StrategyStatus.active ? onStop : null,
                icon: Icons.stop,
                color: Colors.red,
              ),
              CustomButton(
                label: 'Sell Entire Portfolio',
                onPressed: status == StrategyStatus.active ? onSellEntirePortfolio : null,
                icon: Icons.sell,
                color: Colors.orange,
              ),
            ],
          ),
        ],
      ),
    );
  }

  Color _getStatusColor(StrategyStatus status) {
    switch (status) {
      case StrategyStatus.active:
        return Colors.green;
      case StrategyStatus.inactive:
        return Colors.red;
      case StrategyStatus.paused:
        return Colors.orange;
    }
  }
}
```

./lib/features/strategy/ui/widgets/strategy_chart.dart:
```
// lib/features/strategy/ui/widgets/strategy_chart.dart

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class StrategyChart extends StatelessWidget {
  final List<Map<String, dynamic>> chartData;

  const StrategyChart({super.key, required this.chartData});

  @override
  Widget build(BuildContext context) {
    if (chartData.isEmpty) {
      return const Center(child: Text('No chart data available'));
    }
    final minY = chartData
        .map((d) => (d['value'] as num).toDouble())
        .reduce((a, b) => a < b ? a : b);
    final maxY = chartData
        .map((d) => (d['value'] as num).toDouble())
        .reduce((a, b) => a > b ? a : b);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SizedBox(
          height: 300,
          child: LineChart(
            LineChartData(
              gridData: const FlGridData(show: false),
              titlesData: const FlTitlesData(show: false),
              borderData: FlBorderData(show: true),
              minX: 0,
              maxX: chartData.length.toDouble() - 1,
              minY: minY,
              maxY: maxY,
              lineBarsData: [
                LineChartBarData(
                  spots: chartData.asMap().entries.map((entry) {
                    return FlSpot(
                      entry.key.toDouble(),
                      (entry.value['value'] as num).toDouble(),
                    );
                  }).toList(),
                  isCurved: true,
                  color: Theme.of(context).primaryColor,
                  dotData: const FlDotData(show: false),
                  belowBarData: BarAreaData(
                      show: true,
                      color: Theme.of(context).primaryColor.withOpacity(0.3)),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/backtest_results.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class BacktestResults extends StatelessWidget {
  final BacktestResult? backtestResult;
  final Function(DateTime startDate, DateTime endDate) onRunBacktest;

  const BacktestResults({
    super.key,
    this.backtestResult,
    required this.onRunBacktest,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Backtest Results',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 16),
        _buildBacktestControls(context),
        if (backtestResult != null) ...[
          const SizedBox(height: 16),
          _buildPerformanceSummary(context),
          const SizedBox(height: 16),
          _buildPerformanceChart(context),
          const SizedBox(height: 16),
          _buildTradesList(context),
        ],
      ],
    );
  }

  Widget _buildBacktestControls(BuildContext context) {
    return Row(
      children: [
        ElevatedButton(
          onPressed: () {
            final now = DateTime.now();
            final oneYearAgo = now.subtract(const Duration(days: 365));
            onRunBacktest(oneYearAgo, now);
          },
          child: const Text('Run Backtest (Last Year)'),
        ),
      ],
    );
  }

  Widget _buildPerformanceSummary(BuildContext context) {
    final performance = backtestResult!.performance;
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Performance Summary',
                style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Text(
                'Total Profit: \$${performance.totalProfit.toStringAsFixed(2)}'),
            Text(
                'Total Return: ${(performance.totalReturn * 100).toStringAsFixed(2)}%'),
            Text(
                'Max Drawdown: ${(performance.maxDrawdown * 100).toStringAsFixed(2)}%'),
            Text(
                'Win Rate: ${(performance.winRate * 100).toStringAsFixed(2)}%'),
            Text('Sharpe Ratio: ${performance.sharpeRatio.toStringAsFixed(2)}'),
          ],
        ),
      ),
    );
  }

  Widget _buildPerformanceChart(BuildContext context) {
    // Create data points for the chart
    final trades = backtestResult!.trades;
    final dataPoints = trades.map((trade) {
      return FlSpot(
        trade.timestamp.millisecondsSinceEpoch.toDouble(),
        trade.price,
      );
    }).toList();

    return SizedBox(
      height: 300,
      child: LineChart(
        LineChartData(
          gridData: const FlGridData(show: false),
          titlesData: const FlTitlesData(show: false),
          borderData: FlBorderData(show: true),
          minX: dataPoints.first.x,
          maxX: dataPoints.last.x,
          minY: dataPoints.map((e) => e.y).reduce((a, b) => a < b ? a : b),
          maxY: dataPoints.map((e) => e.y).reduce((a, b) => a > b ? a : b),
          lineBarsData: [
            LineChartBarData(
              spots: dataPoints,
              isCurved: true,
              color: Colors.blue,
              barWidth: 2,
              isStrokeCapRound: true,
              dotData: const FlDotData(show: false),
              belowBarData: BarAreaData(show: false),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTradesList(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Trades',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        const SizedBox(height: 8),
        SizedBox(
          height: 200,
          child: ListView.builder(
            itemCount: backtestResult!.trades.length,
            itemBuilder: (context, index) {
              final trade = backtestResult!.trades[index];
              return ListTile(
                title: Text(
                    '${trade.type == CoreTradeType.buy ? 'Buy' : 'Sell'} ${trade.amount.toStringAsFixed(8)} ${trade.symbol}'),
                subtitle: Text('Price: \$${trade.price.toStringAsFixed(2)}'),
                trailing: Text(trade.timestamp.toString().split(' ')[0]),
              );
            },
          ),
        ),
      ],
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_control_panel.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_button.dart';

class StrategyControlPanel extends StatelessWidget {
  final bool isRunning;
  final VoidCallback onStartLive;
  final VoidCallback onStartDemo;
  final VoidCallback onStop;
  final VoidCallback onBacktest;

  const StrategyControlPanel({
    super.key,
    required this.isRunning,
    required this.onStartLive,
    required this.onStartDemo,
    required this.onStop,
    required this.onBacktest,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Strategy Control',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Wrap(
            spacing: 8.0,
            runSpacing: 8.0,
            children: [
              CustomButton(
                label: 'Start Live',
                onPressed: isRunning ? null : onStartLive,
                icon: Icons.play_arrow,
              ),
              CustomButton(
                label: 'Start Demo',
                onPressed: isRunning ? null : onStartDemo,
                icon: Icons.movie,
              ),
              CustomButton(
                label: 'Stop',
                onPressed: isRunning ? onStop : null,
                icon: Icons.stop,
                color: Colors.red,
              ),
              CustomButton(
                label: 'Run Backtest',
                onPressed: isRunning ? null : onBacktest,
                icon: Icons.history,
                color: Colors.orange,
              ),
            ],
          ),
          if (isRunning)
            const Padding(
              padding: EdgeInsets.only(top: 16.0),
              child: Text(
                'Strategy is currently running',
                style: TextStyle(
                  color: Colors.green,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
        ],
      ),
    );
  }
}
```

./lib/features/strategy/ui/widgets/strategy_parameters_form.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_text_field.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class StrategyParametersForm extends StatefulWidget {
  final StrategyParameters initialParameters;
  final Function(StrategyParameters) onParametersChanged;

  const StrategyParametersForm({
    super.key,
    required this.initialParameters,
    required this.onParametersChanged,
  });

  @override
  StrategyParametersFormState createState() => StrategyParametersFormState();
}

class StrategyParametersFormState extends State<StrategyParametersForm> {
  late TextEditingController _symbolController;
  late TextEditingController _investmentAmountController;
  late TextEditingController _purchaseFrequencyController;
  late TextEditingController _targetProfitPercentageController;
  late TextEditingController _stopLossPercentageController;
  late bool _useAutoMinTradeAmount;
  late bool _isVariableInvestmentAmount;
  late bool _reinvestProfits;

  @override
  void initState() {
    super.initState();
    _symbolController = TextEditingController(text: widget.initialParameters.symbol);
    _investmentAmountController = TextEditingController(text: widget.initialParameters.investmentAmount.toString());
    _purchaseFrequencyController = TextEditingController(text: widget.initialParameters.purchaseFrequency.toString());
    _targetProfitPercentageController = TextEditingController(text: widget.initialParameters.targetProfitPercentage.toString());
    _stopLossPercentageController = TextEditingController(text: widget.initialParameters.stopLossPercentage.toString());
    _useAutoMinTradeAmount = widget.initialParameters.useAutoMinTradeAmount;
    _isVariableInvestmentAmount = widget.initialParameters.isVariableInvestmentAmount;
    _reinvestProfits = widget.initialParameters.reinvestProfits;
  }

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Strategy Parameters',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          CustomTextField(
            controller: _symbolController,
            label: 'Trading Symbol (e.g., BTCUSDT)',
            onChanged: (_) => _updateParameters(),
          ),
          const SizedBox(height: 16),
          CustomTextField(
            controller: _investmentAmountController,
            label: 'Investment Amount per Purchase',
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          const SizedBox(height: 16),
          CustomTextField(
            controller: _purchaseFrequencyController,
            label: 'Purchase Frequency (in hours)',
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
            ),
          const SizedBox(height: 16),
          CustomTextField(
            controller: _targetProfitPercentageController,
            label: 'Target Profit (%)',
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          const SizedBox(height: 16),
          CustomTextField(
            controller: _stopLossPercentageController,
            label: 'Stop Loss (%)',
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          const SizedBox(height: 16),
          SwitchListTile(
            title: const Text('Use Auto Minimum Trade Amount'),
            value: _useAutoMinTradeAmount,
            onChanged: (value) {
              setState(() {
                _useAutoMinTradeAmount = value;
              });
              _updateParameters();
            },
          ),
          SwitchListTile(
            title: const Text('Use Variable Investment Amount'),
            value: _isVariableInvestmentAmount,
            onChanged: (value) {
              setState(() {
                _isVariableInvestmentAmount = value;
              });
              _updateParameters();
            },
          ),
          SwitchListTile(
            title: const Text('Reinvest Profits'),
            value: _reinvestProfits,
            onChanged: (value) {
              setState(() {
                _reinvestProfits = value;
              });
              _updateParameters();
            },
          ),
        ],
      ),
    );
  }

  void _updateParameters() {
    final updatedParameters = StrategyParameters(
      symbol: _symbolController.text,
      investmentAmount: double.tryParse(_investmentAmountController.text) ?? 0,
      purchaseFrequency: int.tryParse(_purchaseFrequencyController.text) ?? 0,
      targetProfitPercentage: double.tryParse(_targetProfitPercentageController.text) ?? 0,
      stopLossPercentage: double.tryParse(_stopLossPercentageController.text) ?? 0,
      useAutoMinTradeAmount: _useAutoMinTradeAmount,
      isVariableInvestmentAmount: _isVariableInvestmentAmount,
      reinvestProfits: _reinvestProfits,
      intervalDays: widget.initialParameters.intervalDays,
      maxInvestmentSize: widget.initialParameters.maxInvestmentSize,
      manualMinTradeAmount: widget.initialParameters.manualMinTradeAmount,
      variableInvestmentPercentage: widget.initialParameters.variableInvestmentPercentage,
    );
    widget.onParametersChanged(updatedParameters);
  }

  @override
  void dispose() {
    _symbolController.dispose();
    _investmentAmountController.dispose();
    _purchaseFrequencyController.dispose();
    _targetProfitPercentageController.dispose();
    _stopLossPercentageController.dispose();
    super.dispose();
  }
}
```

./lib/features/strategy/ui/widgets/backtest_progress_chart.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class BacktestProgressChart extends StatelessWidget {
  final List<FlSpot> spots;
  final double minY;
  final double maxY;

  const BacktestProgressChart({
    super.key,
    required this.spots,
    required this.minY,
    required this.maxY,
  });

  @override
  Widget build(BuildContext context) {
    return AspectRatio(
      aspectRatio: 1.70,
      child: LineChart(
        LineChartData(
          gridData: const FlGridData(show: false),
          titlesData: const FlTitlesData(show: false),
          borderData: FlBorderData(show: true),
          minX: 0,
          maxX: spots.length.toDouble() - 1,
          minY: minY,
          maxY: maxY,
          lineBarsData: [
            LineChartBarData(
              spots: spots,
              isCurved: true,
              color: Theme.of(context).primaryColor,
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: const FlDotData(show: false),
              belowBarData: BarAreaData(show: false),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/pages/strategy_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_event.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_parameters_form.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_monitor.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_control_panel.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/backtest_result_view.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_status.dart';
import 'package:cost_averaging_trading_app/ui/layouts/custom_page_layout.dart';

class StrategyPage extends StatelessWidget {
  const StrategyPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<StrategyBloc, StrategyState>(
      builder: (context, state) {
        return CustomPageLayout(
          title: 'Strategy',
          useSliver: true,
          children: _buildStrategyContent(context, state),
        );
      },
    );
  }

  List<Widget> _buildStrategyContent(
      BuildContext context, StrategyState state) {
    if (state is StrategyInitial) {
      context.read<StrategyBloc>().add(LoadStrategyData());
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is StrategyLoading) {
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is StrategyLoaded) {
      return [
        _buildStrategyStatus(context, state),
        const SizedBox(height: 16),
        _buildStrategyParametersForm(context, state),
        const SizedBox(height: 16),
        _buildStrategyControlPanel(context, state),
        const SizedBox(height: 16),
        if (state.status == StrategyStateStatus.active)
          _buildStrategyMonitor(state),
      ];
    } else if (state is BacktestCompleted) {
      return [BacktestResultView(result: state.result)];
    } else if (state is BacktestError) {
      return [Center(child: Text('Backtest Error: ${state.error}'))];
    } else if (state is StrategyError) {
      return [Center(child: Text('Strategy Error: ${state.message}'))];
    }
    return [const Center(child: Text('Unknown state'))];
  }

  Widget _buildStrategyStatus(BuildContext context, StrategyLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: StrategyStatusWidget(
          status: state.status == StrategyStateStatus.active
              ? StrategyStatus.active
              : StrategyStatus.inactive,
          onStart: () => context.read<StrategyBloc>().add(StartStrategyEvent()),
          onStop: () => context.read<StrategyBloc>().add(StopStrategy()),
          onSellEntirePortfolio: () => context.read<StrategyBloc>().add(
                SellEntirePortfolio(
                  symbol: state.parameters.symbol,
                  targetProfit: state.parameters.targetProfitPercentage,
                ),
              ),
        ),
      ),
    );
  }

  Widget _buildStrategyParametersForm(
      BuildContext context, StrategyLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: StrategyParametersForm(
          initialParameters: state.parameters,
          onParametersChanged: (parameters) {
            context
                .read<StrategyBloc>()
                .add(UpdateStrategyParameters(parameters));
          },
        ),
      ),
    );
  }

  Widget _buildStrategyControlPanel(
      BuildContext context, StrategyLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: StrategyControlPanel(
          isRunning: state.status == StrategyStateStatus.active,
          onStartLive: () =>
              context.read<StrategyBloc>().add(StartLiveStrategy()),
          onStartDemo: () =>
              context.read<StrategyBloc>().add(StartDemoStrategy()),
          onStop: () => context.read<StrategyBloc>().add(StopStrategy()),
          onBacktest: () => _showBacktestDialog(context),
        ),
      ),
    );
  }

  Widget _buildStrategyMonitor(StrategyLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: StrategyMonitor(
          totalInvested: state.totalInvested,
          currentProfit: state.currentProfit,
          tradeCount: state.tradeCount,
          averageBuyPrice: state.averageBuyPrice,
          currentMarketPrice: state.currentMarketPrice,
          recentTrades: state.recentTrades,
        ),
      ),
    );
  }

  void _showBacktestDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Run Backtest'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Select backtest period:'),
              ElevatedButton(
                child: const Text('Last 30 days'),
                onPressed: () {
                  Navigator.of(context).pop();
                  context.read<StrategyBloc>().add(RunBacktestEvent(
                        DateTime.now().subtract(const Duration(days: 30)),
                        DateTime.now(),
                      ));
                },
              ),
              ElevatedButton(
                child: const Text('Last 90 days'),
                onPressed: () {
                  Navigator.of(context).pop();
                  context.read<StrategyBloc>().add(RunBacktestEvent(
                        DateTime.now().subtract(const Duration(days: 90)),
                        DateTime.now(),
                      ));
                },
              ),
            ],
          ),
        );
      },
    );
  }
}

```

./lib/features/strategy/blocs/strategy_bloc.dart:
```
import 'package:cost_averaging_trading_app/core/services/trading_service.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_event.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';
import 'package:cost_averaging_trading_app/core/services/risk_management_service.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';

class StrategyBloc extends Bloc<StrategyEvent, StrategyState> {
  final StrategyRepository _strategyRepository;
  final RiskManagementService _riskManagementService;
  final BacktestingService _backtestingService;
  final TradingService _tradingService;

  StrategyBloc(
    this._strategyRepository,
    this._riskManagementService,
    this._backtestingService,
    this._tradingService,
  ) : super(StrategyInitial()) {
    on<LoadStrategyData>(_onLoadStrategyData);
    on<UpdateStrategyParameters>(_onUpdateStrategyParameters);
    on<StartStrategyEvent>(_onStartStrategy);
    on<StopStrategy>(_onStopStrategy);
    on<RunBacktestEvent>(_onRunBacktest);
    on<StartDemoStrategy>(_onStartDemoStrategy);
    on<StartLiveStrategy>(_onStartLiveStrategy);
    on<ForceStartStrategy>(_onForceStartStrategy);
    on<SellEntirePortfolio>(_onSellEntirePortfolio);
    on<UpdateUseAutoMinTradeAmount>(_onUpdateUseAutoMinTradeAmount);
    on<UpdateManualMinTradeAmount>(_onUpdateManualMinTradeAmount);
    on<UpdateIsVariableInvestmentAmount>(_onUpdateIsVariableInvestmentAmount);
    on<UpdateVariableInvestmentPercentage>(
        _onUpdateVariableInvestmentPercentage);
    on<UpdateReinvestProfits>(_onUpdateReinvestProfits);
    on<StartMonitoring>(_onStartMonitoring);
    on<StopMonitoring>(_onStopMonitoring);
    on<UpdateMonitoringData>(_onUpdateMonitoringData);
    // Carica i dati iniziali automaticamente
    add(LoadStrategyData());
  }

  Future<void> _onLoadStrategyData(
    LoadStrategyData event,
    Emitter<StrategyState> emit,
  ) async {
    try {
      emit(StrategyLoading());
      final parameters = await _strategyRepository.getStrategyParameters();
      final status = await _strategyRepository.getStrategyStatus();
      final chartData = await _strategyRepository.getStrategyChartData();
      final riskManagementSettings =
          await _riskManagementService.getRiskManagementSettings();
      final statistics = await _strategyRepository.getStrategyStatistics();
      final recentTrades = await _strategyRepository.getRecentTrades(10);

      emit(StrategyLoaded(
        parameters: parameters,
        status: status,
        chartData: chartData,
        riskManagementSettings: riskManagementSettings,
        totalInvested: statistics['totalInvested'] ?? 0,
        currentProfit: statistics['totalProfit'] ?? 0,
        tradeCount: statistics['totalTrades'] ?? 0,
        averageBuyPrice: statistics['averageBuyPrice'] ?? 0,
        currentMarketPrice:
            await _tradingService.getCurrentPrice(parameters.symbol),
        recentTrades: recentTrades,
      ));
    } catch (e) {
      emit(StrategyError('Failed to load strategy data: ${e.toString()}'));
    }
  }

  Future<void> _onUpdateStrategyParameters(
    UpdateStrategyParameters event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository.saveStrategyParameters(event.parameters);
        emit(currentState.copyWith(parameters: event.parameters));
      } catch (e) {
        emit(StrategyError(
            'Failed to update strategy parameters: ${e.toString()}'));
      }
    }
  }

  Future<void> _onStartStrategy(
    StartStrategyEvent event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        final isStrategySafe = await _riskManagementService
            .isStrategySafe(currentState.parameters);
        if (isStrategySafe) {
          await _strategyRepository
              .updateStrategyStatus(StrategyStateStatus.active);
          emit(currentState.copyWith(status: StrategyStateStatus.active));
        } else {
          emit(StrategyUnsafe(
            message:
                'Strategy is not safe to start based on current risk management settings.',
            parameters: currentState.parameters,
            status: currentState.status,
            chartData: currentState.chartData,
            riskManagementSettings: currentState.riskManagementSettings,
            isNowDemo: false,
          ));
        }
      } catch (e) {
        emit(StrategyError('Failed to start strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onStopStrategy(
    StopStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository
            .updateStrategyStatus(StrategyStateStatus.inactive);
        emit(currentState.copyWith(status: StrategyStateStatus.inactive));
      } catch (e) {
        emit(StrategyError('Failed to stop strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onRunBacktest(
      RunBacktestEvent event, Emitter<StrategyState> emit) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      emit(BacktestInProgress());

      try {
        final backtestResult = await _backtestingService.runBacktest(
          currentState.parameters.symbol,
          event.startDate,
          event.endDate,
          currentState.parameters,
          (progress, currentInvestmentOverTime) {
            emit(BacktestProgressUpdate(progress, currentInvestmentOverTime));
          },
        );
        emit(BacktestCompleted(backtestResult));
      } catch (e) {
        emit(BacktestError('Failed to run backtest: $e'));
      }
    } else {
      emit(const BacktestError('Strategy not loaded'));
    }
  }

  Future<void> _onStartDemoStrategy(
    StartDemoStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository
            .updateStrategyStatus(StrategyStateStatus.active);
        // Implementa la logica specifica per la modalità demo
        emit(currentState.copyWith(
            status: StrategyStateStatus.active, isDemo: true));
      } catch (e) {
        emit(StrategyError('Failed to start demo strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onStartLiveStrategy(
    StartLiveStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        final isStrategySafe = await _riskManagementService
            .isStrategySafe(currentState.parameters);
        if (isStrategySafe) {
          await _strategyRepository
              .updateStrategyStatus(StrategyStateStatus.active);
          emit(currentState.copyWith(
              status: StrategyStateStatus.active, isDemo: false));
        } else {
          emit(StrategyUnsafe(
            message:
                'Strategy is not safe to start in live mode based on current risk management settings.',
            parameters: currentState.parameters,
            status: currentState.status,
            chartData: currentState.chartData,
            riskManagementSettings: currentState.riskManagementSettings,
            isNowDemo: false,
          ));
        }
      } catch (e) {
        emit(StrategyError('Failed to start live strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onForceStartStrategy(
    ForceStartStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository
            .updateStrategyStatus(StrategyStateStatus.active);
        emit(currentState.copyWith(status: StrategyStateStatus.active));
      } catch (e) {
        emit(StrategyError('Failed to force start strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onSellEntirePortfolio(
    SellEntirePortfolio event,
    Emitter<StrategyState> emit,
  ) async {
    try {
      emit(StrategyLoading()); // Emettiamo uno stato di caricamento

      await _strategyRepository.sellEntirePortfolio(
        event.symbol,
        event.targetProfit,
        _tradingService,
      );

      // Otteniamo le statistiche aggiornate dopo la vendita
      final updatedStatistics =
          await _strategyRepository.getStrategyStatistics();

      // Emettiamo lo stato appropriato dopo la vendita
      emit(StrategyLoaded(
        parameters: (state as StrategyLoaded).parameters,
        status: StrategyStateStatus
            .inactive, // Assumiamo che la strategia sia ora inattiva
        chartData: (state as StrategyLoaded).chartData,
        riskManagementSettings:
            (state as StrategyLoaded).riskManagementSettings,
        totalInvested:
            0, // Il portafoglio è stato venduto, quindi l'investimento è 0
        currentProfit: updatedStatistics['totalProfit'] ?? 0,
        tradeCount: updatedStatistics['totalTrades'] ?? 0,
        averageBuyPrice: 0, // Non c'è più un prezzo medio di acquisto
        currentMarketPrice: await _tradingService.getCurrentPrice(event.symbol),
        recentTrades: await _strategyRepository
            .getRecentTrades(10), // Aggiorniamo le trade recenti
      ));

      // Potremmo anche voler emettere un evento di successo o mostrare una notifica
      // all'utente che la vendita è stata completata con successo
    } catch (e) {
      // Gestiamo l'errore e emettiamo lo stato appropriato
      emit(StrategyError('Failed to sell entire portfolio: ${e.toString()}'));

      // Potremmo anche voler loggare l'errore o mostrare una notifica all'utente
    }
  }

  void _onUpdateUseAutoMinTradeAmount(
    UpdateUseAutoMinTradeAmount event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        useAutoMinTradeAmount: event.useAutoMinTradeAmount,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateManualMinTradeAmount(
    UpdateManualMinTradeAmount event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        manualMinTradeAmount: event.manualMinTradeAmount,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateIsVariableInvestmentAmount(
    UpdateIsVariableInvestmentAmount event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        isVariableInvestmentAmount: event.isVariableInvestmentAmount,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateVariableInvestmentPercentage(
    UpdateVariableInvestmentPercentage event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        variableInvestmentPercentage: event.variableInvestmentPercentage,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateReinvestProfits(
    UpdateReinvestProfits event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        reinvestProfits: event.reinvestProfits,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  Future<void> _onStartMonitoring(
    StartMonitoring event,
    Emitter<StrategyState> emit,
  ) async {
    // Implementa la logica per iniziare il monitoraggio
  }

  Future<void> _onStopMonitoring(
    StopMonitoring event,
    Emitter<StrategyState> emit,
  ) async {
    // Implementa la logica per fermare il monitoraggio
  }

  void _onUpdateMonitoringData(
    UpdateMonitoringData event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      emit(currentState.copyWith(
        totalInvested: event.totalInvested ?? currentState.totalInvested,
        currentProfit: event.currentProfit ?? currentState.currentProfit,
        tradeCount: event.tradeCount ?? currentState.tradeCount,
        averageBuyPrice: event.averageBuyPrice ?? currentState.averageBuyPrice,
        currentMarketPrice:
            event.currentMarketPrice ?? currentState.currentMarketPrice,
        recentTrades: event.recentTrades ?? currentState.recentTrades,
      ));
    }
  }
}

class BacktestProgressUpdate extends StrategyState {
  final double progress;
  final List<Map<String, dynamic>> currentInvestmentOverTime;

  const BacktestProgressUpdate(this.progress, this.currentInvestmentOverTime);

  @override
  List<Object?> get props => [progress, currentInvestmentOverTime];
}

```

./lib/features/strategy/blocs/strategy_state.dart:
```
import 'package:cost_averaging_trading_app/core/models/risk_management_settings.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:equatable/equatable.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';

enum StrategyStateStatus { inactive, active, paused, backtesting }

abstract class StrategyState extends Equatable {
  const StrategyState();

  @override
  List<Object?> get props => [];
}

class StrategyInitial extends StrategyState {}

class StrategyLoading extends StrategyState {}

class StrategyLoaded extends StrategyState {
  final StrategyParameters parameters;
  final StrategyStateStatus status;
  final List<Map<String, dynamic>> chartData;
  final RiskManagementSettings riskManagementSettings;
  final BacktestResult? backtestResult;
  final double totalInvested;
  final double currentProfit;
  final int tradeCount;
  final double averageBuyPrice;
  final double currentMarketPrice;
  final List<CoreTrade> recentTrades;
  final bool isDemo;

  const StrategyLoaded({
    required this.parameters,
    required this.status,
    required this.chartData,
    required this.riskManagementSettings,
    this.backtestResult,
    this.totalInvested = 0,
    this.currentProfit = 0,
    this.tradeCount = 0,
    this.averageBuyPrice = 0,
    this.currentMarketPrice = 0,
    this.recentTrades = const [],
    this.isDemo = false,
  });

  StrategyLoaded copyWith({
    StrategyParameters? parameters,
    StrategyStateStatus? status,
    List<Map<String, dynamic>>? chartData,
    RiskManagementSettings? riskManagementSettings,
    BacktestResult? backtestResult,
    double? totalInvested,
    double? currentProfit,
    int? tradeCount,
    double? averageBuyPrice,
    double? currentMarketPrice,
    List<CoreTrade>? recentTrades,
    bool? isDemo,
  }) {
    return StrategyLoaded(
      parameters: parameters ?? this.parameters,
      status: status ?? this.status,
      chartData: chartData ?? this.chartData,
      riskManagementSettings:
          riskManagementSettings ?? this.riskManagementSettings,
      backtestResult: backtestResult ?? this.backtestResult,
      totalInvested: totalInvested ?? this.totalInvested,
      currentProfit: currentProfit ?? this.currentProfit,
      tradeCount: tradeCount ?? this.tradeCount,
      averageBuyPrice: averageBuyPrice ?? this.averageBuyPrice,
      currentMarketPrice: currentMarketPrice ?? this.currentMarketPrice,
      recentTrades: recentTrades ?? this.recentTrades,
      isDemo: isDemo ?? this.isDemo,
    );
  }

  @override
  List<Object?> get props => [
        parameters,
        status,
        chartData,
        riskManagementSettings,
        backtestResult,
        totalInvested,
        currentProfit,
        tradeCount,
        averageBuyPrice,
        currentMarketPrice,
        recentTrades
      ];
}

class StrategyError extends StrategyState {
  final String message;

  const StrategyError(this.message);

  @override
  List<Object> get props => [message];
}

class StrategyUnsafe extends StrategyLoaded {
  final String message;

  final bool isNowDemo;

  const StrategyUnsafe({
    required this.message,
    required super.parameters,
    required super.status,
    required super.chartData,
    required super.riskManagementSettings,
    required this.isNowDemo,
  });

  @override
  List<Object> get props => [super.props, message, isNowDemo];
}

class BacktestInProgress extends StrategyState {}

class BacktestCompleted extends StrategyState {
  final BacktestResult result;

  const BacktestCompleted(this.result);

  @override
  List<Object?> get props => [result];
}

class BacktestError extends StrategyState {
  final String error;

  const BacktestError(this.error);

  @override
  List<Object?> get props => [error];
}

```

./lib/features/strategy/blocs/strategy_event.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:equatable/equatable.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';

abstract class StrategyEvent extends Equatable {
  const StrategyEvent();

  @override
  List<Object?> get props => [];
}

class LoadStrategyData extends StrategyEvent {}

class UpdateStrategyParameters extends StrategyEvent {
  final StrategyParameters parameters;

  const UpdateStrategyParameters(this.parameters);

  @override
  List<Object?> get props => [parameters];
}

class UpdateStrategyStatus extends StrategyEvent {
  final StrategyStateStatus status;

  const UpdateStrategyStatus(this.status);

  @override
  List<Object?> get props => [status];
}

class RunBacktestEvent extends StrategyEvent {
  final DateTime startDate;
  final DateTime endDate;

  const RunBacktestEvent(this.startDate, this.endDate);

  @override
  List<Object?> get props => [startDate, endDate];
}

class StartDemoStrategy extends StrategyEvent {}

class StartLiveStrategy extends StrategyEvent {}

class StopStrategy extends StrategyEvent {}

class ForceStartStrategy extends StrategyEvent {}

class SellEntirePortfolio extends StrategyEvent {
  final String symbol;
  final double targetProfit;

  const SellEntirePortfolio({required this.symbol, required this.targetProfit});

  @override
  List<Object?> get props => [symbol, targetProfit];
}

// Nuovi eventi
class UpdateUseAutoMinTradeAmount extends StrategyEvent {
  final bool useAutoMinTradeAmount;

  const UpdateUseAutoMinTradeAmount(this.useAutoMinTradeAmount);

  @override
  List<Object?> get props => [useAutoMinTradeAmount];
}

class UpdateManualMinTradeAmount extends StrategyEvent {
  final double manualMinTradeAmount;

  const UpdateManualMinTradeAmount(this.manualMinTradeAmount);

  @override
  List<Object?> get props => [manualMinTradeAmount];
}

class UpdateIsVariableInvestmentAmount extends StrategyEvent {
  final bool isVariableInvestmentAmount;

  const UpdateIsVariableInvestmentAmount(this.isVariableInvestmentAmount);

  @override
  List<Object?> get props => [isVariableInvestmentAmount];
}

class UpdateVariableInvestmentPercentage extends StrategyEvent {
  final double variableInvestmentPercentage;

  const UpdateVariableInvestmentPercentage(this.variableInvestmentPercentage);

  @override
  List<Object?> get props => [variableInvestmentPercentage];
}

class UpdateReinvestProfits extends StrategyEvent {
  final bool reinvestProfits;

  const UpdateReinvestProfits(this.reinvestProfits);

  @override
  List<Object?> get props => [reinvestProfits];
}

class StartMonitoring extends StrategyEvent {}

class StopMonitoring extends StrategyEvent {}

class UpdateMonitoringData extends StrategyEvent {
  final double? totalInvested;
  final double? currentProfit;
  final int? tradeCount;
  final double? averageBuyPrice;
  final double? currentMarketPrice;
  final List<CoreTrade>? recentTrades;

  const UpdateMonitoringData({
    this.totalInvested,
    this.currentProfit,
    this.tradeCount,
    this.averageBuyPrice,
    this.currentMarketPrice,
    this.recentTrades,
  });

  @override
  List<Object?> get props => [
        totalInvested,
        currentProfit,
        tradeCount,
        averageBuyPrice,
        currentMarketPrice,
        recentTrades
      ];
}

class StartStrategyEvent extends StrategyEvent {}

class StopStrategyEvent extends StrategyEvent {}

```

./lib/features/strategy/repositories/strategy_repository.dart:
```
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/core/services/trading_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class StrategyRepository {
  final DatabaseService databaseService;

  StrategyRepository({
    required this.databaseService,
  });

  Future<void> saveStrategyParameters(StrategyParameters params) async {
    try {
      await databaseService.saveStrategyParameters(params);
    } catch (e) {
      throw Exception('Failed to save strategy parameters: $e');
    }
  }

  Future<void> sellEntirePortfolio(
      String symbol, double targetProfit, TradingService tradingService) async {
    await tradingService.sellEntirePortfolio(symbol, targetProfit);
  }

  Future<StrategyParameters> getStrategyParameters() async {
    try {
      final params = await databaseService.getStrategyParameters();
      return params ??
          StrategyParameters(
            symbol: 'BTCUSDT',
            investmentAmount: 100.0,
            intervalDays: 7,
            targetProfitPercentage: 5.0,
            stopLossPercentage: 3.0,
            purchaseFrequency: 1,
            maxInvestmentSize: 1000.0,
            useAutoMinTradeAmount: true,
            manualMinTradeAmount: 10.0,
            isVariableInvestmentAmount: false,
            variableInvestmentPercentage: 10.0,
            reinvestProfits: false,
          );
    } catch (e) {
      throw Exception('Failed to get strategy parameters: $e');
    }
  }

  Future<Map<String, dynamic>> getStrategyStatistics() async {
    try {
      final trades = await databaseService.query('trades');

      int totalTrades = trades.length;
      int profitableTrades = trades
          .where((t) => (t['price'] as num) > (t['averageEntryPrice'] as num))
          .length;
      double totalProfit = trades.fold(
          0.0,
          (sum, t) =>
              sum +
              ((t['price'] as num) - (t['averageEntryPrice'] as num)) *
                  (t['amount'] as num));
      double winRate = totalTrades > 0 ? profitableTrades / totalTrades : 0;

      int variableInvestmentTrades =
          trades.where((t) => t['isVariableInvestment'] == 1).length;

      double totalReinvestedProfit = trades
          .where((t) => t['reinvestedProfit'] != null)
          .fold(0.0, (sum, t) => sum + (t['reinvestedProfit'] as num));

      return {
        'totalTrades': totalTrades,
        'profitableTrades': profitableTrades,
        'totalProfit': totalProfit,
        'winRate': winRate,
        'variableInvestmentTrades': variableInvestmentTrades,
        'totalReinvestedProfit': totalReinvestedProfit,
      };
    } catch (e) {
      throw Exception('Failed to get strategy statistics: $e');
    }
  }

  Future<List<CoreTrade>> getRecentTrades(int limit) async {
    try {
      final trades = await databaseService.query('trades',
          orderBy: 'timestamp DESC', limit: limit);

      return trades.map((t) => CoreTrade.fromJson(t)).toList();
    } catch (e) {
      throw Exception('Failed to get recent trades: $e');
    }
  }

  Future<void> saveTradeWithNewFields(CoreTrade trade,
      bool isVariableInvestment, double? reinvestedProfit) async {
    try {
      Map<String, dynamic> tradeData = trade.toJson();
      tradeData['isVariableInvestment'] = isVariableInvestment ? 1 : 0;
      tradeData['reinvestedProfit'] = reinvestedProfit;

      await databaseService.insert('trades', tradeData);
    } catch (e) {
      throw Exception('Failed to save trade with new fields: $e');
    }
  }

  Future<void> updateStrategyStatus(StrategyStateStatus status) async {
    try {
      await databaseService.update(
          'strategy_status', {'status': status.toString().split('.').last});
    } catch (e) {
      throw Exception('Failed to update strategy status: $e');
    }
  }

  Future<StrategyParameters?> getActiveStrategy() async {
    try {
      final status = await getStrategyStatus();
      if (status == StrategyStateStatus.active) {
        return await getStrategyParameters();
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  Future<StrategyStateStatus> getStrategyStatus() async {
    try {
      final result = await databaseService.query('strategy_status');
      if (result.isNotEmpty) {
        final statusString = result.first['status'] as String;
        return StrategyStateStatus.values.firstWhere(
          (e) => e.toString().split('.').last == statusString,
          orElse: () => StrategyStateStatus.inactive,
        );
      }
      return StrategyStateStatus.inactive;
    } catch (e) {
      return StrategyStateStatus.inactive;
    }
  }

  Future<List<Map<String, dynamic>>> getStrategyChartData() async {
    try {
      final trades = await databaseService.query('trades',
          orderBy: 'timestamp DESC', limit: 100);

      return trades.map((trade) {
        return {
          'date':
              DateTime.fromMillisecondsSinceEpoch(trade['timestamp'] as int),
          'value': trade['price'],
        };
      }).toList();
    } catch (e) {
      throw Exception('Failed to get strategy chart data: $e');
    }
  }
}

```

./lib/features/strategy/models/strategy_parameters.dart:
```
import 'package:equatable/equatable.dart';

class StrategyParameters extends Equatable {
  final String symbol;
  final double investmentAmount;
  final int intervalDays;
  final double targetProfitPercentage;
  final double stopLossPercentage;
  final int purchaseFrequency;
  final double maxInvestmentSize;
  // Nuovi campi aggiunti
  final bool useAutoMinTradeAmount;
  final double manualMinTradeAmount;
  final bool isVariableInvestmentAmount;
  final double variableInvestmentPercentage;
  final bool reinvestProfits;

  StrategyParameters({
    required this.symbol,
    required this.investmentAmount,
    required this.intervalDays,
    required this.targetProfitPercentage,
    required this.stopLossPercentage,
    required this.purchaseFrequency,
    required this.maxInvestmentSize,
    // Nuovi campi aggiunti al costruttore
    this.useAutoMinTradeAmount = true,
    this.manualMinTradeAmount = 0.0,
    this.isVariableInvestmentAmount = false,
    this.variableInvestmentPercentage = 0.0,
    this.reinvestProfits = false,
  }) {
    assert(investmentAmount > 0, 'Investment amount must be positive');
    assert(intervalDays > 0, 'Interval days must be positive');
    assert(targetProfitPercentage > 0 && targetProfitPercentage <= 100,
        'Target profit must be between 0 and 100');
    assert(stopLossPercentage > 0 && stopLossPercentage <= 100,
        'Stop loss must be between 0 and 100');
    assert(purchaseFrequency > 0, 'Purchase frequency must be positive');
    assert(maxInvestmentSize > 0, 'Max investment size must be positive');
    // Nuove asserzioni per i nuovi campi
    assert(manualMinTradeAmount >= 0,
        'Manual min trade amount must be non-negative');
    assert(
        variableInvestmentPercentage >= 0 &&
            variableInvestmentPercentage <= 100,
        'Variable investment percentage must be between 0 and 100');
  }

  @override
  List<Object?> get props => [
        symbol,
        investmentAmount,
        intervalDays,
        targetProfitPercentage,
        stopLossPercentage,
        purchaseFrequency,
        maxInvestmentSize,
        // Nuovi campi aggiunti alla lista props
        useAutoMinTradeAmount,
        manualMinTradeAmount,
        isVariableInvestmentAmount,
        variableInvestmentPercentage,
        reinvestProfits,
      ];

  StrategyParameters copyWith({
    String? symbol,
    double? investmentAmount,
    int? intervalDays,
    double? targetProfitPercentage,
    double? stopLossPercentage,
    int? purchaseFrequency,
    double? maxInvestmentSize,
    // Nuovi campi aggiunti al metodo copyWith
    bool? useAutoMinTradeAmount,
    double? manualMinTradeAmount,
    bool? isVariableInvestmentAmount,
    double? variableInvestmentPercentage,
    bool? reinvestProfits,
  }) {
    return StrategyParameters(
      symbol: symbol ?? this.symbol,
      investmentAmount: investmentAmount ?? this.investmentAmount,
      intervalDays: intervalDays ?? this.intervalDays,
      targetProfitPercentage:
          targetProfitPercentage ?? this.targetProfitPercentage,
      stopLossPercentage: stopLossPercentage ?? this.stopLossPercentage,
      purchaseFrequency: purchaseFrequency ?? this.purchaseFrequency,
      maxInvestmentSize: maxInvestmentSize ?? this.maxInvestmentSize,
      // Nuovi campi aggiunti al metodo copyWith
      useAutoMinTradeAmount:
          useAutoMinTradeAmount ?? this.useAutoMinTradeAmount,
      manualMinTradeAmount: manualMinTradeAmount ?? this.manualMinTradeAmount,
      isVariableInvestmentAmount:
          isVariableInvestmentAmount ?? this.isVariableInvestmentAmount,
      variableInvestmentPercentage:
          variableInvestmentPercentage ?? this.variableInvestmentPercentage,
      reinvestProfits: reinvestProfits ?? this.reinvestProfits,
    );
  }

  factory StrategyParameters.fromJson(Map<String, dynamic> json) {
    return StrategyParameters(
      symbol: json['symbol'],
      investmentAmount: json['investmentAmount'],
      intervalDays: json['intervalDays'],
      targetProfitPercentage: json['targetProfitPercentage'],
      stopLossPercentage: json['stopLossPercentage'],
      purchaseFrequency: json['purchaseFrequency'],
      maxInvestmentSize: json['maxInvestmentSize'],
      // Nuovi campi aggiunti al metodo fromJson
      useAutoMinTradeAmount: json['useAutoMinTradeAmount'] ?? true,
      manualMinTradeAmount: json['manualMinTradeAmount'] ?? 0.0,
      isVariableInvestmentAmount: json['isVariableInvestmentAmount'] ?? false,
      variableInvestmentPercentage: json['variableInvestmentPercentage'] ?? 0.0,
      reinvestProfits: json['reinvestProfits'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'symbol': symbol,
      'investmentAmount': investmentAmount,
      'intervalDays': intervalDays,
      'targetProfitPercentage': targetProfitPercentage,
      'stopLossPercentage': stopLossPercentage,
      'purchaseFrequency': purchaseFrequency,
      'maxInvestmentSize': maxInvestmentSize,
      // Nuovi campi aggiunti al metodo toJson
      'useAutoMinTradeAmount': useAutoMinTradeAmount,
      'manualMinTradeAmount': manualMinTradeAmount,
      'isVariableInvestmentAmount': isVariableInvestmentAmount,
      'variableInvestmentPercentage': variableInvestmentPercentage,
      'reinvestProfits': reinvestProfits,
    };
  }
}

```

./lib/features/strategy/models/strategy_model.dart:
```
class StrategyModel {
  final double initialCapital;
  final double riskPercentage;
  final double minProfitTarget;
  final double maxLossPercentage;
  final int maxTrades;
  final bool isActive;

  StrategyModel({
    required this.initialCapital,
    required this.riskPercentage,
    required this.minProfitTarget,
    required this.maxLossPercentage,
    required this.maxTrades,
    required this.isActive,
  });

  StrategyModel copyWith({
    double? initialCapital,
    double? riskPercentage,
    double? minProfitTarget,
    double? maxLossPercentage,
    int? maxTrades,
    bool? isActive,
  }) {
    return StrategyModel(
      initialCapital: initialCapital ?? this.initialCapital,
      riskPercentage: riskPercentage ?? this.riskPercentage,
      minProfitTarget: minProfitTarget ?? this.minProfitTarget,
      maxLossPercentage: maxLossPercentage ?? this.maxLossPercentage,
      maxTrades: maxTrades ?? this.maxTrades,
      isActive: isActive ?? this.isActive,
    );
  }
}

```

./lib/features/chart/blocs/chart_event.dart:
```
import 'package:equatable/equatable.dart';
import 'package:candlesticks/candlesticks.dart';

abstract class ChartEvent extends Equatable {
  const ChartEvent();

  @override
  List<Object> get props => [];
}

class LoadChartData extends ChartEvent {}

class UpdateChartData extends ChartEvent {
  final Candle latestCandle;

  const UpdateChartData({required this.latestCandle});

  @override
  List<Object> get props => [latestCandle];
}

class ChangeInterval extends ChartEvent {
  final String interval;

  const ChangeInterval(this.interval);

  @override
  List<Object> get props => [interval];
}

class ToggleOrderMarkers extends ChartEvent {}

class UpdateTicker extends ChartEvent {
  final Map<String, dynamic> tickerData;
  const UpdateTicker(this.tickerData);

  @override
  List<Object> get props => [tickerData];
}
```

./lib/features/chart/blocs/chart_state.dart:
```
import 'package:equatable/equatable.dart';
import 'package:candlesticks/candlesticks.dart';

abstract class ChartState extends Equatable {
  const ChartState();

  @override
  List<Object> get props => [];
}

class ChartLoading extends ChartState {}

class ChartLoaded extends ChartState {
  final List<Candle> candles;
  final String interval;
  final bool showOrderMarkers;

  const ChartLoaded({
    required this.candles,
    required this.interval,
    required this.showOrderMarkers,
  });

  @override
  List<Object> get props => [candles, interval, showOrderMarkers];
}

class ChartError extends ChartState {
  final String message;

  const ChartError({required this.message});

  @override
  List<Object> get props => [message];
}

```

./lib/features/chart/blocs/chart_bloc.dart:
```
import 'dart:async';
import 'package:candlesticks/candlesticks.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_event.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_state.dart';

class ChartBloc extends Bloc<ChartEvent, ChartState> {
  final ApiService _apiService;
  final String symbol;
  StreamSubscription<Map<String, dynamic>>? _klineSubscription;
  static const List<String> intervals = [
    '1m',
    '3m',
    '5m',
    '15m',
    '30m',
    '1h',
    '2h',
    '4h',
    '6h',
    '8h',
    '12h',
    '1d',
    '3d',
    '1w',
    '1M'
  ];

  ChartBloc({required this.symbol, required ApiService apiService})
      : _apiService = apiService,
        super(ChartLoading()) {
    on<LoadChartData>(_onLoadChartData);
    on<UpdateChartData>(_onUpdateChartData);
    on<ChangeInterval>(_onChangeInterval);
    on<ToggleOrderMarkers>(_onToggleOrderMarkers);
  }

  Future<void> _onLoadChartData(
      LoadChartData event, Emitter<ChartState> emit) async {
    try {
      emit(ChartLoading());
      final candles = await _fetchInitialCandles();
      _subscribeToKlineUpdates('1m');
      emit(ChartLoaded(
          candles: candles, interval: '1m', showOrderMarkers: true));
    } catch (e) {
      emit(ChartError(message: e.toString()));
    }
  }

  void _onUpdateChartData(UpdateChartData event, Emitter<ChartState> emit) {
    if (state is ChartLoaded) {
      final currentState = state as ChartLoaded;
      List<Candle> updatedCandles = List.from(currentState.candles);

      if (updatedCandles.isNotEmpty &&
          updatedCandles[0].date == event.latestCandle.date &&
          updatedCandles[0].open == event.latestCandle.open) {
        // Update last candle
        updatedCandles[0] = event.latestCandle;
      } else if (event.latestCandle.date.difference(updatedCandles[0].date) ==
          updatedCandles[0].date.difference(updatedCandles[1].date)) {
        // Add new candle
        updatedCandles.insert(0, event.latestCandle);
        if (updatedCandles.length > 100) {
          updatedCandles.removeLast();
        }
      }

      emit(ChartLoaded(
        candles: updatedCandles,
        interval: currentState.interval,
        showOrderMarkers: currentState.showOrderMarkers,
      ));
    }
  }

  Future<void> _onChangeInterval(
      ChangeInterval event, Emitter<ChartState> emit) async {
    try {
      emit(ChartLoading());
      final candles = await _fetchInitialCandles(interval: event.interval);
      _subscribeToKlineUpdates(event.interval);
      emit(ChartLoaded(
        candles: candles,
        interval: event.interval,
        showOrderMarkers: (state as ChartLoaded).showOrderMarkers,
      ));
    } catch (e) {
      emit(ChartError(message: e.toString()));
    }
  }

  void _onToggleOrderMarkers(
      ToggleOrderMarkers event, Emitter<ChartState> emit) {
    if (state is ChartLoaded) {
      final currentState = state as ChartLoaded;
      emit(ChartLoaded(
        candles: currentState.candles,
        interval: currentState.interval,
        showOrderMarkers: !currentState.showOrderMarkers,
      ));
    }
  }

  Future<List<Candle>> _fetchInitialCandles({String interval = '1m'}) async {
    final klines = await _apiService.getKlines(
      symbol: symbol,
      interval: interval,
      limit: 100,
    );
    return klines
        .map((kline) {
          try {
            return Candle(
              date: DateTime.fromMillisecondsSinceEpoch(kline[0]),
              high: double.parse(kline[2]),
              low: double.parse(kline[3]),
              open: double.parse(kline[1]),
              close: double.parse(kline[4]),
              volume: double.parse(kline[5]),
            );
          } catch (e) {
            return null;
          }
        })
        .where((candle) => candle != null)
        .cast<Candle>()
        .toList()
        .reversed
        .toList();
  }

  void _subscribeToKlineUpdates(String interval) {
    _klineSubscription?.cancel();
    _klineSubscription =
        _apiService.getKlineStream(symbol, interval).listen((event) {
      if (event['e'] == 'kline') {
        final kline = event['k'];
        final candle = Candle(
          date: DateTime.fromMillisecondsSinceEpoch(kline['t']),
          high: double.parse(kline['h']),
          low: double.parse(kline['l']),
          open: double.parse(kline['o']),
          close: double.parse(kline['c']),
          volume: double.parse(kline['v']),
        );
        add(UpdateChartData(latestCandle: candle));
      }
    });
  }

  @override
  Future<void> close() {
    _klineSubscription?.cancel();
    return super.close();
  }
}

```

./lib/features/settings/ui/widgets/backtesting_settings.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_button.dart';

class BacktestingSettings extends StatelessWidget {
  final bool isBacktestingEnabled;
  final VoidCallback onToggleBacktesting;
  final VoidCallback onRunBacktest;

  const BacktestingSettings({
    super.key,
    required this.isBacktestingEnabled,
    required this.onToggleBacktesting,
    required this.onRunBacktest,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Backtesting',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SwitchListTile(
            title: const Text('Enable Backtesting'),
            value: isBacktestingEnabled,
            onChanged: (value) => onToggleBacktesting(),
          ),
          const SizedBox(height: 16),
          CustomButton(
            label: 'Run Backtest',
            onPressed: isBacktestingEnabled ? onRunBacktest : null,
            icon: Icons.play_arrow,
          ),
        ],
      ),
    );
  }
}
```

./lib/features/settings/ui/widgets/api_settings.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_text_field.dart';

class ApiSettings extends StatelessWidget {
  final String apiKey;
  final String secretKey;
  final Function(String) onApiKeyChanged;
  final Function(String) onSecretKeyChanged;

  const ApiSettings({
    super.key,
    required this.apiKey,
    required this.secretKey,
    required this.onApiKeyChanged,
    required this.onSecretKeyChanged,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'API Settings',
      child: Column(
        children: [
          CustomTextField(
            label: 'API Key',
            value: apiKey,
            onChanged: onApiKeyChanged,
            icon: Icons.vpn_key,
          ),
          const SizedBox(height: 16),
          CustomTextField(
            label: 'Secret Key',
            value: secretKey,
            onChanged: onSecretKeyChanged,
            icon: Icons.lock,
            obscureText: true,
          ),
        ],
      ),
    );
  }
}
```

./lib/features/settings/ui/widgets/demo_mode_toggle.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class DemoModeToggle extends StatelessWidget {
  final bool isDemoMode;
  final ValueChanged<bool> onToggle;

  const DemoModeToggle({
    super.key,
    required this.isDemoMode,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Trading Mode',
      child: SwitchListTile(
        title: const Text('Demo Mode'),
        subtitle: const Text('Practice trading without real funds'),
        value: isDemoMode,
        onChanged: onToggle,
      ),
    );
  }
}
```

./lib/features/settings/ui/widgets/risk_management.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class RiskManagement extends StatelessWidget {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;
  final Function(double, int, double, double, double, int) onUpdateRiskManagement;

  const RiskManagement({
    super.key,
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
    required this.onUpdateRiskManagement,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Risk Management',
      child: Column(
        children: [
          _buildSlider(
            context,
            'Max Loss Percentage',
            maxLossPercentage,
            0.0,
            10.0,
            Icons.trending_down,
            (value) => onUpdateRiskManagement(value, maxConcurrentTrades, maxPositionSizePercentage, dailyExposureLimit, maxAllowedVolatility, maxRebuyCount),
          ),
          _buildSlider(
            context,
            'Max Concurrent Trades',
            maxConcurrentTrades.toDouble(),
            1,
            10,
            Icons.swap_horiz,
            (value) => onUpdateRiskManagement(maxLossPercentage, value.toInt(), maxPositionSizePercentage, dailyExposureLimit, maxAllowedVolatility, maxRebuyCount),
          ),
          _buildSlider(
            context,
            'Max Position Size Percentage',
            maxPositionSizePercentage,
            1.0,
            100.0,
            Icons.account_balance,
            (value) => onUpdateRiskManagement(maxLossPercentage, maxConcurrentTrades, value, dailyExposureLimit, maxAllowedVolatility, maxRebuyCount),
          ),
          _buildSlider(
            context,
            'Daily Exposure Limit',
            dailyExposureLimit,
            100.0,
            10000.0,
            Icons.today,
            (value) => onUpdateRiskManagement(maxLossPercentage, maxConcurrentTrades, maxPositionSizePercentage, value, maxAllowedVolatility, maxRebuyCount),
          ),
          _buildSlider(
            context,
            'Max Allowed Volatility',
            maxAllowedVolatility,
            0.0,
            1.0,
            Icons.show_chart,
            (value) => onUpdateRiskManagement(maxLossPercentage, maxConcurrentTrades, maxPositionSizePercentage, dailyExposureLimit, value, maxRebuyCount),
          ),
          _buildSlider(
            context,
            'Max Rebuy Count',
            maxRebuyCount.toDouble(),
            1,
            10,
            Icons.refresh,
            (value) => onUpdateRiskManagement(maxLossPercentage, maxConcurrentTrades, maxPositionSizePercentage, dailyExposureLimit, maxAllowedVolatility, value.toInt()),
          ),
        ],
      ),
    );
  }

  Widget _buildSlider(BuildContext context, String label, double value, double min, double max, IconData icon, Function(double) onChanged) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, size: 20),
            const SizedBox(width: 8),
            Text(label, style: Theme.of(context).textTheme.titleMedium),
          ],
        ),
        Slider(
          value: value,
          min: min,
          max: max,
          divisions: 100,
          label: value.toStringAsFixed(2),
          onChanged: onChanged,
        ),
        Text(value.toStringAsFixed(2), style: Theme.of(context).textTheme.bodySmall),
        const SizedBox(height: 16),
      ],
    );
  }
}
```

./lib/features/settings/ui/pages/settings_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_state.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_event.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/api_settings.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/backtesting_settings.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/demo_mode_toggle.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/risk_management.dart';
import 'package:cost_averaging_trading_app/ui/layouts/custom_page_layout.dart';

class SettingsPage extends StatelessWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<SettingsBloc, SettingsState>(
      listener: (context, state) {
        if (state is SettingsError) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.message)),
          );
        }
      },
      builder: (context, state) {
        return CustomPageLayout(
          title: 'Settings',
          useSliver: false,
          children: [
            _buildSearchBar(context),
            const SizedBox(height: 16),
            _buildApiSettings(context, state),
            const SizedBox(height: 16),
            _buildDemoModeToggle(context, state),
            const SizedBox(height: 16),
            _buildBacktestingSettings(context, state),
            const SizedBox(height: 16),
            _buildRiskManagement(context, state),
          ],
        );
      },
    );
  }

  Widget _buildSearchBar(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: TextField(
          decoration: const InputDecoration(
            hintText: 'Search settings...',
            prefixIcon: Icon(Icons.search),
            border: InputBorder.none,
          ),
          onChanged: (value) {
            // Implement search functionality
          },
        ),
      ),
    );
  }

  Widget _buildApiSettings(BuildContext context, SettingsState state) {
    if (state is SettingsLoaded) {
      return ApiSettings(
        apiKey: state.apiKey,
        secretKey: state.secretKey,
        onApiKeyChanged: (newKey) {
          context.read<SettingsBloc>().add(UpdateApiKey(newKey));
        },
        onSecretKeyChanged: (newKey) {
          context.read<SettingsBloc>().add(UpdateSecretKey(newKey));
        },
      );
    }
    return const SizedBox.shrink();
  }

  Widget _buildDemoModeToggle(BuildContext context, SettingsState state) {
    if (state is SettingsLoaded) {
      return DemoModeToggle(
        isDemoMode: state.isDemoMode,
        onToggle: (isDemo) {
          context.read<SettingsBloc>().add(ToggleDemoMode());
        },
      );
    }
    return const SizedBox.shrink();
  }

  Widget _buildBacktestingSettings(BuildContext context, SettingsState state) {
    if (state is SettingsLoaded) {
      return BacktestingSettings(
        isBacktestingEnabled: state.isBacktestingEnabled,
        onToggleBacktesting: () {
          context.read<SettingsBloc>().add(ToggleBacktesting());
        },
        onRunBacktest: () {
          // Implement backtesting logic
        },
      );
    }
    return const SizedBox.shrink();
  }

  Widget _buildRiskManagement(BuildContext context, SettingsState state) {
    if (state is SettingsLoaded) {
      return RiskManagement(
        maxLossPercentage: state.maxLossPercentage,
        maxConcurrentTrades: state.maxConcurrentTrades,
        maxPositionSizePercentage: state.maxPositionSizePercentage,
        dailyExposureLimit: state.dailyExposureLimit,
        maxAllowedVolatility: state.maxAllowedVolatility,
        maxRebuyCount: state.maxRebuyCount,
        onUpdateRiskManagement: (
          maxLoss,
          maxTrades,
          maxPositionSize,
          dailyExposure,
          maxVolatility,
          rebuyCount,
        ) {
          context.read<SettingsBloc>().add(UpdateRiskManagement(
                maxLoss,
                maxTrades,
                maxPositionSize,
                dailyExposure,
                maxVolatility,
                rebuyCount,
              ));
        },
      );
    }
    return const SizedBox.shrink();
  }
}

```

./lib/features/settings/blocs/settings_event.dart:
```
// lib/features/settings/blocs/settings_event.dart

import 'package:equatable/equatable.dart';

abstract class SettingsEvent extends Equatable {
  const SettingsEvent();

  @override
  List<Object> get props => [];
}

class LoadSettings extends SettingsEvent {}

class UpdateApiKey extends SettingsEvent {
  final String apiKey;

  const UpdateApiKey(this.apiKey);

  @override
  List<Object> get props => [apiKey];
}

class UpdateSecretKey extends SettingsEvent {
  final String secretKey;

  const UpdateSecretKey(this.secretKey);

  @override
  List<Object> get props => [secretKey];
}

class ToggleDemoMode extends SettingsEvent {}

class ToggleBacktesting extends SettingsEvent {}

class UpdateRiskManagement extends SettingsEvent {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  const UpdateRiskManagement(
    this.maxLossPercentage,
    this.maxConcurrentTrades,
    this.maxPositionSizePercentage,
    this.dailyExposureLimit,
    this.maxAllowedVolatility,
    this.maxRebuyCount,
  );

  @override
  List<Object> get props => [
        maxLossPercentage,
        maxConcurrentTrades,
        maxPositionSizePercentage,
        dailyExposureLimit,
        maxAllowedVolatility,
        maxRebuyCount,
      ];
}

```

./lib/features/settings/blocs/settings_state.dart:
```
// lib/features/settings/blocs/settings_state.dart

import 'package:equatable/equatable.dart';

abstract class SettingsState extends Equatable {
  const SettingsState();

  @override
  List<Object> get props => [];
}

class SettingsInitial extends SettingsState {}

class SettingsLoading extends SettingsState {}

class SettingsLoaded extends SettingsState {
  final String apiKey;
  final String secretKey;
  final bool isDemoMode;
  final bool isBacktestingEnabled;
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  const SettingsLoaded({
    required this.apiKey,
    required this.secretKey,
    required this.isDemoMode,
    required this.isBacktestingEnabled,
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
  });

  @override
  List<Object> get props => [
        apiKey,
        secretKey,
        isDemoMode,
        isBacktestingEnabled,
        maxLossPercentage,
        maxConcurrentTrades,
        maxPositionSizePercentage,
        dailyExposureLimit,
        maxAllowedVolatility,
        maxRebuyCount,
      ];
}

class SettingsError extends SettingsState {
  final String message;

  const SettingsError(this.message);

  @override
  List<Object> get props => [message];
}

```

./lib/features/settings/blocs/settings_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_event.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_state.dart';
import 'package:cost_averaging_trading_app/features/settings/repositories/settings_repository.dart';

class SettingsBloc extends Bloc<SettingsEvent, SettingsState> {
  final SettingsRepository _repository;

  SettingsBloc(this._repository) : super(SettingsInitial()) {
    on<LoadSettings>(_onLoadSettings);
    on<UpdateApiKey>(_onUpdateApiKey);
    on<UpdateSecretKey>(_onUpdateSecretKey);
    on<ToggleDemoMode>(_onToggleDemoMode);
    on<ToggleBacktesting>(_onToggleBacktesting);
    on<UpdateRiskManagement>(_onUpdateRiskManagement);
    add(LoadSettings());
  }

  Future<void> _onLoadSettings(
    LoadSettings event,
    Emitter<SettingsState> emit,
  ) async {
    emit(SettingsLoading());
    try {
      final settings = await _repository.getSettings();
      emit(SettingsLoaded(
        apiKey: settings.apiKey,
        secretKey: settings.secretKey,
        isDemoMode: settings.isDemoMode,
        isBacktestingEnabled: settings.isBacktestingEnabled,
        maxLossPercentage: settings.maxLossPercentage,
        maxConcurrentTrades: settings.maxConcurrentTrades,
        maxPositionSizePercentage: settings.maxPositionSizePercentage,
        dailyExposureLimit: settings.dailyExposureLimit,
        maxAllowedVolatility: settings.maxAllowedVolatility,
        maxRebuyCount: settings.maxRebuyCount,
      ));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error loading settings', e, stackTrace);
      emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }

  Future<void> _onUpdateApiKey(
    UpdateApiKey event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        await _repository.updateApiKey(event.apiKey);
        emit(SettingsLoaded(
          apiKey: event.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error updating API key', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onUpdateSecretKey(
    UpdateSecretKey event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        await _repository.updateSecretKey(event.secretKey);
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: event.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error updating Secret key', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onToggleDemoMode(
    ToggleDemoMode event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        final newDemoMode = !currentState.isDemoMode;
        await _repository.updateDemoMode(newDemoMode);
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: newDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error toggle demoMode settings', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onToggleBacktesting(
    ToggleBacktesting event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        final newBacktestingMode = !currentState.isBacktestingEnabled;
        await _repository.updateBacktestingMode(newBacktestingMode);
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: newBacktestingMode,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError(
            'Error toggle backtesting settings', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onUpdateRiskManagement(
    UpdateRiskManagement event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        await _repository.updateRiskManagement(
          maxLossPercentage: event.maxLossPercentage,
          maxConcurrentTrades: event.maxConcurrentTrades,
          maxPositionSizePercentage: event.maxPositionSizePercentage,
          dailyExposureLimit: event.dailyExposureLimit,
          maxAllowedVolatility: event.maxAllowedVolatility,
          maxRebuyCount: event.maxRebuyCount,
        );
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: event.maxLossPercentage,
          maxConcurrentTrades: event.maxConcurrentTrades,
          maxPositionSizePercentage: event.maxPositionSizePercentage,
          dailyExposureLimit: event.dailyExposureLimit,
          maxAllowedVolatility: event.maxAllowedVolatility,
          maxRebuyCount: event.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError(
            'Error updating risk management settings', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }
}

```

./lib/features/settings/repositories/settings_repository.dart:
```
// lib/features/settings/repositories/settings_repository.dart

import 'package:cost_averaging_trading_app/core/services/secure_storage_service.dart';
import 'package:cost_averaging_trading_app/features/settings/models/settings_model.dart';

class SettingsRepository {
  final SecureStorageService _secureStorage;

  SettingsRepository(this._secureStorage);

   Future<SettingsModel> getSettings() async {
    final apiKey = await _secureStorage.getApiKey() ?? '';
    final secretKey = await _secureStorage.getSecretKey() ?? '';
    final isDemoMode = await _secureStorage.getValue('isDemoMode') == 'true';
    final isBacktestingEnabled = await _secureStorage.getValue('isBacktestingEnabled') == 'true';
    final maxLossPercentage = double.parse(await _secureStorage.getValue('maxLossPercentage') ?? '2.0');
    final maxConcurrentTrades = int.parse(await _secureStorage.getValue('maxConcurrentTrades') ?? '3');
    final maxPositionSizePercentage = double.parse(await _secureStorage.getValue('maxPositionSizePercentage') ?? '5.0');
    final dailyExposureLimit = double.parse(await _secureStorage.getValue('dailyExposureLimit') ?? '1000.0');
    final maxAllowedVolatility = double.parse(await _secureStorage.getValue('maxAllowedVolatility') ?? '0.05');
    final maxRebuyCount = int.parse(await _secureStorage.getValue('maxRebuyCount') ?? '3');
    final maxVariableInvestmentPercentage = double.parse(await _secureStorage.getValue('maxVariableInvestmentPercentage') ?? '20.0');

    return SettingsModel(
      apiKey: apiKey,
      secretKey: secretKey,
      isDemoMode: isDemoMode,
      isBacktestingEnabled: isBacktestingEnabled,
      maxLossPercentage: maxLossPercentage,
      maxConcurrentTrades: maxConcurrentTrades,
      maxPositionSizePercentage: maxPositionSizePercentage,
      dailyExposureLimit: dailyExposureLimit,
      maxAllowedVolatility: maxAllowedVolatility,
      maxRebuyCount: maxRebuyCount,
      maxVariableInvestmentPercentage: maxVariableInvestmentPercentage,
    );
  }

  Future<void> updateSettings(SettingsModel settings) async {
    await _secureStorage.saveApiKey(settings.apiKey);
    await _secureStorage.saveSecretKey(settings.secretKey);
    await _secureStorage.saveValue('isDemoMode', settings.isDemoMode.toString());
    await _secureStorage.saveValue('isBacktestingEnabled', settings.isBacktestingEnabled.toString());
    await _secureStorage.saveValue('maxLossPercentage', settings.maxLossPercentage.toString());
    await _secureStorage.saveValue('maxConcurrentTrades', settings.maxConcurrentTrades.toString());
    await _secureStorage.saveValue('maxPositionSizePercentage', settings.maxPositionSizePercentage.toString());
    await _secureStorage.saveValue('dailyExposureLimit', settings.dailyExposureLimit.toString());
    await _secureStorage.saveValue('maxAllowedVolatility', settings.maxAllowedVolatility.toString());
    await _secureStorage.saveValue('maxRebuyCount', settings.maxRebuyCount.toString());
    await _secureStorage.saveValue('maxVariableInvestmentPercentage', settings.maxVariableInvestmentPercentage.toString());
  }

  Future<void> updateApiKey(String apiKey) async {
    await _secureStorage.saveApiKey(apiKey);
  }

  Future<void> updateSecretKey(String secretKey) async {
    await _secureStorage.saveSecretKey(secretKey);
  }

  Future<void> updateDemoMode(bool isDemoMode) async {
    await _secureStorage.saveValue('isDemoMode', isDemoMode.toString());
  }

  Future<void> updateBacktestingMode(bool isBacktestingEnabled) async {
    await _secureStorage.saveValue(
        'isBacktestingEnabled', isBacktestingEnabled.toString());
  }

  Future<void> updateRiskManagement({
    required double maxLossPercentage,
    required int maxConcurrentTrades,
    required double maxPositionSizePercentage,
    required double dailyExposureLimit,
    required double maxAllowedVolatility,
    required int maxRebuyCount,
  }) async {
    await _secureStorage.saveValue(
        'maxLossPercentage', maxLossPercentage.toString());
    await _secureStorage.saveValue(
        'maxConcurrentTrades', maxConcurrentTrades.toString());
    await _secureStorage.saveValue(
        'maxPositionSizePercentage', maxPositionSizePercentage.toString());
    await _secureStorage.saveValue(
        'dailyExposureLimit', dailyExposureLimit.toString());
    await _secureStorage.saveValue(
        'maxAllowedVolatility', maxAllowedVolatility.toString());
    await _secureStorage.saveValue('maxRebuyCount', maxRebuyCount.toString());
  }
}



```

./lib/features/settings/models/settings_model.dart:
```
import 'package:equatable/equatable.dart';

class SettingsModel extends Equatable {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;
  final double maxVariableInvestmentPercentage;
  final bool isDemoMode;
  final bool isBacktestingEnabled;
  final String apiKey;
  final String secretKey;

  const SettingsModel({
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
    required this.maxVariableInvestmentPercentage,
    required this.isDemoMode,
    required this.isBacktestingEnabled,
    required this.apiKey,
    required this.secretKey,
  });

  factory SettingsModel.defaultSettings() {
    return const SettingsModel(
      maxLossPercentage: 2.0,
      maxConcurrentTrades: 3,
      maxPositionSizePercentage: 5.0,
      dailyExposureLimit: 1000.0,
      maxAllowedVolatility: 0.05,
      maxRebuyCount: 3,
      maxVariableInvestmentPercentage: 20.0,
      isDemoMode: true,
      isBacktestingEnabled: false,
      apiKey: '',
      secretKey: '',
    );
  }

  SettingsModel copyWith({
    double? maxLossPercentage,
    int? maxConcurrentTrades,
    double? maxPositionSizePercentage,
    double? dailyExposureLimit,
    double? maxAllowedVolatility,
    int? maxRebuyCount,
    double? maxVariableInvestmentPercentage,
    bool? isDemoMode,
    bool? isBacktestingEnabled,
    String? apiKey,
    String? secretKey,
  }) {
    return SettingsModel(
      maxLossPercentage: maxLossPercentage ?? this.maxLossPercentage,
      maxConcurrentTrades: maxConcurrentTrades ?? this.maxConcurrentTrades,
      maxPositionSizePercentage:
          maxPositionSizePercentage ?? this.maxPositionSizePercentage,
      dailyExposureLimit: dailyExposureLimit ?? this.dailyExposureLimit,
      maxAllowedVolatility: maxAllowedVolatility ?? this.maxAllowedVolatility,
      maxRebuyCount: maxRebuyCount ?? this.maxRebuyCount,
      maxVariableInvestmentPercentage: maxVariableInvestmentPercentage ??
          this.maxVariableInvestmentPercentage,
      isDemoMode: isDemoMode ?? this.isDemoMode,
      isBacktestingEnabled: isBacktestingEnabled ?? this.isBacktestingEnabled,
      apiKey: apiKey ?? this.apiKey,
      secretKey: secretKey ?? this.secretKey,
    );
  }

  factory SettingsModel.fromJson(Map<String, dynamic> json) {
    return SettingsModel(
      maxLossPercentage: json['maxLossPercentage'],
      maxConcurrentTrades: json['maxConcurrentTrades'],
      maxPositionSizePercentage: json['maxPositionSizePercentage'],
      dailyExposureLimit: json['dailyExposureLimit'],
      maxAllowedVolatility: json['maxAllowedVolatility'],
      maxRebuyCount: json['maxRebuyCount'],
      maxVariableInvestmentPercentage: json['maxVariableInvestmentPercentage'],
      isDemoMode: json['isDemoMode'],
      isBacktestingEnabled: json['isBacktestingEnabled'],
      apiKey: json['apiKey'],
      secretKey: json['secretKey'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'maxLossPercentage': maxLossPercentage,
      'maxConcurrentTrades': maxConcurrentTrades,
      'maxPositionSizePercentage': maxPositionSizePercentage,
      'dailyExposureLimit': dailyExposureLimit,
      'maxAllowedVolatility': maxAllowedVolatility,
      'maxRebuyCount': maxRebuyCount,
      'maxVariableInvestmentPercentage': maxVariableInvestmentPercentage,
      'isDemoMode': isDemoMode,
      'isBacktestingEnabled': isBacktestingEnabled,
      'apiKey': apiKey,
      'secretKey': secretKey,
    };
  }

  @override
  List<Object?> get props => [
        maxLossPercentage,
        maxConcurrentTrades,
        maxPositionSizePercentage,
        dailyExposureLimit,
        maxAllowedVolatility,
        maxRebuyCount,
        maxVariableInvestmentPercentage,
        isDemoMode,
        isBacktestingEnabled,
        apiKey,
        secretKey,
      ];
}

```

./lib/features/dashboard/ui/widgets/portfolio_overview.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class PortfolioOverview extends StatelessWidget {
  final double totalValue;
  final double dailyChange;
  final Map<String, double> assets;

  const PortfolioOverview({
    super.key,
    required this.totalValue,
    required this.dailyChange,
    required this.assets,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Portfolio Overview',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Total Value: \$${totalValue.toStringAsFixed(2)}',
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 8),
          Text(
            '24h Change: ${_formatChange(dailyChange)}',
            style: TextStyle(
              color: dailyChange >= 0 ? Colors.green : Colors.red,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          Text('Asset Distribution:', style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),
          ...assets.entries.map((entry) => _buildAssetRow(entry.key, entry.value)),
        ],
      ),
    );
  }

  Widget _buildAssetRow(String asset, double amount) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(asset),
          Text(amount.toStringAsFixed(8)),
        ],
      ),
    );
  }

  String _formatChange(double change) {
    final sign = change >= 0 ? '+' : '';
    return '$sign${change.toStringAsFixed(2)}%';
  }
}
```

./lib/features/dashboard/ui/widgets/recent_trades_widget.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';
import 'package:intl/intl.dart';

class RecentTradesWidget extends StatelessWidget {
  final List<CoreTrade> trades;
  final VoidCallback onViewAllTrades;

  const RecentTradesWidget({
    super.key,
    required this.trades,
    required this.onViewAllTrades,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Recent Trades',
      child: Column(
        children: [
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: trades.length > 5 ? 5 : trades.length,
            itemBuilder: (context, index) {
              final trade = trades[index];
              return ListTile(
                leading: Icon(
                  trade.type == CoreTradeType.buy ? Icons.arrow_downward : Icons.arrow_upward,
                  color: trade.type == CoreTradeType.buy ? Colors.green : Colors.red,
                ),
                title: Text('${trade.type.name.toUpperCase()} ${trade.amount} ${trade.symbol}'),
                subtitle: Text('Price: ${trade.price} | ${DateFormat.yMd().add_Hms().format(trade.timestamp)}'),
                trailing: Text(
                  '${trade.type == CoreTradeType.buy ? '-' : '+'}${(trade.amount * trade.price).toStringAsFixed(2)}',
                  style: TextStyle(
                    color: trade.type == CoreTradeType.buy ? Colors.red : Colors.green,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              );
            },
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onViewAllTrades,
            child: const Text('View All Trades'),
          ),
        ],
      ),
    );
  }
}
```

./lib/features/dashboard/ui/widgets/performance_chart.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class PerformanceChart extends StatelessWidget {
  final List<Map<String, dynamic>> data;

  const PerformanceChart({super.key, required this.data});

  @override
  Widget build(BuildContext context) {
    if (data.isEmpty) {
      return const CustomCard(
        title: 'Performance Chart',
        child: Center(child: Text('No data available')),
      );
    }

    final spots = data.map((entry) {
      final x = entry['date'] is DateTime
          ? entry['date'].millisecondsSinceEpoch.toDouble()
          : 0.0;
      final y =
          entry['value'] is num ? (entry['value'] as num).toDouble() : 0.0;
      return FlSpot(x, y);
    }).toList();

    final minY = spots.map((spot) => spot.y).reduce((a, b) => a < b ? a : b);
    final maxY = spots.map((spot) => spot.y).reduce((a, b) => a > b ? a : b);

    return CustomCard(
      title: 'Performance Chart',
      child: SizedBox(
        height: 200,
        child: LineChart(
          LineChartData(
            gridData: const FlGridData(show: false),
            titlesData: const FlTitlesData(show: false),
            borderData: FlBorderData(show: true),
            minX: spots.first.x,
            maxX: spots.last.x,
            minY: minY,
            maxY: maxY,
            lineBarsData: [
              LineChartBarData(
                spots: spots,
                isCurved: true,
                color: Theme.of(context).primaryColor,
                dotData: const FlDotData(show: false),
                belowBarData: BarAreaData(
                    show: true,
                    color: Theme.of(context).primaryColor.withOpacity(0.3)),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

./lib/features/dashboard/ui/pages/dashboard_page.dart:
```
import 'package:cost_averaging_trading_app/features/dashboard/ui/widgets/recent_trades_widget.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_candlestick_chart.dart';
import 'package:cost_averaging_trading_app/ui/layouts/custom_page_layout.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_bloc.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_state.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_event.dart';
import 'package:cost_averaging_trading_app/features/dashboard/ui/widgets/portfolio_overview.dart';
import 'package:cost_averaging_trading_app/features/dashboard/ui/widgets/performance_chart.dart';

class DashboardPage extends StatelessWidget {
  const DashboardPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<DashboardBloc, DashboardState>(
      builder: (context, state) {
        if (state is DashboardInitial) {
          context.read<DashboardBloc>().add(LoadDashboardData());
        }
        return CustomPageLayout(
          title: 'Dashboard',
          useSliver: true,
          children: _buildDashboardContent(context, state),
        );
      },
    );
  }

  List<Widget> _buildDashboardContent(
      BuildContext context, DashboardState state) {
    if (state is DashboardLoading) {
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is DashboardLoaded) {
      return [
        _buildPortfolioOverview(context, state),
        const SizedBox(height: 16),
        _buildMarketChart(context, state),
        const SizedBox(height: 16),
        _buildRecentTrades(context, state),
        const SizedBox(height: 16),
        _buildPerformanceSummary(context, state),
      ];
    } else if (state is DashboardError) {
      return [Center(child: Text('Error: ${state.message}'))];
    }
    return [const Center(child: Text('Unknown state'))];
  }

  Widget _buildPortfolioOverview(BuildContext context, DashboardLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: PortfolioOverview(
          totalValue: state.portfolio.totalValue,
          dailyChange: state.dailyChange,
          assets: state.portfolio.assets,
        ),
      ),
    );
  }

  Widget _buildMarketChart(BuildContext context, DashboardLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Market Chart', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 8),
            SizedBox(
              height: 300,
              child: CustomCandlestickChart(
                symbol: state.activeStrategy?.symbol ?? 'BTCUSDT',
                trades: state.recentTrades,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRecentTrades(BuildContext context, DashboardLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Recent Trades',
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 8),
            RecentTradesWidget(
              trades: state.recentTrades,
              onViewAllTrades: () {
                // Navigate to Trade History page
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPerformanceSummary(BuildContext context, DashboardLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Performance Summary',
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                _buildPerformanceItem(
                    context, 'Daily P/L', state.dailyProfitLoss),
                _buildPerformanceItem(
                    context, 'Weekly P/L', state.weeklyProfitLoss),
                _buildPerformanceItem(
                    context, 'Monthly P/L', state.monthlyProfitLoss),
              ],
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 100,
              child: PerformanceChart(data: state.performanceData),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPerformanceItem(
      BuildContext context, String label, double value) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.bodySmall),
        Text(
          '${value >= 0 ? '+' : ''}${value.toStringAsFixed(2)}',
          style: TextStyle(
            color: value >= 0 ? Colors.green : Colors.red,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }
}

```

./lib/features/dashboard/blocs/dashboard_event.dart:
```
abstract class DashboardEvent {}

class LoadDashboardData extends DashboardEvent {}

class ChangePage extends DashboardEvent {
  final int newPage;

  ChangePage(this.newPage);
}

class ChangeTradesPerPage extends DashboardEvent {
  final int tradesPerPage;

  ChangeTradesPerPage(this.tradesPerPage);
}

```

./lib/features/dashboard/blocs/dashboard_state.dart:
```
import 'package:equatable/equatable.dart';
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

abstract class DashboardState extends Equatable {
  const DashboardState();

  @override
  List<Object?> get props => [];
}

class DashboardInitial extends DashboardState {}

class DashboardLoading extends DashboardState {}

class DashboardLoaded extends DashboardState {
  final Portfolio portfolio;
  final List<CoreTrade> recentTrades;
  final List<Map<String, dynamic>> performanceData;
  final StrategyParameters? activeStrategy;
  final double dailyChange;
  final double dailyProfitLoss;
  final double weeklyProfitLoss;
  final double monthlyProfitLoss;

  const DashboardLoaded({
    required this.portfolio,
    required this.recentTrades,
    required this.performanceData,
    this.activeStrategy,
    required this.dailyChange,
    required this.dailyProfitLoss,
    required this.weeklyProfitLoss,
    required this.monthlyProfitLoss,
  });

  @override
  List<Object?> get props => [
        portfolio,
        recentTrades,
        performanceData,
        activeStrategy,
        dailyChange,
        dailyProfitLoss,
        weeklyProfitLoss,
        monthlyProfitLoss,
      ];
}

class DashboardError extends DashboardState {
  final String message;

  const DashboardError(this.message);

  @override
  List<Object> get props => [message];
}
```

./lib/features/dashboard/blocs/dashboard_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_event.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_state.dart';
import 'package:cost_averaging_trading_app/features/dashboard/repositories/dashboard_repository.dart';

class DashboardBloc extends Bloc<DashboardEvent, DashboardState> {
  final DashboardRepository _repository;

  DashboardBloc(this._repository) : super(DashboardInitial()) {
    on<LoadDashboardData>(_onLoadDashboardData);
  }

  Future<void> _onLoadDashboardData(
    LoadDashboardData event,
    Emitter<DashboardState> emit,
  ) async {
    emit(DashboardLoading());
    try {
      final portfolio = await _repository.getPortfolio();
      final recentTrades = await _repository.getRecentTrades();
      final performanceData = await _repository.getPerformanceData();
      final activeStrategy = await _repository.getActiveStrategy();
      final dailyChange = await _repository.getDailyChange();
      final dailyProfitLoss = await _repository.getDailyProfitLoss();
      final weeklyProfitLoss = await _repository.getWeeklyProfitLoss();
      final monthlyProfitLoss = await _repository.getMonthlyProfitLoss();

      emit(DashboardLoaded(
        portfolio: portfolio,
        recentTrades: recentTrades,
        performanceData: performanceData,
        activeStrategy: activeStrategy,
        dailyChange: dailyChange,
        dailyProfitLoss: dailyProfitLoss,
        weeklyProfitLoss: weeklyProfitLoss,
        monthlyProfitLoss: monthlyProfitLoss,
      ));
    } catch (e) {
      emit(DashboardError(e.toString()));
    }
  }
}
```

./lib/features/dashboard/repositories/dashboard_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class DashboardRepository {
  final ApiService apiService;
  final DatabaseService databaseService;

  DashboardRepository({
    required this.apiService,
    required this.databaseService,
  });

  Future<Portfolio> getPortfolio() async {
    try {
      final accountInfo = await apiService.getAccountInfo();
      final balances = accountInfo['balances'] as List;
      final assets = Map<String, double>.fromEntries(
        balances.where((b) => double.parse(b['free']) > 0).map(
              (b) => MapEntry(b['asset'], double.parse(b['free'])),
            ),
      );

      double totalValue = 0;
      for (var entry in assets.entries) {
        if (entry.key != 'USDT') {
          try {
            final price = await apiService.getCurrentPrice('${entry.key}USDT');
            if (price > 0) {
              totalValue += entry.value * price;
            }
          } catch (e) {
            throw Exception('No local portfolio data available');
          }
        } else {
          totalValue += entry.value;
        }
      }

      await databaseService.savePortfolioValue(DateTime.now(), totalValue);

      return Portfolio(
        id: accountInfo['accountType'],
        assets: assets,
        totalValue: totalValue,
      );
    } catch (e) {
      return _getLocalPortfolio();
    }
  }

  Future<Portfolio> _getLocalPortfolio() async {
    final localData = await databaseService.query('portfolio');
    if (localData.isNotEmpty) {
      return Portfolio.fromJson(localData.first);
    }
    return const Portfolio(
        id: 'local', assets: {}, totalValue: 0); // Return an empty portfolio
  }

  Future<List<CoreTrade>> getRecentTrades() async {
    try {
      final trades =
          await apiService.getMyTrades(symbol: 'BTCUSDT', limit: 100);
      return trades.map((trade) => CoreTrade.fromJson(trade)).toList();
    } catch (e) {
      return _getLocalTrades();
    }
  }

  Future<List<CoreTrade>> _getLocalTrades() async {
    final localData = await databaseService.query('trades');
    return localData.map((trade) => CoreTrade.fromJson(trade)).toList();
  }

  Future<List<Map<String, dynamic>>> getPerformanceData() async {
    try {
      final klines = await apiService.getKlines(
        symbol: 'BTCUSDT',
        interval: '1d',
        limit: 30,
      );
      return klines
          .map((kline) => {
                'date': DateTime.fromMillisecondsSinceEpoch(kline[0]),
                'value': double.parse(kline[4]), // Closing price
              })
          .toList();
    } catch (e) {
      // Fallback to example data if API call fails
      return [
        {
          'date': DateTime.now().subtract(const Duration(days: 30)),
          'value': 30000
        },
        {
          'date': DateTime.now().subtract(const Duration(days: 20)),
          'value': 32000
        },
        {
          'date': DateTime.now().subtract(const Duration(days: 10)),
          'value': 31000
        },
        {'date': DateTime.now(), 'value': 33000},
      ];
    }
  }

  Future<StrategyParameters?> getActiveStrategy() async {
    return await databaseService.getActiveStrategy();
  }

  Future<double> getDailyChange() async {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    final today = DateTime.now();
    final yesterdayValue =
        await databaseService.getPortfolioValueForDate(yesterday);
    final todayValue = await databaseService.getPortfolioValueForDate(today);
    return (todayValue - yesterdayValue) / yesterdayValue * 100;
  }

  Future<double> getDailyProfitLoss() async {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    final today = DateTime.now();
    final yesterdayValue =
        await databaseService.getPortfolioValueForDate(yesterday);
    final todayValue = await databaseService.getPortfolioValueForDate(today);
    return todayValue - yesterdayValue;
  }

  Future<double> getWeeklyProfitLoss() async {
    final lastWeek = DateTime.now().subtract(const Duration(days: 7));
    final today = DateTime.now();
    final lastWeekValue =
        await databaseService.getPortfolioValueForDate(lastWeek);
    final todayValue = await databaseService.getPortfolioValueForDate(today);
    return todayValue - lastWeekValue;
  }

  Future<double> getMonthlyProfitLoss() async {
    final lastMonth = DateTime.now().subtract(const Duration(days: 30));
    final today = DateTime.now();
    final lastMonthValue =
        await databaseService.getPortfolioValueForDate(lastMonth);
    final todayValue = await databaseService.getPortfolioValueForDate(today);
    return todayValue - lastMonthValue;
  }
}

```

./lib/features/dashboard/models/dashboard_model.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class DashboardModel {
  final String portfolioValue;
  final String activeTrades;
  final String totalProfit;
  final String totalLoss;
  final List<CoreTrade> recentTrades;
  final List<PortfolioItem> portfolioItems;
  final List<Notification> notifications;

  DashboardModel({
    required this.portfolioValue,
    required this.activeTrades,
    required this.totalProfit,
    required this.totalLoss,
    required this.recentTrades,
    required this.portfolioItems,
    required this.notifications,
  });

  factory DashboardModel.fromJson(Map<String, dynamic> json) {
    return DashboardModel(
      portfolioValue: json['portfolioValue'],
      activeTrades: json['activeTrades'],
      totalProfit: json['totalProfit'],
      totalLoss: json['totalLoss'],
      recentTrades: (json['recentTrades'] as List)
          .map((i) => CoreTrade.fromJson(i))
          .toList(),
      portfolioItems: (json['portfolioItems'] as List)
          .map((i) => PortfolioItem.fromJson(i))
          .toList(),
      notifications: (json['notifications'] as List)
          .map((i) => Notification.fromJson(i))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'portfolioValue': portfolioValue,
      'activeTrades': activeTrades,
      'totalProfit': totalProfit,
      'totalLoss': totalLoss,
      'recentTrades': recentTrades.map((e) => e.toJson()).toList(),
      'portfolioItems': portfolioItems.map((e) => e.toJson()).toList(),
      'notifications': notifications.map((e) => e.toJson()).toList(),
    };
  }
}

class PortfolioItem {
  final String asset;
  final double amount;
  final double value;

  PortfolioItem({
    required this.asset,
    required this.amount,
    required this.value,
  });

  factory PortfolioItem.fromJson(Map<String, dynamic> json) {
    return PortfolioItem(
      asset: json['asset'],
      amount: json['amount'],
      value: json['value'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'asset': asset,
      'amount': amount,
      'value': value,
    };
  }
}

class Notification {
  final String id;
  final String title;
  final String message;
  final DateTime timestamp;

  Notification({
    required this.id,
    required this.title,
    required this.message,
    required this.timestamp,
  });

  factory Notification.fromJson(Map<String, dynamic> json) {
    return Notification(
      id: json['id'],
      title: json['title'],
      message: json['message'],
      timestamp: DateTime.parse(json['timestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'message': message,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}
```

./lib/features/portfolio/ui/widgets/asset_list.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class AssetList extends StatelessWidget {
  final Map<String, double> assets;

  const AssetList({super.key, required this.assets});

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Assets',
      child: ListView.builder(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        itemCount: assets.length,
        itemBuilder: (context, index) {
          final asset = assets.entries.elementAt(index);
          return ListTile(
            leading: CircleAvatar(
              backgroundColor: Colors.blue,
              child: Text(asset.key[0]),
            ),
            title: Text(asset.key),
            trailing: Text(
              asset.value.toStringAsFixed(8),
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          );
        },
      ),
    );
  }
}
```

./lib/features/portfolio/ui/widgets/portfolio_summary.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class PortfolioSummary extends StatelessWidget {
  final double totalValue;
  final double dailyChange;
  final double weeklyChange;

  const PortfolioSummary({
    super.key,
    required this.totalValue,
    required this.dailyChange,
    required this.weeklyChange,
  });

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Portfolio Summary',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Total Value: \$${totalValue.toStringAsFixed(2)}',
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 8),
          _buildChangeRow('24h Change', dailyChange),
          _buildChangeRow('7d Change', weeklyChange),
        ],
      ),
    );
  }

  Widget _buildChangeRow(String label, double change) {
    final isPositive = change >= 0;
    final changeText = '${isPositive ? '+' : ''}${change.toStringAsFixed(2)}%';
    final changeColor = isPositive ? Colors.green : Colors.red;

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label),
        Text(
          changeText,
          style: TextStyle(
            color: changeColor,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }
}
```

./lib/features/portfolio/ui/widgets/portfolio_chart.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_card.dart';

class PortfolioChart extends StatelessWidget {
  final List<Map<String, dynamic>> chartData;

  const PortfolioChart({super.key, required this.chartData});

  @override
  Widget build(BuildContext context) {
    return CustomCard(
      title: 'Portfolio Performance',
      child: SizedBox(
        height: 300,
        child: LineChart(
          LineChartData(
            gridData: const FlGridData(show: false),
            titlesData: const FlTitlesData(show: false),
            borderData: FlBorderData(show: true),
            minX: 0,
            maxX: chartData.length.toDouble() - 1,
            minY: chartData.map((d) => d['value'] as double).reduce((a, b) => a < b ? a : b),
            maxY: chartData.map((d) => d['value'] as double).reduce((a, b) => a > b ? a : b),
            lineBarsData: [
              LineChartBarData(
                spots: chartData.asMap().entries.map((entry) {
                  return FlSpot(entry.key.toDouble(), entry.value['value'] as double);
                }).toList(),
                isCurved: true,
                color: Theme.of(context).primaryColor,
                dotData: const FlDotData(show: false),
                belowBarData: BarAreaData(show: true, color: Theme.of(context).primaryColor.withOpacity(0.3)),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

./lib/features/portfolio/ui/pages/portfolio_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_bloc.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_state.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_event.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/widgets/asset_list.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/widgets/portfolio_summary.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/widgets/portfolio_chart.dart';
import 'package:cost_averaging_trading_app/ui/layouts/custom_page_layout.dart';

class PortfolioPage extends StatelessWidget {
  const PortfolioPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<PortfolioBloc, PortfolioState>(
      builder: (context, state) {
        return CustomPageLayout(
          title: 'Portfolio',
          useSliver: true,
          children: _buildPortfolioContent(context, state),
        );
      },
    );
  }

  List<Widget> _buildPortfolioContent(
      BuildContext context, PortfolioState state) {
    if (state is PortfolioInitial) {
      context.read<PortfolioBloc>().add(LoadPortfolio());
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is PortfolioLoading) {
      return [const Center(child: CircularProgressIndicator())];
    } else if (state is PortfolioLoaded) {
      return [
        _buildPortfolioSummary(state),
        const SizedBox(height: 16),
        _buildPortfolioChart(state),
        const SizedBox(height: 16),
        _buildAssetList(state),
        const SizedBox(height: 16),
        _buildExportButton(context),
      ];
    } else if (state is PortfolioError) {
      return [Center(child: Text('Error: ${state.message}'))];
    }
    return [const Center(child: Text('Unknown state'))];
  }

  Widget _buildPortfolioSummary(PortfolioLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: PortfolioSummary(
          totalValue: state.portfolio.totalValue,
          dailyChange: state.dailyChange,
          weeklyChange: state.weeklyChange,
        ),
      ),
    );
  }

  Widget _buildPortfolioChart(PortfolioLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: PortfolioChart(chartData: state.performanceData),
      ),
    );
  }

  Widget _buildAssetList(PortfolioLoaded state) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: AssetList(assets: state.portfolio.assets),
      ),
    );
  }

  Widget _buildExportButton(BuildContext context) {
    return ElevatedButton(
      onPressed: () {
        // Implement export functionality
      },
      child: const Text('Export Report'),
    );
  }
}

```

./lib/features/portfolio/blocs/portfolio_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_event.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_state.dart';
import 'package:cost_averaging_trading_app/features/portfolio/repositories/portfolio_repository.dart';

class PortfolioBloc extends Bloc<PortfolioEvent, PortfolioState> {
  final PortfolioRepository _repository;

  PortfolioBloc(this._repository) : super(PortfolioInitial()) {
    on<LoadPortfolio>(_onLoadPortfolio);
  }

  Future<void> _onLoadPortfolio(
    LoadPortfolio event,
    Emitter<PortfolioState> emit,
  ) async {
    emit(PortfolioLoading());
    try {
      final portfolio = await _repository.getPortfolio();
      final performanceData = await _repository.getPerformanceData();
      final dailyChange = await _repository.getDailyChange();
      final weeklyChange = await _repository.getWeeklyChange();
      emit(PortfolioLoaded(
        portfolio: portfolio,
        performanceData: performanceData,
        dailyChange: dailyChange,
        weeklyChange: weeklyChange,
      ));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error loading portfolio data', e, stackTrace);
      emit(PortfolioError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }
}

```

./lib/features/portfolio/blocs/portfolio_state.dart:
```
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:equatable/equatable.dart';

abstract class PortfolioState extends Equatable {
  const PortfolioState();

  @override
  List<Object> get props => [];
}

class PortfolioInitial extends PortfolioState {}

class PortfolioLoading extends PortfolioState {}

class PortfolioLoaded extends PortfolioState {
  final Portfolio portfolio;
  final List<Map<String, dynamic>> performanceData;
  final double dailyChange;
  final double weeklyChange;

  const PortfolioLoaded({
    required this.portfolio,
    required this.performanceData,
    required this.dailyChange,
    required this.weeklyChange,
  });

  @override
  List<Object> get props =>
      [portfolio, performanceData, dailyChange, weeklyChange];
}

class PortfolioError extends PortfolioState {
  final String message;

  const PortfolioError(this.message);

  @override
  List<Object> get props => [message];
}

```

./lib/features/portfolio/blocs/portfolio_event.dart:
```
// lib/features/portfolio/blocs/portfolio_event.dart

import 'package:equatable/equatable.dart';

abstract class PortfolioEvent extends Equatable {
  const PortfolioEvent();

  @override
  List<Object> get props => [];
}

class LoadPortfolio extends PortfolioEvent {}

```

./lib/features/portfolio/repositories/portfolio_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';

class PortfolioRepository {
  final ApiService apiService;
  final DatabaseService databaseService;

  PortfolioRepository(
      {required this.apiService, required this.databaseService});

  Future<Portfolio> getPortfolio() async {
    // Implementa la logica per ottenere il portfolio
    // Usa apiService o databaseService a seconda delle necessità
    // Per ora, restituiamo dati di esempio
    return const Portfolio(
      id: '1',
      assets: {'BTC': 0.5, 'ETH': 2.0, 'USDT': 1000.0},
      totalValue: 10000.0,
    );
  }

  Future<List<Map<String, dynamic>>> getPerformanceData() async {
    // Implementa la logica per ottenere i dati di performance
    // Usa apiService o databaseService a seconda delle necessità
    // Per ora, restituiamo dati di esempio
    return [
      {
        'date': DateTime.now().subtract(const Duration(days: 30)),
        'value': 9000.0
      },
      {
        'date': DateTime.now().subtract(const Duration(days: 20)),
        'value': 9500.0
      },
      {
        'date': DateTime.now().subtract(const Duration(days: 10)),
        'value': 9800.0
      },
      {'date': DateTime.now(), 'value': 10000.0},
    ];
  }

  Future<double> getDailyChange() async {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    final today = DateTime.now();
    final yesterdayValue =
        await databaseService.getPortfolioValueForDate(yesterday);
    final todayValue = await databaseService.getPortfolioValueForDate(today);
    return (todayValue - yesterdayValue) / yesterdayValue * 100;
  }

  Future<double> getWeeklyChange() async {
    final lastWeek = DateTime.now().subtract(const Duration(days: 7));
    final today = DateTime.now();
    final lastWeekValue =
        await databaseService.getPortfolioValueForDate(lastWeek);
    final todayValue = await databaseService.getPortfolioValueForDate(today);
    return (todayValue - lastWeekValue) / lastWeekValue * 100;
  }

  Future<List<CoreTrade>> getRecentTrades() async {
    try {
      final trades =
          await apiService.getMyTrades(symbol: 'BTCUSDT', limit: 100);
      return trades.map((trade) => CoreTrade.fromJson(trade)).toList();
    } catch (e) {
      return _getLocalTrades();
    }
  }

  Future<List<CoreTrade>> _getLocalTrades() async {
    final localData = await databaseService.query('trades');
    return localData.map((trade) => CoreTrade.fromJson(trade)).toList();
  }
}

```

./lib/features/portfolio/models/portfolio_model.dart:
```
class PortfolioModel {
  final Map<String, double> assets;
  final List<Transaction> transactions;

  PortfolioModel({
    required this.assets,
    required this.transactions,
  });
}

class Transaction {
  final String id;
  final String assetSymbol;
  final double amount;
  final double price;
  final DateTime timestamp;

  Transaction({
    required this.id,
    required this.assetSymbol,
    required this.amount,
    required this.price,
    required this.timestamp,
  });
}
```

./lib/core/widgets/custom_button.dart:
```
import 'package:flutter/material.dart';

class CustomButton extends StatelessWidget {
  final String label;
  final VoidCallback? onPressed;
  final IconData? icon;
  final Color? color;

  const CustomButton({
    super.key,
    required this.label,
    this.onPressed,
    this.icon,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: color ?? Theme.of(context).primaryColor,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(icon),
              const SizedBox(width: 8),
            ],
            Text(label),
          ],
        ),
      ),
    );
  }
}

```

./lib/core/widgets/custom_card.dart:
```
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
  final String title;
  final Widget child;
  final EdgeInsetsGeometry padding;

  const CustomCard({
    super.key,
    required this.title,
    required this.child,
    this.padding = const EdgeInsets.all(16.0),
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: Padding(
        padding: padding,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min, // Aggiungi questa riga
          children: [
            Text(
              title,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            Flexible(child: child), // Avvolgi il child in un Flexible
          ],
        ),
      ),
    );
  }
}

```

./lib/core/widgets/custom_text_field.dart:
```
import 'package:flutter/material.dart';

class CustomTextField extends StatelessWidget {
  final String label;
  final TextEditingController? controller;
  final ValueChanged<String>? onChanged;
  final TextInputType? keyboardType;
  final bool obscureText;
  final IconData? icon;
  final bool readOnly;
  final VoidCallback? onTap;
  final String? value;

  const CustomTextField({
    super.key,
    required this.label,
    this.controller,
    this.onChanged,
    this.keyboardType,
    this.obscureText = false,
    this.icon,
    this.readOnly = false,
    this.onTap,
    this.value,
  });

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: controller,
      onChanged: onChanged,
      keyboardType: keyboardType,
      obscureText: obscureText,
      readOnly: readOnly,
      onTap: onTap,
      decoration: InputDecoration(
        labelText: label,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        prefixIcon: icon != null ? Icon(icon) : null,
      ),
    );
  }
}

```

./lib/core/widgets/shared_widgets.dart:
```
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;
  final double elevation;

  const CustomCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(16.0),
    this.elevation = 2.0,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: elevation,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: padding,
        child: child,
      ),
    );
  }
}

class ErrorMessage extends StatelessWidget {
  final String message;

  const ErrorMessage({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error_outline, color: Colors.red, size: 48),
            const SizedBox(height: 16),
            Text(
              'An error occurred',
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              message,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class LoadingIndicator extends StatelessWidget {
  final String message;

  const LoadingIndicator({super.key, this.message = 'Loading...'});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            message,
            style: Theme.of(context).textTheme.bodyLarge,
          ),
        ],
      ),
    );
  }
}

```

./lib/core/widgets/custom_candlestick_chart.dart:
```
import 'package:candlesticks/candlesticks.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_bloc.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_event.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_state.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';

class CustomCandlestickChart extends StatefulWidget {
  final String symbol;
  final List<CoreTrade> trades;

  const CustomCandlestickChart({
    super.key,
    required this.symbol,
    required this.trades,
  });

  @override
  CustomCandlestickChartState createState() => CustomCandlestickChartState();
}

class CustomCandlestickChartState extends State<CustomCandlestickChart> {
  late ChartBloc _chartBloc;

  @override
  void initState() {
    super.initState();
    _chartBloc = ChartBloc(
      symbol: widget.symbol,
      apiService: context.read<ApiService>(),
    );
    _chartBloc.add(LoadChartData());
  }

  @override
  void dispose() {
    _chartBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<ChartBloc, ChartState>(
      bloc: _chartBloc,
      listener: (context, state) {
        if (state is ChartError) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.message)),
          );
        }
      },
      builder: (context, state) {
        if (state is ChartLoading) {
          return const Center(child: CircularProgressIndicator());
        } else if (state is ChartLoaded && state.candles.isNotEmpty) {
          return _buildChart(context, state);
        } else if (state is ChartError) {
          return Center(child: Text('Error: ${state.message}'));
        }
        return const Center(child: Text('No data available'));
      },
    );
  }

  Widget _buildChart(BuildContext context, ChartLoaded state) {
    final validCandles =
        state.candles.where((candle) => candle.low != null).toList();

    if (validCandles.isEmpty) {
      return const Center(child: Text('No valid candle data available'));
    }

    return AspectRatio(
      aspectRatio: 1.5,
      child: BarChart(
        BarChartData(
          alignment: BarChartAlignment.spaceAround,
          barGroups: _createBarGroups(validCandles),
          titlesData: FlTitlesData(
            show: true,
            bottomTitles: _bottomTitles(),
            leftTitles: _leftTitles(),
            topTitles:
                const AxisTitles(sideTitles: SideTitles(showTitles: false)),
            rightTitles:
                const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          ),
          gridData: FlGridData(
            show: true,
            drawVerticalLine: true,
            getDrawingHorizontalLine: (value) {
              return FlLine(
                color: Colors.grey[300],
                strokeWidth: 1,
              );
            },
            getDrawingVerticalLine: (value) {
              return FlLine(
                color: Colors.grey[300],
                strokeWidth: 1,
              );
            },
          ),
          borderData: FlBorderData(
            show: true,
            border: Border.all(color: Colors.grey[300]!, width: 1),
          ),
        ),
      ),
    );
  }

  List<BarChartGroupData> _createBarGroups(List<Candle> candles) {
    return candles.asMap().entries.map((entry) {
      final index = entry.key;
      final candle = entry.value;
      final open = candle.open;
      final close = candle.close;
      final high = candle.high;
      final low = candle.low;

      return BarChartGroupData(
        x: index,
        barRods: [
          BarChartRodData(
            toY: high,
            fromY: low,
            color: open > close ? Colors.red : Colors.green,
            width: 8,
          ),
        ],
      );
    }).toList();
  }

  AxisTitles _bottomTitles() {
    return AxisTitles(
      sideTitles: SideTitles(
        showTitles: true,
        getTitlesWidget: (value, meta) {
          final index = value.toInt();
          if (index % 5 == 0) {
            return Text(
              '${index + 1}',
              style: const TextStyle(color: Colors.black, fontSize: 10),
            );
          }
          return const SizedBox.shrink();
        },
      ),
    );
  }

  AxisTitles _leftTitles() {
    return AxisTitles(
      sideTitles: SideTitles(
        showTitles: true,
        getTitlesWidget: (value, meta) {
          return Text(
            value.toStringAsFixed(2),
            style: const TextStyle(color: Colors.black, fontSize: 10),
          );
        },
      ),
    );
  }
}

```

./lib/core/dtos/portfolio_dto.dart:
```
import 'dart:convert';

class PortfolioDTO {
  final String id;
  final Map<String, double> assets;
  final double totalValue;

  PortfolioDTO({
    required this.id,
    required this.assets,
    required this.totalValue,
  });

  factory PortfolioDTO.fromJson(Map<String, dynamic> json) {
    return PortfolioDTO(
      id: json['id'],
      assets: Map<String, double>.from(json['assets']),
      totalValue: json['totalValue'].toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'assets': assets,
      'totalValue': totalValue,
    };
  }

  factory PortfolioDTO.fromDatabase(Map<String, dynamic> data) {
    return PortfolioDTO(
      id: data['id'],
      assets: Map<String, double>.from(json.decode(data['assets'])),
      totalValue: data['totalValue'],
    );
  }

  Map<String, dynamic> toDatabase() {
    return {
      'id': id,
      'assets': json.encode(assets),
      'totalValue': totalValue,
    };
  }
}

```

./lib/core/dtos/trade_dto.dart:
```
class TradeDTO {
  final String id;
  final String symbol;
  final double amount;
  final double price;
  final DateTime timestamp;
  final String type;

  TradeDTO({
    required this.id,
    required this.symbol,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  factory TradeDTO.fromJson(Map<String, dynamic> json) {
    return TradeDTO(
      id: json['id'],
      symbol: json['symbol'],
      amount: json['amount'],
      price: json['price'],
      timestamp: DateTime.parse(json['timestamp']),
      type: json['type'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'symbol': symbol,
      'amount': amount,
      'price': price,
      'timestamp': timestamp.toIso8601String(),
      'type': type,
    };
  }
}

```

./lib/core/theme/app_theme.dart:
```
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      primarySwatch: Colors.blue,
      scaffoldBackgroundColor: Colors.white,
      appBarTheme: const AppBarTheme(
        color: Colors.blue,
        elevation: 0,
        iconTheme: IconThemeData(color: Colors.white),
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      textTheme: const TextTheme(
        titleLarge: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
      ),
      buttonTheme: ButtonThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        buttonColor: Colors.blue,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      brightness: Brightness.dark,
      primarySwatch: Colors.blue,
      scaffoldBackgroundColor: Colors.grey[900],
      appBarTheme: AppBarTheme(
        color: Colors.grey[800],
        elevation: 0,
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      cardTheme: CardTheme(
        color: Colors.grey[800],
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      textTheme: const TextTheme(
        titleLarge: TextStyle(
            fontSize: 18, fontWeight: FontWeight.bold, color: Colors.white),
        bodyLarge: TextStyle(fontSize: 16, color: Colors.white70),
        bodyMedium: TextStyle(fontSize: 14, color: Colors.white70),
      ),
      buttonTheme: ButtonThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        buttonColor: Colors.blue,
      ),
    );
  }
}

```

./lib/core/domain/enums/trading_enums.dart:
```
enum TradeType { buy, sell }

enum OrderType { market, limit, stopLoss, takeProfit }

enum TradingMode { demo, live }

enum TimeFrame { m1, m5, m15, m30, h1, h4, d1, w1, mn1 }

```

./lib/core/domain/entities/trade_entity.dart:
```
import 'package:equatable/equatable.dart';

enum TradeType { buy, sell }

class TradeEntity extends Equatable {
  final String id;
  final String symbol;
  final double amount;
  final double price;
  final DateTime timestamp;
  final TradeType type;

  const TradeEntity({
    required this.id,
    required this.symbol,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  @override
  List<Object?> get props => [id, symbol, amount, price, timestamp, type];
}
```

./lib/core/domain/entities/portfolio_entity.dart:
```
import 'package:equatable/equatable.dart';

class PortfolioEntity extends Equatable {
  final String id;
  final Map<String, double> assets;
  final double totalValue;

  const PortfolioEntity({
    required this.id,
    required this.assets,
    required this.totalValue,
  });

  @override
  List<Object?> get props => [id, assets, totalValue];
}
```

./lib/core/providers/app_providers.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/core/services/risk_management_service.dart';
import 'package:cost_averaging_trading_app/core/services/secure_storage_service.dart';
import 'package:cost_averaging_trading_app/core/services/trading_service.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_bloc.dart';
import 'package:cost_averaging_trading_app/features/dashboard/repositories/dashboard_repository.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_bloc.dart';
import 'package:cost_averaging_trading_app/features/portfolio/repositories/portfolio_repository.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/repositories/settings_repository.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_bloc.dart';
import 'package:cost_averaging_trading_app/features/trade_history/repositories/trade_history_repository.dart';

class AppProviders extends StatelessWidget {
  final Widget child;

  const AppProviders({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return MultiRepositoryProvider(
      providers: [
        RepositoryProvider<ApiService>(
          create: (context) => ApiService(
            apiKey: dotenv.env['API_KEY'] ?? '',
            secretKey: dotenv.env['SECRET_KEY'] ?? '',
          ),
        ),
        RepositoryProvider<DatabaseService>(
          create: (context) {
            final databaseService = DatabaseService();
            _initializeDatabase(databaseService);
            return databaseService;
          },
        ),
        RepositoryProvider<SecureStorageService>(
          create: (context) => SecureStorageService(),
        ),
        RepositoryProvider<SettingsRepository>(
          create: (context) =>
              SettingsRepository(context.read<SecureStorageService>()),
        ),
        RepositoryProvider<RiskManagementService>(
          create: (context) => RiskManagementService(
            context.read<SettingsRepository>(),
            context.read<ApiService>(),
            context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<StrategyRepository>(
          create: (context) => StrategyRepository(
            databaseService: context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<TradingService>(
          create: (context) => TradingService(
            context.read<ApiService>(),
            context.read<DatabaseService>(),
            context.read<StrategyRepository>(),
          ),
        ),
        RepositoryProvider<DashboardRepository>(
          create: (context) => DashboardRepository(
            apiService: context.read<ApiService>(),
            databaseService: context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<PortfolioRepository>(
          create: (context) => PortfolioRepository(
            apiService: context.read<ApiService>(),
            databaseService: context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<TradeHistoryRepository>(
          create: (context) => TradeHistoryRepository(),
        ),
        RepositoryProvider<BacktestingService>(
          create: (context) => BacktestingService(context.read<ApiService>()),
        ),
      ],
      child: MultiBlocProvider(
        providers: [
          BlocProvider<DashboardBloc>(
            create: (context) => DashboardBloc(
              context.read<DashboardRepository>(),
              //context.read<StrategyRepository>(),
            ),
          ),
          BlocProvider<PortfolioBloc>(
            create: (context) =>
                PortfolioBloc(context.read<PortfolioRepository>()),
          ),
          BlocProvider<StrategyBloc>(
            create: (context) => StrategyBloc(
              context.read<StrategyRepository>(),
              context.read<RiskManagementService>(),
              context.read<BacktestingService>(),
              context.read<TradingService>(),
            ),
          ),
          BlocProvider<TradeHistoryBloc>(
            create: (context) =>
                TradeHistoryBloc(context.read<TradeHistoryRepository>()),
          ),
          BlocProvider<SettingsBloc>(
            create: (context) =>
                SettingsBloc(context.read<SettingsRepository>()),
          ),
        ],
        child: child,
      ),
    );
  }

  void _initializeDatabase(DatabaseService databaseService) {
    databaseService.initDatabase().then((_) async {
      bool isHealthy = await databaseService.isDatabaseHealthy();
      if (isHealthy) {
        await databaseService.performMaintenance();
        await databaseService.checkAndCleanupOldData();
        await databaseService.optimizeDatabasePerformance();
      } else {
        await databaseService.backupDatabase();
      }
    }).catchError((error) {});
  }
}

```

./lib/core/mappers/trade_mapper.dart:
```
import 'package:cost_averaging_trading_app/core/dtos/trade_dto.dart';
import 'package:cost_averaging_trading_app/core/domain/entities/trade_entity.dart';

class TradeMapper {
  static TradeEntity fromDTO(TradeDTO dto) {
    return TradeEntity(
      id: dto.id,
      symbol: dto.symbol,
      amount: dto.amount,
      price: dto.price,
      timestamp: dto.timestamp,
      type: TradeType.values
          .firstWhere((e) => e.toString().split('.').last == dto.type),
    );
  }

  static TradeDTO toDTO(TradeEntity entity) {
    return TradeDTO(
      id: entity.id,
      symbol: entity.symbol,
      amount: entity.amount,
      price: entity.price,
      timestamp: entity.timestamp,
      type: entity.type.toString().split('.').last,
    );
  }
}

```

./lib/core/mappers/portfolio_mapper.dart:
```
import 'package:cost_averaging_trading_app/core/dtos/portfolio_dto.dart';
import 'package:cost_averaging_trading_app/core/domain/entities/portfolio_entity.dart';

class PortfolioMapper {
  static PortfolioEntity fromDTO(PortfolioDTO dto) {
    return PortfolioEntity(
      id: dto.id,
      assets: dto.assets,
      totalValue: dto.totalValue,
    );
  }

  static PortfolioDTO toDTO(PortfolioEntity entity) {
    return PortfolioDTO(
      id: entity.id,
      assets: entity.assets,
      totalValue: entity.totalValue,
    );
  }
}

```

./lib/core/animations/custom_animations.dart:
```
import 'package:flutter/material.dart';

class FadeInAnimation extends StatefulWidget {
  final Widget child;
  final Duration duration;

  const FadeInAnimation({
    super.key,
    required this.child,
    this.duration = const Duration(milliseconds: 500),
  });

  @override
  FadeInAnimationState createState() => FadeInAnimationState();
}

class FadeInAnimationState extends State<FadeInAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: widget.duration);
    _animation = Tween<double>(begin: 0.0, end: 1.0).animate(_controller);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: widget.child,
    );
  }
}

class SlideInAnimation extends StatefulWidget {
  final Widget child;
  final Duration duration;
  final Offset beginOffset;

  const SlideInAnimation({
    super.key,
    required this.child,
    this.duration = const Duration(milliseconds: 500),
    this.beginOffset = const Offset(0.0, 0.35),
  });

  @override
  SlideInAnimationState createState() => SlideInAnimationState();
}

class SlideInAnimationState extends State<SlideInAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Offset> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: widget.duration);
    _animation =
        Tween<Offset>(begin: widget.beginOffset, end: Offset.zero).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeOut),
    );
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SlideTransition(
      position: _animation,
      child: widget.child,
    );
  }
}

```

./lib/core/services/risk_management_service.dart:
```
import 'dart:math';
import 'package:cost_averaging_trading_app/core/models/risk_management_settings.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/settings/repositories/settings_repository.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class RiskManagementService {
  final SettingsRepository settingsRepository;
  final ApiService apiService;
  final DatabaseService databaseService;

  RiskManagementService(
      this.settingsRepository, this.apiService, this.databaseService);

  Future<bool> isCoreTradeAllowed(
      CoreTrade proposedCoreTrade, double currentPortfolioValue) async {
    try {
      final strategyParameters = await _getStrategyParameters();

      if (!await _isWithinVolatilityLimits(proposedCoreTrade)) {
        return false;
      }

      if (!await _isWithinMaxRebuyLimit(proposedCoreTrade)) {
        return false;
      }

      if (!await _isAboveStopLoss(proposedCoreTrade, currentPortfolioValue)) {
        return false;
      }

      if (!await _isWithinMaxPositionSize(
          proposedCoreTrade, currentPortfolioValue, strategyParameters)) {
        return false;
      }

      if (!await _isWithinDailyExposureLimit(proposedCoreTrade)) {
        return false;
      }

      if (!_isWithinCoolingOffPeriod(proposedCoreTrade)) {
        return false;
      }

      return true;
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in isCoreTradeAllowed', e, stackTrace);
      return false;
    }
  }

  Future<bool> isStrategySafe(StrategyParameters parameters) async {
    try {
      final settings = await settingsRepository.getSettings();

      // Check if the investment amount is within limits
      if (parameters.investmentAmount >
          settings.maxPositionSizePercentage *
              await _getCurrentPortfolioValue()) {
        return false;
      }

      // Check if the symbol's volatility is within acceptable limits
      double volatility = await _calculateVolatility(parameters.symbol);
      if (volatility > settings.maxAllowedVolatility) {
        return false;
      }

      // Check if the variable investment amount is within acceptable limits
      if (parameters.isVariableInvestmentAmount &&
          parameters.variableInvestmentPercentage >
              settings.maxVariableInvestmentPercentage) {
        return false;
      }

      return true;
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in isStrategySafe', e, stackTrace);
      return false;
    }
  }

  Future<bool> _isWithinVolatilityLimits(CoreTrade trade) async {
    try {
      double volatility = await _calculateVolatility(trade.symbol);
      final settings = await settingsRepository.getSettings();

      return volatility <= settings.maxAllowedVolatility;
    } catch (e, stackTrace) {
      ErrorHandler.logError(
          'Error in _isWithinVolatilityLimits', e, stackTrace);
      return false;
    }
  }

  Future<bool> _isWithinMaxRebuyLimit(CoreTrade trade) async {
    try {
      int rebuyCount = await _getRebuyCount(trade.symbol);
      final settings = await settingsRepository.getSettings();

      return rebuyCount < settings.maxRebuyCount;
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in _isWithinMaxRebuyLimit', e, stackTrace);
      return false;
    }
  }

  Future<bool> _isAboveStopLoss(
      CoreTrade trade, double currentPortfolioValue) async {
    final settings = await settingsRepository.getSettings();
    double potentialLoss =
        (currentPortfolioValue - (trade.amount * trade.price)) /
            currentPortfolioValue;
    return potentialLoss <= settings.maxLossPercentage;
  }

  Future<bool> _isWithinMaxPositionSize(
      CoreTrade trade,
      double currentPortfolioValue,
      StrategyParameters strategyParameters) async {
    final settings = await settingsRepository.getSettings();
    double tradeValue = trade.amount * trade.price;

    double maxPositionSize =
        currentPortfolioValue * settings.maxPositionSizePercentage;

    if (strategyParameters.isVariableInvestmentAmount) {
      double variationFactor =
          1 + (strategyParameters.variableInvestmentPercentage / 100);
      maxPositionSize *= variationFactor;
    }

    return tradeValue <= maxPositionSize;
  }

  Future<bool> _isWithinDailyExposureLimit(CoreTrade trade) async {
    try {
      double dailyExposure = await _calculateDailyExposure(trade.symbol);
      final settings = await settingsRepository.getSettings();
      return dailyExposure + (trade.amount * trade.price) <=
          settings.dailyExposureLimit;
    } catch (e, stackTrace) {
      ErrorHandler.logError(
          'Error in _isWithinDailyExposureLimit', e, stackTrace);
      return false;
    }
  }

  bool _isWithinCoolingOffPeriod(CoreTrade trade) {
    // Implement cooling off logic here
    // For example, check if there's been a recent loss and if enough time has passed
    return true; // Placeholder
  }

  Future<double> _calculateVolatility(String symbol) async {
    try {
      var klineData = await apiService.getKlines(
        symbol: symbol,
        interval: '1d',
        limit: 30,
      );

      List<double> closePrices =
          klineData.map<double>((k) => double.parse(k[4])).toList();

      List<double> logReturns = [];
      for (int i = 1; i < closePrices.length; i++) {
        logReturns.add(log(closePrices[i] / closePrices[i - 1]));
      }

      double mean = logReturns.reduce((a, b) => a + b) / logReturns.length;
      double variance =
          logReturns.map((x) => pow(x - mean, 2)).reduce((a, b) => a + b) /
              logReturns.length;
      double stdDev = sqrt(variance);

      return stdDev * sqrt(365);
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in _calculateVolatility', e, stackTrace);
      return double.infinity;
    }
  }

  Future<int> _getRebuyCount(String symbol) async {
    try {
      var sevenDaysAgo = DateTime.now().subtract(const Duration(days: 7));
      var recentTrades = await databaseService.query(
        'trades',
        where: 'symbol = ? AND timestamp > ? AND type = ?',
        whereArgs: [symbol, sevenDaysAgo.millisecondsSinceEpoch, 'buy'],
      );
      return recentTrades.length;
    } catch (e, stackTrace) {
      final settings = await settingsRepository.getSettings();

      ErrorHandler.logError('Error in _getRebuyCount', e, stackTrace);
      return settings.maxRebuyCount;
    }
  }

  Future<double> _calculateDailyExposure(String symbol) async {
  try {
    var startOfDay = DateTime.now().subtract(Duration(
        hours: DateTime.now().hour,
        minutes: DateTime.now().minute,
        seconds: DateTime.now().second,
        milliseconds: DateTime.now().millisecond,
        microseconds: DateTime.now().microsecond));
    var todayTrades = await databaseService.query(
      'trades',
      where: 'symbol = ? AND timestamp > ?',
      whereArgs: [symbol, startOfDay.millisecondsSinceEpoch],
    );

    double totalExposure = 0.0;
    for (var trade in todayTrades) {
      double amount = (trade['amount'] as num).toDouble();
      double price = (trade['price'] as num).toDouble();
      totalExposure += amount * price;
    }

    return totalExposure;
  } catch (e, stackTrace) {
    final settings = await settingsRepository.getSettings();
    ErrorHandler.logError('Error in _calculateDailyExposure', e, stackTrace);
    return settings.dailyExposureLimit;
  }
}

  Future<double> _getCurrentPortfolioValue() async {
    try {
      // Prova prima a ottenere il valore del portfolio dall'API
      final accountInfo = await apiService.getAccountInfo();
      double totalValue = 0.0;

      for (var balance in accountInfo['balances']) {
        String asset = balance['asset'];
        double free = double.parse(balance['free']);
        double locked = double.parse(balance['locked']);
        double totalAssetAmount = free + locked;

        if (totalAssetAmount > 0) {
          if (asset != 'USDT') {
            // Se l'asset non è USDT, ottieni il prezzo corrente e calcola il valore
            String symbol = '${asset}USDT';
            double price = await apiService.getCurrentPrice(symbol);
            totalValue += totalAssetAmount * price;
          } else {
            // Se l'asset è USDT, aggiungi direttamente il valore
            totalValue += totalAssetAmount;
          }
        }
      }

      // Salva il valore del portfolio nel database locale per uso futuro
      await databaseService.insert('portfolio_value', {
        'value': totalValue,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });

      return totalValue;
    } catch (e) {
      // Se c'è un errore nell'ottenere i dati dall'API, prova a recuperare l'ultimo valore salvato dal database
      try {
        final lastValue = await databaseService.query(
          'portfolio_value',
          orderBy: 'timestamp DESC',
          limit: 1,
        );

        if (lastValue.isNotEmpty) {
          return lastValue.first['value'];
        }
      } catch (dbError, stacktrace) {
        ErrorHandler.logError(
            'Error retrieving portfolio value from database: ',
            dbError,
            stacktrace);
      }

      // Se non è possibile recuperare il valore né dall'API né dal database, lancia un'eccezione
      throw Exception('Unable to get current portfolio value');
    }
  }

  Future<StrategyParameters> _getStrategyParameters() async {
    try {
      return await databaseService.getStrategyParameters() ??
          StrategyParameters(
            symbol: 'BTCUSDT',
            investmentAmount: 100,
            intervalDays: 7,
            targetProfitPercentage: 5,
            stopLossPercentage: 3,
            purchaseFrequency: 1,
            maxInvestmentSize: 1000,
            useAutoMinTradeAmount: true,
            manualMinTradeAmount: 10,
            isVariableInvestmentAmount: false,
            variableInvestmentPercentage: 10,
            reinvestProfits: false,
          );
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error getting strategy parameters', e, stackTrace);
      throw Exception('Failed to get strategy parameters');
    }
  }

  Future<double> calculateRisk(StrategyParameters parameters) async {
    // Implement a risk calculation based on the strategy parameters
    // This is a simplified example and should be expanded based on your specific risk model
    double risk = 0;

    // Consider volatility
    double volatility = await _calculateVolatility(parameters.symbol);
    risk += volatility * 10; // Adjust the multiplier as needed

    // Consider investment amount
    double portfolioValue = await _getCurrentPortfolioValue();
    double investmentPercentage = parameters.investmentAmount / portfolioValue;
    risk += investmentPercentage * 100; // Adjust the multiplier as needed

    // Consider stop loss
    risk -= parameters.stopLossPercentage; // Lower stop loss increases risk

    // Consider variable investment
    if (parameters.isVariableInvestmentAmount) {
      risk += parameters.variableInvestmentPercentage / 2;
    }

    // Normalize risk to a 0-100 scale
    risk = risk.clamp(0, 100);

    return risk;
  }

  Future<RiskManagementSettings> getRiskManagementSettings() async {
    final settings = await settingsRepository.getSettings();
    return RiskManagementSettings(
      maxLossPercentage: settings.maxLossPercentage,
      maxConcurrentTrades: settings.maxConcurrentTrades,
      maxPositionSizePercentage: settings.maxPositionSizePercentage,
      dailyExposureLimit: settings.dailyExposureLimit,
      maxAllowedVolatility: settings.maxAllowedVolatility,
      maxRebuyCount: settings.maxRebuyCount,
    );
  }
}

```

./lib/core/services/backtesting_service.dart:
```
import 'dart:math';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class BacktestingService {
  final ApiService apiService;

  BacktestingService(this.apiService);

  Future<BacktestResult> runBacktest(
    String symbol,
    DateTime startDate,
    DateTime endDate,
    StrategyParameters parameters,
    void Function(double progress,
            List<Map<String, dynamic>> currentInvestmentOverTime)
        onProgress,
  ) async {
    try {
      List<HistoricalDataPoint> historicalData =
          await _fetchHistoricalData(symbol, startDate, endDate);

      List<CoreTrade> trades = [];
      double portfolioValue = parameters.investmentAmount;
      double btcAmount = 0;
      double averageEntryPrice = 0;
      int daysSinceLastPurchase = 0;

      double highestPortfolioValue = portfolioValue;
      double lowestPortfolioValue = portfolioValue;
      List<double> dailyReturns = [];
      double previousPortfolioValue = portfolioValue;
      List<Map<String, dynamic>> investmentOverTime = [];

      for (int i = 0; i < historicalData.length; i++) {
        HistoricalDataPoint currentData = historicalData[i];
        daysSinceLastPurchase++;

        double currentPortfolioValue =
            portfolioValue + (btcAmount * currentData.close);

        if (i > 0) {
          double dailyReturn =
              (currentPortfolioValue - previousPortfolioValue) /
                  previousPortfolioValue;
          dailyReturns.add(dailyReturn);
        }
        previousPortfolioValue = currentPortfolioValue;

        highestPortfolioValue =
            max(highestPortfolioValue, currentPortfolioValue);
        lowestPortfolioValue = min(lowestPortfolioValue, currentPortfolioValue);

        investmentOverTime.add({
          'date': currentData.timestamp,
          'value': currentPortfolioValue,
        });

        if (btcAmount > 0 &&
            currentData.close <=
                averageEntryPrice * (1 - parameters.stopLossPercentage / 100)) {
          trades.add(CoreTrade(
            id: (i + 2000000).toString(),
            symbol: symbol,
            amount: btcAmount,
            price: currentData.close,
            timestamp: currentData.timestamp,
            type: CoreTradeType.sell,
          ));

          portfolioValue += btcAmount * currentData.close;
          btcAmount = 0;
          averageEntryPrice = 0;
        }

        if (daysSinceLastPurchase >= parameters.purchaseFrequency) {
          double investmentAmount = parameters.investmentAmount;
          if (parameters.isVariableInvestmentAmount) {
            double variationPercentage =
                (parameters.variableInvestmentPercentage / 100);
            double randomFactor =
                1 + (Random().nextDouble() * 2 - 1) * variationPercentage;
            investmentAmount *= randomFactor;
          }

          double buyAmount = investmentAmount / currentData.close;
          if (parameters.useAutoMinTradeAmount) {
            double minTradeAmount = 0.00001;
            buyAmount =
                buyAmount.clamp(minTradeAmount, parameters.maxInvestmentSize);
          } else {
            buyAmount = buyAmount.clamp(
                parameters.manualMinTradeAmount, parameters.maxInvestmentSize);
          }

          if (portfolioValue >= buyAmount * currentData.close) {
            btcAmount += buyAmount;
            portfolioValue -= buyAmount * currentData.close;

            averageEntryPrice = (averageEntryPrice * (btcAmount - buyAmount) +
                    currentData.close * buyAmount) /
                btcAmount;

            trades.add(CoreTrade(
              id: i.toString(),
              symbol: symbol,
              amount: buyAmount,
              price: currentData.close,
              timestamp: currentData.timestamp,
              type: CoreTradeType.buy,
            ));

            daysSinceLastPurchase = 0;
          }
        }

        if (btcAmount > 0 &&
            currentData.close >=
                averageEntryPrice *
                    (1 + parameters.targetProfitPercentage / 100)) {
          trades.add(CoreTrade(
            id: (i + 1000000).toString(),
            symbol: symbol,
            amount: btcAmount,
            price: currentData.close,
            timestamp: currentData.timestamp,
            type: CoreTradeType.sell,
          ));

          double sellValue = btcAmount * currentData.close;
          portfolioValue += sellValue;

          if (parameters.reinvestProfits) {
            double profit = sellValue - (btcAmount * averageEntryPrice);
            double reinvestAmount = profit / currentData.close;
            btcAmount = reinvestAmount;
            averageEntryPrice = currentData.close;
          } else {
            btcAmount = 0;
            averageEntryPrice = 0;
          }
        }
        if (i % 10 == 0) {
          // Emetti un aggiornamento ogni 10 giorni
          onProgress(i / historicalData.length, List.from(investmentOverTime));
        }
      }

      double finalPortfolioValue =
          portfolioValue + (btcAmount * historicalData.last.close);
      double totalProfit = finalPortfolioValue - parameters.investmentAmount;
      double totalReturn = totalProfit / parameters.investmentAmount;
      double maxDrawdown = (highestPortfolioValue - lowestPortfolioValue) /
          highestPortfolioValue;

      int profitableTrades = trades
          .where((t) =>
              t.type == CoreTradeType.sell && t.price > averageEntryPrice)
          .length;
      double winRate = profitableTrades /
          trades.where((t) => t.type == CoreTradeType.sell).length;

      double averageDailyReturn =
          dailyReturns.reduce((a, b) => a + b) / dailyReturns.length;
      double stdDailyReturn = sqrt(dailyReturns
              .map((r) => pow(r - averageDailyReturn, 2))
              .reduce((a, b) => a + b) /
          dailyReturns.length);
      double sharpeRatio = sqrt(252) * averageDailyReturn / stdDailyReturn;

      double sortinoRatio = calculateSortinoRatio(dailyReturns,
          0.02 / 252); // Assumendo un tasso risk-free del 2% annuo
      int totalTrades = trades.length;
      double averageTradeProfit = totalProfit / totalTrades;

      return BacktestResult(
        trades: trades,
        performance: BacktestPerformance(
          totalProfit: totalProfit,
          totalReturn: totalReturn,
          maxDrawdown: maxDrawdown,
          winRate: winRate,
          sharpeRatio: sharpeRatio,
          sortinoRatio: sortinoRatio,
          totalTrades: totalTrades,
          averageTradeProfit: averageTradeProfit,
        ),
        investmentOverTime: investmentOverTime,
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<double> getMinimumTradeAmount(String symbol) async {
    try {
      return await apiService.getMinimumTradeAmount(symbol);
    } catch (e) {
      return 0.00001; // Valore di fallback
    }
  }

  Future<List<HistoricalDataPoint>> _fetchHistoricalData(
      String symbol, DateTime startDate, DateTime endDate) async {
    final klines = await apiService.getKlines(
      symbol: symbol,
      interval: '1d',
      startTime: startDate.millisecondsSinceEpoch,
      endTime: endDate.millisecondsSinceEpoch,
    );

    return klines
        .map((kline) => HistoricalDataPoint(
              timestamp: DateTime.fromMillisecondsSinceEpoch(kline[0]),
              open: double.parse(kline[1]),
              high: double.parse(kline[2]),
              low: double.parse(kline[3]),
              close: double.parse(kline[4]),
              volume: double.parse(kline[5]),
            ))
        .toList();
  }
}

double calculateSortinoRatio(List<double> dailyReturns, double riskFreeRate) {
  double averageReturn =
      dailyReturns.reduce((a, b) => a + b) / dailyReturns.length;
  List<double> negativeReturns = dailyReturns.where((r) => r < 0).toList();
  double downsideDeviation = sqrt(negativeReturns
          .map((r) => pow(r - riskFreeRate, 2))
          .reduce((a, b) => a + b) /
      negativeReturns.length);
  return sqrt(252) * (averageReturn - riskFreeRate) / downsideDeviation;
}

class HistoricalDataPoint {
  final DateTime timestamp;
  final double open;
  final double high;
  final double low;
  final double close;
  final double volume;

  HistoricalDataPoint({
    required this.timestamp,
    required this.open,
    required this.high,
    required this.low,
    required this.close,
    required this.volume,
  });
}

class BacktestResult {
  final List<CoreTrade> trades;
  final BacktestPerformance performance;
  final List<Map<String, dynamic>> investmentOverTime;

  BacktestResult({
    required this.trades,
    required this.performance,
    required this.investmentOverTime,
  });
}

class BacktestPerformance {
  final double totalProfit;
  final double totalReturn;
  final double maxDrawdown;
  final double winRate;
  final double sharpeRatio;
  final double sortinoRatio; // Nuovo
  final int totalTrades; // Nuovo
  final double averageTradeProfit; // Nuovo

  BacktestPerformance({
    required this.totalProfit,
    required this.totalReturn,
    required this.maxDrawdown,
    required this.winRate,
    required this.sharpeRatio,
    required this.sortinoRatio,
    required this.totalTrades,
    required this.averageTradeProfit,
  });
}

```

./lib/core/services/api_service.dart:
```
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:crypto/crypto.dart';
import 'package:web_socket_channel/web_socket_channel.dart';

class ApiService {
  final String apiKey;
  final String secretKey;
  final String baseUrl = 'https://api.binance.com';

  ApiService({required this.apiKey, required this.secretKey});

  Future<int> getServerTime() async {
    try {
      final response = await http.get(Uri.parse('$baseUrl/api/v3/time'));
      if (response.statusCode == 200) {
        final serverTime = json.decode(response.body)['serverTime'];
        return serverTime;
      } else {
        throw Exception('Failed to get server time');
      }
    } catch (e) {
      rethrow;
    }
  }

  

  Stream<Map<String, dynamic>> getTickerStream(String symbol) {
    final wsUrl =
        'wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@ticker';
    final channel = WebSocketChannel.connect(Uri.parse(wsUrl));
    return channel.stream.map((event) => jsonDecode(event));
  }

  Future<double> getAccountBalance(String asset) async {
    try {
      final accountInfo = await getAccountInfo();
      final balances = accountInfo['balances'] as List<dynamic>;
      final assetBalance = balances.firstWhere(
        (balance) => balance['asset'] == asset,
        orElse: () => {'free': '0'},
      );
      return double.parse(assetBalance['free']);
    } catch (e) {
      throw Exception('Failed to get account balance: $e');
    }
  }

  Future<Map<String, dynamic>> createMarketSellOrder(
      String symbol, double quantity) async {
    try {
      final response = await createOrder(
        symbol: symbol,
        side: 'SELL',
        type: 'MARKET',
        quantity: quantity.toStringAsFixed(8),
      );
      return response;
    } catch (e) {
      throw Exception('Failed to create market sell order: $e');
    }
  }

  Future<dynamic> get(String endpoint,
      {Map<String, dynamic>? queryParams, bool requiresAuth = false}) async {
    try {
      var params = queryParams ?? {};
      if (requiresAuth) {
        final serverTime = await getServerTime();
        params['timestamp'] = serverTime.toString();
        params['recvWindow'] = '60000';
        params['signature'] = _generateSignature(params);
      }

      final uri =
          Uri.parse('$baseUrl$endpoint').replace(queryParameters: params);

      final response = await http.get(
        uri,
        headers: _getHeaders(requiresAuth),
      );
      return _handleResponse(response);
    } catch (e) {
      throw Exception('GET request failed: $endpoint. Error: $e');
    }
  }

  Future<dynamic> post(String endpoint, Map<String, dynamic> body,
      {bool requiresAuth = true}) async {
    try {
      if (requiresAuth) {
        final serverTime = await getServerTime();
        body['timestamp'] = serverTime.toString();
        body['recvWindow'] = '60000';
        body['signature'] = _generateSignature(body);
      }

      final uri = Uri.parse('$baseUrl$endpoint');

      final response = await http.post(
        uri,
        headers: _getHeaders(requiresAuth),
        body: body,
      );
      return _handleResponse(response);
    } catch (e) {
      throw Exception('POST request failed: $endpoint. Error: $e');
    }
  }

  Map<String, String> _getHeaders(bool requiresAuth) {
    var headers = {'Content-Type': 'application/x-www-form-urlencoded'};
    if (requiresAuth) {
      headers['X-MBX-APIKEY'] = apiKey;
    }
    return headers;
  }

  String _generateSignature(Map<String, dynamic> params) {
    final queryString = Uri(queryParameters: params).query;
    final hmac = Hmac(sha256, utf8.encode(secretKey));
    final signature = hmac.convert(utf8.encode(queryString)).toString();
    return signature;
  }

  dynamic _handleResponse(http.Response response) {
    if (response.statusCode >= 200 && response.statusCode < 300) {
      return json.decode(response.body);
    } else {
      throw Exception(
          'HTTP error ${response.statusCode}: ${response.reasonPhrase}\nBody: ${response.body}');
    }
  }

  Future<dynamic> getAccountInfo() async {
    return await get('/api/v3/account', requiresAuth: true);
  }

  Future<dynamic> createOrder({
    required String symbol,
    required String side,
    required String type,
    required String quantity,
    String? price,
    String? stopPrice,
  }) async {
    final body = {
      'symbol': symbol,
      'side': side,
      'type': type,
      'quantity': quantity,
      if (price != null) 'price': price,
      if (stopPrice != null) 'stopPrice': stopPrice,
    };
    return await post('/api/v3/order', body);
  }

  Future<dynamic> cancelOrder({
    required String symbol,
    String? orderId,
    String? origClientOrderId,
  }) async {
    final body = {
      'symbol': symbol,
      if (orderId != null) 'orderId': orderId,
      if (origClientOrderId != null) 'origClientOrderId': origClientOrderId,
    };
    return await post('/api/v3/order', body);
  }

  Future<dynamic> getOpenOrders({String? symbol}) async {
    return await get('/api/v3/openOrders',
        queryParams: symbol != null ? {'symbol': symbol} : null,
        requiresAuth: true);
  }

  Future<dynamic> getAllOrders({required String symbol}) async {
    return await get('/api/v3/allOrders',
        queryParams: {'symbol': symbol}, requiresAuth: true);
  }

  Future<dynamic> getExchangeInfo() async {
    return await get('/api/v3/exchangeInfo', requiresAuth: false);
  }

Future<List<List<dynamic>>> getKlines({
    required String symbol,
    required String interval,
    int? limit,
    int? startTime,
    int? endTime,
  }) async {
    final queryParams = {
      'symbol': symbol,
      'interval': interval,
      if (limit != null) 'limit': limit.toString(),
      if (startTime != null) 'startTime': startTime.toString(),
      if (endTime != null) 'endTime': endTime.toString(),
    };

    final uri = Uri.parse('$baseUrl/api/v3/klines')
        .replace(queryParameters: queryParams);
    final response = await http.get(uri);

    if (response.statusCode == 200) {
      return List<List<dynamic>>.from(json.decode(response.body));
    } else {
      throw Exception('Failed to load klines');
    }
  }

  Stream<Map<String, dynamic>> getKlineStream(String symbol, String interval) {
    final wsUrl =
        'wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_$interval';
    final channel = WebSocketChannel.connect(Uri.parse(wsUrl));

    return channel.stream.map((event) {
      return jsonDecode(event);
    });
  }
  Future<Map<String, dynamic>> get24hrTickerPriceChange(String symbol) async {
    return await get('/api/v3/ticker/24hr',
        queryParams: {'symbol': symbol}, requiresAuth: false);
  }


  Future<double> getCurrentPrice(String symbol) async {
    try {
      final response = await get('/api/v3/ticker/price',
          queryParams: {'symbol': symbol}, requiresAuth: false);
      if (response is Map<String, dynamic> && response.containsKey('price')) {
        return double.parse(response['price']);
      } else {
        throw Exception('Unexpected response format for price');
      }
    } catch (e) {
      return 0.0; // Return a default value or throw an exception based on your needs
    }
  }

  Future<List<String>> getValidTradingSymbols() async {
    final response = await get('/api/v3/exchangeInfo', requiresAuth: false);
    final symbols = (response['symbols'] as List<dynamic>)
        .map((symbol) => symbol['symbol'] as String)
        .toList();
    return symbols;
  }

  Future<List<Map<String, dynamic>>> getMyTrades(
      {required String symbol, int? limit, int? startTime}) async {
    try {
      final params = {
        'symbol': symbol,
        if (limit != null) 'limit': limit.toString(),
        if (startTime != null) 'startTime': startTime.toString(),
      };
      final response = await get('/api/v3/myTrades',
          queryParams: params, requiresAuth: true);
      if (response is List) {
        return response.cast<Map<String, dynamic>>();
      } else {
        return [];
      }
    } catch (e) {
      rethrow;
    }
  }

  Future<dynamic> getAccountTradeList({required String symbol}) async {
    return await get('/api/v3/myTrades',
        queryParams: {'symbol': symbol}, requiresAuth: true);
  }

  Future<dynamic> getDepositHistory() async {
    return await get('/sapi/v1/capital/deposit/hisrec', requiresAuth: true);
  }

  Future<dynamic> getWithdrawHistory() async {
    return await get('/sapi/v1/capital/withdraw/history', requiresAuth: true);
  }

  Future<dynamic> getDepositAddress({required String coin}) async {
    return await get('/sapi/v1/capital/deposit/address',
        queryParams: {'coin': coin}, requiresAuth: true);
  }

  Future<dynamic> withdraw({
    required String coin,
    required String address,
    required String amount,
    String? network,
  }) async {
    final body = {
      'coin': coin,
      'address': address,
      'amount': amount,
      if (network != null) 'network': network,
    };
    return await post('/sapi/v1/capital/withdraw/apply', body);
  }

  Future<double> getMinimumTradeAmount(String symbol) async {
    try {
      final response = await get('/api/v3/exchangeInfo',
          queryParams: {'symbol': symbol}, requiresAuth: false);
      final filters = response['symbols'][0]['filters'] as List<dynamic>;
      final lotSizeFilter =
          filters.firstWhere((filter) => filter['filterType'] == 'LOT_SIZE');
      return double.parse(lotSizeFilter['minQty']);
    } catch (e) {
      // In caso di errore, restituisci un valore di default
      return 0.00001; // Questo è un valore arbitrario, regolalo secondo le tue esigenze
    }
  }

  Stream<double> getPriceStream(String symbol) async* {
    final ws = await WebSocket.connect(
        'wss://stream.binance.com:9443/ws/$symbol@trade');

    try {
      await for (var message in ws) {
        final data = json.decode(message);
        yield double.parse(data['p']);
      }
    } finally {
      await ws.close();
    }
  }

  Future<String> createMarketBuyOrder(String symbol, double quantity) async {
    return await createOrder(
      symbol: symbol,
      side: 'BUY',
      type: 'MARKET',
      quantity: quantity.toStringAsFixed(8),
    );
  }

  Future<String> createLimitBuyOrder(
      String symbol, double quantity, double price) async {
    return await createOrder(
      symbol: symbol,
      side: 'BUY',
      type: 'LIMIT',
      quantity: quantity.toStringAsFixed(8),
      price: price.toStringAsFixed(8),
    );
  }

  Future<String> createLimitSellOrder(
      String symbol, double quantity, double price) async {
    return await createOrder(
      symbol: symbol,
      side: 'SELL',
      type: 'LIMIT',
      quantity: quantity.toStringAsFixed(8),
      price: price.toStringAsFixed(8),
    );
  }
}

```

./lib/core/services/trading_service.dart:
```
import 'dart:math';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';

class TradingService {
  final ApiService _apiService;
  final DatabaseService _databaseService;
  final StrategyRepository _strategyRepository;

  TradingService(
    this._apiService,
    this._databaseService,
    this._strategyRepository,
  );

  Future<double> getCurrentPrice(String symbol) async {
    try {
      // Tenta di ottenere il prezzo corrente dall'API
      final price = await _apiService.getCurrentPrice(symbol);

      // Salva il prezzo nel database locale per uso futuro
      await _databaseService.insert('price_history', {
        'symbol': symbol,
        'price': price,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });

      return price;
    } catch (e) {

      // Se fallisce l'API, prova a ottenere l'ultimo prezzo salvato dal database
      try {
        final latestPrice = await _databaseService.query(
          'price_history',
          where: 'symbol = ?',
          whereArgs: [symbol],
          orderBy: 'timestamp DESC',
          limit: 1,
        );

        if (latestPrice.isNotEmpty) {
          return latestPrice.first['price'];
        }
      } catch (dbError) {
              throw Exception('dbError: $dbError');

      }

      // Se non riesce a ottenere il prezzo né dall'API né dal database, lancia un'eccezione
      throw Exception('Unable to get current price for $symbol');
    }
  }

  Future<void> sellEntirePortfolio(String symbol, double targetProfit) async {
    try {
      // Ottieni il saldo attuale per il simbolo specificato
      final balance = await _apiService.getAccountBalance(symbol);

      if (balance > 0) {
        // Crea un ordine di vendita al mercato per l'intero saldo
        final order = await _apiService.createMarketSellOrder(symbol, balance);

        // Assumiamo che l'API restituisca il prezzo medio di esecuzione
        final executionPrice = double.parse(order['avgPrice'] ?? '0');

        // Registra la transazione nel database
        await _databaseService.insert('trades', {
          'symbol': symbol,
          'amount': balance,
          'price': executionPrice,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
          'type': 'sell',
        });

        // Aggiorna le statistiche
        final currentStats = await _strategyRepository.getStrategyStatistics();
        final updatedStats = {
          ...currentStats,
          'totalInvested': 0.0,
          'totalProfit': currentStats['totalProfit'] + targetProfit,
          'totalTrades': currentStats['totalTrades'] + 1,
        };
        await _databaseService.insert('strategy_statistics', updatedStats);
      }
    } catch (e) {
      // Gestisci eventuali errori
      throw Exception('Failed to sell entire portfolio: $e');
    }
  }

  Future<void> executeStrategy(StrategyParameters params) async {
    try {
      double currentPrice = await _apiService.getCurrentPrice(params.symbol);
      double minimumTradableAmount = params.useAutoMinTradeAmount
          ? await _apiService.getMinimumTradeAmount(params.symbol)
          : params.manualMinTradeAmount;

      double amountToBuy =
          _calculateBuyAmount(params, minimumTradableAmount, currentPrice);

      if (await _shouldBuy(params, currentPrice)) {
        await _executeBuy(params.symbol, amountToBuy, currentPrice,
            params.isVariableInvestmentAmount);
      } else if (await _shouldSell(params, currentPrice)) {
        await _executeSell(params, currentPrice);
      }

      await _checkAndExecuteTakeProfit(params);
    } catch (e) {
      throw Exception('Failed to execute strategy: $e');
    }
  }

  double _calculateBuyAmount(StrategyParameters params,
      double minimumTradableAmount, double currentPrice) {
    double baseAmount = params.investmentAmount;
    if (params.isVariableInvestmentAmount) {
      double variationPercentage = (params.variableInvestmentPercentage / 100);
      double randomFactor =
          1 + (Random().nextDouble() * 2 - 1) * variationPercentage;
      baseAmount *= randomFactor;
    }
    return (baseAmount / currentPrice)
        .clamp(minimumTradableAmount, params.maxInvestmentSize);
  }

  Future<bool> _shouldBuy(
      StrategyParameters params, double currentPrice) async {
    Portfolio portfolio = await _getPortfolio(params.symbol);
    return currentPrice <=
        portfolio.averagePrice * (1 - params.stopLossPercentage / 100);
  }

  Future<bool> _shouldSell(
      StrategyParameters params, double currentPrice) async {
    Portfolio portfolio = await _getPortfolio(params.symbol);
    return currentPrice >=
        portfolio.averagePrice * (1 + params.targetProfitPercentage / 100);
  }

  Future<void> _executeBuy(String symbol, double amount, double price,
      bool isVariableInvestment) async {
    CoreTrade trade = CoreTrade(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      symbol: symbol,
      amount: amount,
      price: price,
      timestamp: DateTime.now(),
      type: CoreTradeType.buy,
    );

    await _strategyRepository.saveTradeWithNewFields(
        trade, isVariableInvestment, null);
  }

  Future<void> _executeSell(
      StrategyParameters params, double currentPrice) async {
    Portfolio portfolio = await _getPortfolio(params.symbol);
    CoreTrade trade = CoreTrade(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      symbol: params.symbol,
      amount: portfolio.totalAmount,
      price: currentPrice,
      timestamp: DateTime.now(),
      type: CoreTradeType.sell,
    );

    double profit =
        (currentPrice - portfolio.averagePrice) * portfolio.totalAmount;
    await _strategyRepository.saveTradeWithNewFields(trade, false, null);

    if (params.reinvestProfits) {
      await _reinvestProfit(params.symbol, profit, currentPrice);
    }
  }

  Future<void> _reinvestProfit(
      String symbol, double profit, double currentPrice) async {
    double amountToBuy = profit / currentPrice;
    CoreTrade reinvestmentTrade = CoreTrade(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      symbol: symbol,
      amount: amountToBuy,
      price: currentPrice,
      timestamp: DateTime.now(),
      type: CoreTradeType.buy,
    );

    await _strategyRepository.saveTradeWithNewFields(
        reinvestmentTrade, false, profit);
  }

  Future<void> _checkAndExecuteTakeProfit(StrategyParameters params) async {
    double currentPrice = await _apiService.getCurrentPrice(params.symbol);
    Portfolio portfolio = await _getPortfolio(params.symbol);

    if (currentPrice >=
        portfolio.averagePrice * (1 + params.targetProfitPercentage / 100)) {
      await _executeSell(params, currentPrice);
    }
  }

  Future<Portfolio> _getPortfolio(String symbol) async {
    List<CoreTrade> trades = await _strategyRepository.getRecentTrades(1000);
    trades = trades.where((trade) => trade.symbol == symbol).toList();

    double totalAmount = 0;
    double totalValue = 0;

    for (var trade in trades) {
      if (trade.type == CoreTradeType.buy) {
        totalAmount += trade.amount;
        totalValue += trade.amount * trade.price;
      } else {
        totalAmount -= trade.amount;
        totalValue -= trade.amount * trade.price;
      }
    }

    double averagePrice = totalAmount > 0 ? totalValue / totalAmount : 0;

    return Portfolio(
      symbol: symbol,
      totalAmount: totalAmount,
      averagePrice: averagePrice,
    );
  }
}

class Portfolio {
  final String symbol;
  final double totalAmount;
  final double averagePrice;

  Portfolio({
    required this.symbol,
    required this.totalAmount,
    required this.averagePrice,
  });
}

```

./lib/core/services/secure_storage_service.dart:
```
// lib/core/services/secure_storage_service.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class SecureStorageService {
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  Future<void> saveApiKey(String apiKey) async {
    await _storage.write(key: 'apiKey', value: apiKey);
  }

  Future<String?> getApiKey() async {
    return await _storage.read(key: 'apiKey');
  }

  Future<void> saveSecretKey(String secretKey) async {
    await _storage.write(key: 'secretKey', value: secretKey);
  }

  Future<String?> getSecretKey() async {
    return await _storage.read(key: 'secretKey');
  }

  Future<void> saveValue(String key, String value) async {
    await _storage.write(key: key, value: value);
  }

  Future<String?> getValue(String key) async {
    return await _storage.read(key: key);
  }
}

```

./lib/core/services/database_service.dart:
```
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'dart:convert';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class DatabaseService {
  static Database? _database;
  static const String _databaseName = 'trading_strategy_1777_41.db';
  static const int _databaseVersion = 4;

  Future<void> initDatabase() async {
    if (_database != null) return;
    String path = join(await getDatabasesPath(), _databaseName);
    _database = await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _createDb,
      onUpgrade: _upgradeDb,
      onConfigure: _configureDb,
    );
  }

  Future<Database> get database async {
    if (_database == null) {
      await initDatabase();
    }
    return _database!;
  }

  Future<void> _configureDb(Database db) async {
    await db.execute('PRAGMA foreign_keys = ON');
  }

  Future<void> _createDb(Database db, int version) async {
    await db.execute('''
      CREATE TABLE trades(
        id TEXT PRIMARY KEY,
        symbol TEXT NOT NULL,
        amount REAL NOT NULL,
        price REAL NOT NULL,
        timestamp INTEGER NOT NULL,
        type TEXT NOT NULL,
        isVariableInvestment INTEGER NOT NULL,
        reinvestedProfit REAL
      )
    ''');

    await db.execute('''
      CREATE TABLE strategy_parameters(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT NOT NULL,
        investmentAmount REAL NOT NULL,
        intervalDays INTEGER NOT NULL,
        targetProfitPercentage REAL NOT NULL,
        stopLossPercentage REAL NOT NULL,
        purchaseFrequency INTEGER NOT NULL,
        maxInvestmentSize REAL NOT NULL,
        useAutoMinTradeAmount INTEGER NOT NULL,
        manualMinTradeAmount REAL NOT NULL,
        isVariableInvestmentAmount INTEGER NOT NULL,
        variableInvestmentPercentage REAL NOT NULL,
        reinvestProfits INTEGER NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE strategy_status(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        status TEXT NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE price_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT NOT NULL,
        price REAL NOT NULL,
        timestamp INTEGER NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE portfolio (
        id TEXT PRIMARY KEY,
        assets TEXT NOT NULL,
        totalValue REAL NOT NULL,
        lastUpdated INTEGER NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE portfolio_value (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT NOT NULL,
        value REAL NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE active_strategy (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        strategy_parameters TEXT NOT NULL
      )
    ''');

    await db.execute('''
      CREATE INDEX idx_trades_symbol ON trades(symbol)
    ''');

    await db.execute('''
      CREATE INDEX idx_price_history_symbol_timestamp ON price_history(symbol, timestamp)
    ''');
  }

  Future<void> _upgradeDb(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      await db.execute(
          'ALTER TABLE trades ADD COLUMN isVariableInvestment INTEGER NOT NULL DEFAULT 0');
      await db.execute('ALTER TABLE trades ADD COLUMN reinvestedProfit REAL');
    }
    if (oldVersion < 3) {
      await db.execute('''
        CREATE TABLE IF NOT EXISTS portfolio (
          id TEXT PRIMARY KEY,
          assets TEXT NOT NULL,
          totalValue REAL NOT NULL,
          lastUpdated INTEGER NOT NULL
        )
      ''');
    }
    if (oldVersion < 4) {
      await db.execute('''
        CREATE TABLE IF NOT EXISTS portfolio_value (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          date TEXT NOT NULL,
          value REAL NOT NULL
        )
      ''');

      await db.execute('''
        CREATE TABLE IF NOT EXISTS active_strategy (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          strategy_parameters TEXT NOT NULL
        )
      ''');
    }
  }

  Future<int> insert(String table, Map<String, dynamic> data) async {
    Database db = await database;
    return await db.insert(table, data,
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<List<Map<String, dynamic>>> query(
    String table, {
    bool? distinct,
    List<String>? columns,
    String? where,
    List<Object?>? whereArgs,
    String? groupBy,
    String? having,
    String? orderBy,
    int? limit,
    int? offset,
  }) async {
    Database db = await database;
    return await db.query(
      table,
      distinct: distinct,
      columns: columns,
      where: where,
      whereArgs: whereArgs,
      groupBy: groupBy,
      having: having,
      orderBy: orderBy,
      limit: limit,
      offset: offset,
    );
  }

  Future<int> update(String table, Map<String, dynamic> data,
      {String? where, List<Object?>? whereArgs}) async {
    Database db = await database;
    return await db.update(table, data, where: where, whereArgs: whereArgs);
  }

  Future<int> delete(String table,
      {String? where, List<Object?>? whereArgs}) async {
    Database db = await database;
    return await db.delete(table, where: where, whereArgs: whereArgs);
  }

  Future<void> saveStrategyParameters(StrategyParameters params) async {
    Database db = await database;
    await db.insert(
      'strategy_parameters',
      params.toJson(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<StrategyParameters?> getStrategyParameters() async {
    Database db = await database;
    List<Map<String, dynamic>> results = await db.query('strategy_parameters');
    if (results.isNotEmpty) {
      return StrategyParameters.fromJson(results.first);
    }
    return null;
  }

  Future<List<Map<String, dynamic>>> getRecentTrades(int limit) async {
    Database db = await database;
    return await db.query('trades', orderBy: 'timestamp DESC', limit: limit);
  }

  Future<void> performMaintenance() async {
    Database db = await database;
    await db.execute('VACUUM');
    await db.execute('ANALYZE');
  }

  Future<bool> isDatabaseHealthy() async {
    try {
      Database db = await database;
      await db.rawQuery('SELECT 1');
      return true;
    } catch (e) {
      return false;
    }
  }

  Future<void> backupDatabase() async {
    Database db = await database;
    String path = db.path;
    String backupPath = '$path.backup';
    await db.rawQuery('VACUUM INTO ?', [backupPath]);
  }

  Future<void> checkAndCleanupOldData() async {
    Database db = await database;
    final thirtyDaysAgo = DateTime.now()
        .subtract(const Duration(days: 30))
        .millisecondsSinceEpoch;

    await db.delete('price_history',
        where: 'timestamp < ?', whereArgs: [thirtyDaysAgo]);
    await db
        .delete('trades', where: 'timestamp < ?', whereArgs: [thirtyDaysAgo]);
  }

  Future<void> optimizeDatabasePerformance() async {
    Database db = await database;
    await db.execute('PRAGMA optimize');
  }

  Future<StrategyParameters?> getActiveStrategy() async {
    final db = await database;
    final results = await db.query('active_strategy', limit: 1);
    if (results.isNotEmpty) {
      final json = results.first['strategy_parameters'] as String;
      return StrategyParameters.fromJson(jsonDecode(json));
    }
    return null;
  }

  Future<double> getPortfolioValueForDate(DateTime date) async {
    final db = await database;
    final results = await db.query(
      'portfolio_value',
      where: 'date = ?',
      whereArgs: [date.toIso8601String().split('T')[0]],
      limit: 1,
    );
    if (results.isNotEmpty) {
      return results.first['value'] as double;
    }
    return 0.0;
  }

  Future<void> savePortfolioValue(DateTime date, double value) async {
    final db = await database;
    await db.insert(
      'portfolio_value',
      {
        'date': date.toIso8601String().split('T')[0],
        'value': value,
      },
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }
}

```

./lib/core/repositories/trading_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

abstract class TradingRepository {
  Future<List<CoreTrade>> getTrades();
  Future<void> executeTrade(CoreTrade trade);
}

```

./lib/core/repositories/trading_repository_impl.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/repositories/trading_repository.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/features/settings/models/settings_model.dart';

class TradingRepositoryImpl implements TradingRepository {
  final ApiService _apiService;
  final DatabaseService _databaseService;
  final SettingsModel _settings;

  TradingRepositoryImpl(
      this._apiService, this._databaseService, this._settings);

  @override
  Future<List<CoreTrade>> getTrades() async {
    if (_settings.isDemoMode) {
      return _getDemoTrades();
    } else {
      try {
        final json = await _apiService.get('trades');
        final trades = (json['trades'] as List)
            .map((e) => CoreTrade(
                  id: e['id'],
                  symbol: e['symbol'],
                  amount: e['amount'],
                  price: e['price'],
                  timestamp:
                      DateTime.fromMillisecondsSinceEpoch(e['timestamp']),
                  type: e['type'],
                ))
            .toList();
        return trades;
      } catch (e) {
        // If API call fails, try to get data from local database
        final data = await _databaseService.query('trades');
        return data
            .map((e) => CoreTrade(
                  id: e['id'],
                  symbol: e['symbol'],
                  amount: e['amount'],
                  price: e['price'],
                  timestamp: DateTime.fromMillisecondsSinceEpoch(
                    e['timestamp'],
                  ),
                  type: e['type'],
                ))
            .toList();
      }
    }
  }

  @override
  Future<void> executeTrade(CoreTrade trade) async {
    if (_settings.isDemoMode) {
      await _executeDemoTrade(trade);
    } else {
      try {
        await _apiService.post('trades', {
          'symbol': trade.symbol,
          'amount': trade.amount,
          'price': trade.price,
        });
      } catch (e) {
        // If API call fails, save to local database
        await _databaseService.insert('trades', {
          'id': trade.id,
          'symbol': trade.symbol,
          'amount': trade.amount,
          'price': trade.price,
          'timestamp': trade.timestamp.millisecondsSinceEpoch,
        });
      }
    }
  }

  Future<List<CoreTrade>> _getDemoTrades() async {
    // Recupera le operazioni demo dal database locale
    final data = await _databaseService.query('demo_trades');
    return data
        .map(
          (e) => CoreTrade(
            id: e['id'],
            symbol: e['symbol'],
            amount: e['amount'],
            price: e['price'],
            timestamp: DateTime.fromMillisecondsSinceEpoch(e['timestamp']),
            type: e['type'],
          ),
        )
        .toList();
  }

  Future<void> _executeDemoTrade(CoreTrade trade) async {
    // Salva l'operazione demo nel database locale
    await _databaseService.insert('demo_trades', {
      'id': trade.id,
      'symbol': trade.symbol,
      'amount': trade.amount,
      'price': trade.price,
      'timestamp': trade.timestamp.millisecondsSinceEpoch,
    });
  }
}

```

./lib/core/repositories/portfolio_repository_impl.dart:
```
import 'package:cost_averaging_trading_app/core/dtos/portfolio_dto.dart';
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/repositories/portfolio_repository.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';

class PortfolioRepositoryImpl implements PortfolioRepository {
  final ApiService _apiService;
  final DatabaseService _databaseService;

  PortfolioRepositoryImpl(this._apiService, this._databaseService);

  @override
  Future<Portfolio> getPortfolio() async {
    try {
      final json = await _apiService.get('portfolio');
      final dto = PortfolioDTO.fromJson(json);
      return Portfolio(
        id: dto.id,
        assets: dto.assets,
        totalValue: dto.totalValue,
      );
    } catch (e) {
      // If API call fails, try to get data from local database
      final data = await _databaseService.query('portfolio');
      if (data.isNotEmpty) {
        final dto = PortfolioDTO.fromDatabase(data.first);
        return Portfolio(
          id: dto.id,
          assets: dto.assets,
          totalValue: dto.totalValue,
        );
      }
      throw Exception('Failed to get portfolio data');
    }
  }

  @override
  Future<void> updatePortfolio(Portfolio portfolio) async {
    final dto = PortfolioDTO(
      id: portfolio.id,
      assets: portfolio.assets,
      totalValue: portfolio.totalValue,
    );
    try {
      await _apiService.post('portfolio', dto.toJson());
    } catch (e) {
      // If API call fails, update local database
      await _databaseService.insert('portfolio', dto.toDatabase());
    }
  }
}

```

./lib/core/repositories/portfolio_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';

abstract class PortfolioRepository {
  Future<Portfolio> getPortfolio();
  Future<void> updatePortfolio(Portfolio portfolio);
}

```

./lib/core/models/portfolio.dart:
```
// lib/core/models/portfolio.dart

import 'package:equatable/equatable.dart';

class Portfolio extends Equatable {
  final String id;
  final Map<String, double> assets;
  final double totalValue;

  const Portfolio({
    required this.id,
    required this.assets,
    required this.totalValue,
  });

  @override
  List<Object?> get props => [id, assets, totalValue];

  factory Portfolio.fromJson(Map<String, dynamic> json) {
    return Portfolio(
      id: json['id'],
      assets: Map<String, double>.from(json['assets']),
      totalValue: json['totalValue'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'assets': assets,
      'totalValue': totalValue,
    };
  }
}

```

./lib/core/models/trade.dart:
```
// lib/core/models/trade.dart

import 'package:equatable/equatable.dart';

enum CoreTradeType { buy, sell }

class CoreTrade extends Equatable {
  final String id;
  final String symbol;
  final double amount;
  final double price;
  final DateTime timestamp;
  final CoreTradeType type;

  const CoreTrade({
    required this.id,
    required this.symbol,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  @override
  List<Object?> get props => [id, symbol, amount, price, timestamp, type];

  CoreTrade copyWith({
    String? id,
    String? symbol,
    double? amount,
    double? price,
    DateTime? timestamp,
    CoreTradeType? type,
  }) {
    return CoreTrade(
      id: id ?? this.id,
      symbol: symbol ?? this.symbol,
      amount: amount ?? this.amount,
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      type: type ?? this.type,
    );
  }

factory CoreTrade.fromJson(Map<String, dynamic> json) {
    return CoreTrade(
      id: json['id']?.toString() ?? '',
      symbol: json['symbol'] ?? '',
      amount: double.tryParse(json['qty']?.toString() ?? '0') ?? 0.0,
      price: double.tryParse(json['price']?.toString() ?? '0') ?? 0.0,
      timestamp: json['time'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['time'] as int)
          : DateTime.now(),
      type: json['isBuyer'] == true ? CoreTradeType.buy : CoreTradeType.sell,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'symbol': symbol,
      'amount': amount,
      'price': price,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'type': type == CoreTradeType.buy ? 'buy' : 'sell',
    };
  }
}

```

./lib/core/models/risk_management_settings.dart:
```
class RiskManagementSettings {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  RiskManagementSettings({
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
  });
}
```

./lib/core/models/strategy_execution_result.dart:
```
enum StrategyExecutionResult {
  success,
  tradeNotAllowed,
  insufficientTime,
  stopLossTriggered,
  error;

  bool get isSuccess => this == StrategyExecutionResult.success;
  bool get isTradeNotAllowed => this == StrategyExecutionResult.tradeNotAllowed;
  bool get isInsufficientTime => this == StrategyExecutionResult.insufficientTime;
  bool get isStopLossTriggered => this == StrategyExecutionResult.stopLossTriggered;
  bool get isError => this == StrategyExecutionResult.error;

  String get message {
    switch (this) {
      case StrategyExecutionResult.success:
        return 'Strategy executed successfully';
      case StrategyExecutionResult.tradeNotAllowed:
        return 'Trade not allowed due to risk limits';
      case StrategyExecutionResult.insufficientTime:
        return 'Insufficient time since last trade';
      case StrategyExecutionResult.stopLossTriggered:
        return 'Stop loss triggered, entire portfolio sold';
      case StrategyExecutionResult.error:
        return 'An error occurred during strategy execution';
    }
  }
}
```

./lib/core/utils/breakpoints.dart:
```
class Breakpoints {
  static const double mobileSmall = 320;
  static const double mobileMedium = 375;
  static const double mobileLarge = 425;
  static const double tablet = 768;
  static const double laptop = 1024;
  static const double laptopLarge = 1440;
  static const double desktop4K = 2560;

  static bool isMobile(double width) => width < tablet;
  static bool isTablet(double width) => width >= tablet && width < laptop;
  static bool isDesktop(double width) => width >= laptop;

  static String getDeviceType(double width) {
    if (width < mobileMedium) {
      return 'mobile_small';
    } else if (width < mobileLarge) {
      return 'mobile_medium';
    } else if (width < tablet) {
      return 'mobile_large';
    } else if (width < laptop) {
      return 'tablet';
    } else if (width < laptopLarge) {
      return 'laptop';
    } else if (width < desktop4K) {
      return 'laptop_large';
    } else {
      return 'desktop_4k';
    }
  }
}

```

./lib/core/error/error_handler.dart:
```
// lib/core/error/error_handler.dart


class ErrorHandler {
  static void logError(String message, dynamic error, StackTrace stackTrace) {
    // In un'applicazione reale, qui potresti inviare l'errore a un servizio di logging remoto
  }

  static String getUserFriendlyErrorMessage(dynamic error) {
    if (error is NetworkError) {
      return 'Si è verificato un problema di connessione. Controlla la tua connessione internet e riprova.';
    } else if (error is AuthenticationError) {
      return 'Si è verificato un problema di autenticazione. Per favore, effettua nuovamente il login.';
    } else if (error is ValidationError) {
      return 'Si è verificato un problema con i dati inseriti. Per favore, controlla i tuoi input e riprova.';
    } else if (error is ApiError) {
      return 'Si è verificato un errore durante la comunicazione con il server. Per favore, riprova più tardi.';
    } else {
      return 'Si è verificato un errore imprevisto. Per favore, riprova più tardi.';
    }
  }
}

class NetworkError implements Exception {}

class AuthenticationError implements Exception {}

class ValidationError implements Exception {}

class ApiError implements Exception {
  final String message;
  ApiError(this.message);
}

```

