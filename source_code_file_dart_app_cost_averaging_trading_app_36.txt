./lib/main.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/app.dart';
import 'package:cost_averaging_trading_app/core/providers/app_providers.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await dotenv.load(fileName: ".env");

  if (!kIsWeb) {
    sqfliteFfiInit();
    databaseFactory = databaseFactoryFfi;
  }

  runApp(
    const AppProviders(
      child: App(),
    ),
  );
}
```

./lib/routes.dart:
```
// lib/routes.dart
import 'package:flutter/material.dart';

import 'package:cost_averaging_trading_app/features/dashboard/ui/pages/dashboard_page.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/pages/portfolio_page.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/pages/settings_page.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/pages/strategy_page.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/pages/trade_history_page.dart';
import 'package:cost_averaging_trading_app/ui/layouts/main_layout.dart';

class Routes {
  static const String dashboard = '/';
  static const String portfolio = '/portfolio';
  static const String strategy = '/strategy';
  static const String tradeHistory = '/trade-history';
  static const String settings = '/settings';

  static Route<dynamic> generateRoute(RouteSettings setting) {
    switch (setting.name) {
      case dashboard:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: DashboardPage()));
      case portfolio:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: PortfolioPage()));
      case strategy:
        return MaterialPageRoute(
          builder: (_) => const MainLayout(child: StrategyPage()),
        );
      case tradeHistory:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: TradeHistoryPage()));
      case settings:
        return MaterialPageRoute(
            builder: (_) => const MainLayout(child: SettingsPage()));
      default:
        return MaterialPageRoute(
          builder: (_) => Scaffold(
            body: Center(
              child: Text('No route defined for ${setting.name}'),
            ),
          ),
        );
    }
  }
}

```

./lib/app.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/theme/app_theme.dart';
import 'package:cost_averaging_trading_app/routes.dart';

class App extends StatelessWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Cost Averaging Trading App',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system,
      initialRoute: Routes.dashboard,
      onGenerateRoute: Routes.generateRoute,
    );
  }
}
```

./lib/ui/widgets/responsive_text.dart:
```
import 'package:auto_size_text/auto_size_text.dart';
import 'package:flutter/material.dart';

class ResponsiveText extends StatelessWidget {
  final String text;
  final TextStyle? style;
  final int maxLines;
  final TextAlign textAlign;

  const ResponsiveText(
    this.text, {
    super.key,
    this.style,
    this.maxLines = 1,
    this.textAlign = TextAlign.start,
  });

  @override
  Widget build(BuildContext context) {
    return AutoSizeText(
      text,
      style: style,
      maxLines: maxLines,
      textAlign: textAlign,
      overflow: TextOverflow.ellipsis,
    );
  }
}
```

./lib/ui/layouts/custom_page_layout.dart:
```
import 'package:flutter/material.dart';
import 'package:responsive_builder/responsive_builder.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class CustomPageLayout extends StatelessWidget {
  final String title;
  final List<Widget> children;
  final Widget? floatingActionButton;

  const CustomPageLayout({
    super.key,
    required this.title,
    required this.children,
    this.floatingActionButton,
  });

  @override
  Widget build(BuildContext context) {
    return ResponsiveBuilder(
      builder: (context, sizingInformation) {
        return Scaffold(
          body: CustomScrollView(
            slivers: [
              SliverAppBar(
                expandedHeight: 120.0,
                floating: false,
                pinned: true,
                flexibleSpace: FlexibleSpaceBar(
                  title: ResponsiveText(
                    title,
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  centerTitle: false,
                ),
              ),
              SliverPadding(
                padding:
                    EdgeInsets.all(sizingInformation.isMobile ? 16.0 : 24.0),
                sliver: SliverList(
                  delegate: SliverChildBuilderDelegate(
                    (BuildContext context, int index) {
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 16.0),
                        child: children[index],
                      );
                    },
                    childCount: children.length,
                  ),
                ),
              ),
            ],
          ),
          floatingActionButton: floatingActionButton,
        );
      },
    );
  }
}

```

./lib/ui/layouts/main_layout.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_state.dart';
import 'package:cost_averaging_trading_app/routes.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class MainLayout extends StatelessWidget {
  final Widget child;

  const MainLayout({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    final bool isDesktop = MediaQuery.of(context).size.width >= 600;

    return Scaffold(
      appBar: AppBar(
        title: const ResponsiveText(
          'Cost Averaging Trading App',
          style: TextStyle(fontSize: 20),
        ),
        automaticallyImplyLeading: !isDesktop,
        actions: [
          BlocBuilder<SettingsBloc, SettingsState>(
            builder: (context, state) {
              if (state is SettingsLoaded && state.isDemoMode) {
                return const Chip(
                  label: Text('Demo Mode'),
                  backgroundColor: Colors.orange,
                );
              }
              return const SizedBox.shrink();
            },
          ),
        ],
      ),
      drawer: isDesktop ? null : const AppDrawer(),
      body: SafeArea(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (isDesktop) const AppDrawer(),
            Expanded(child: child),
          ],
        ),
      ),
    );
  }
}

class AppDrawer extends StatelessWidget {
  const AppDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    return Drawer(
      child: ListView(
        children: [
          const DrawerHeader(
            child: ResponsiveText(
              'Menu',
              style: TextStyle(fontSize: 24),
            ),
          ),
          _buildMenuItem(context, 'Dashboard', Routes.dashboard),
          _buildMenuItem(context, 'Strategy', Routes.strategy),
          _buildMenuItem(context, 'Portfolio', Routes.portfolio),
          _buildMenuItem(context, 'Trade History', Routes.tradeHistory),
          _buildMenuItem(context, 'Settings', Routes.settings),
        ],
      ),
    );
  }

  Widget _buildMenuItem(BuildContext context, String title, String route) {
    return ListTile(
      title: ResponsiveText(
        title,
        style: const TextStyle(fontSize: 18),
      ),
      onTap: () {
        Navigator.pushReplacementNamed(context, route);
      },
    );
  }
}

```

./lib/features/trade_history/ui/widgets/trade_stats.dart:
```
// lib/features/trade_history/ui/widgets/trade_stats.dart

import 'package:flutter/material.dart';

class TradeStats extends StatelessWidget {
  final Map<String, dynamic> stats;

  const TradeStats({super.key, required this.stats});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Trade Statistics',
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            Text('Total Trades: ${stats['totalTrades']}'),
            Text('Buy Trades: ${stats['buyTrades']}'),
            Text('Sell Trades: ${stats['sellTrades']}'),
            Text('Total Volume: \$${stats['totalVolume'].toStringAsFixed(2)}'),
            Text(
                'Total Profit/Loss: \$${stats['totalProfit'].toStringAsFixed(2)}'),
            const SizedBox(height: 8),
            Text('Asset Volumes:',
                style: Theme.of(context).textTheme.titleMedium),
            ...(stats['assetVolumes'] as Map<String, double>).entries.map(
                  (entry) =>
                      Text('${entry.key}: \$${entry.value.toStringAsFixed(2)}'),
                ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/trade_history/ui/widgets/statistics.dart:
```
import 'package:flutter/material.dart';

class Statistics extends StatelessWidget {
  final Map<String, dynamic> statistics;

  const Statistics({super.key, required this.statistics});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Trade Statistics', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            Text('Total Trades: ${statistics['totalTrades']}'),
            Text('Buy Trades: ${statistics['buyTrades']}'),
            Text('Sell Trades: ${statistics['sellTrades']}'),
            Text('Total Volume: \$${statistics['totalVolume'].toStringAsFixed(2)}'),
            Text('Total Profit/Loss: \$${statistics['totalProfit'].toStringAsFixed(2)}'),
            const SizedBox(height: 8),
            Text('Asset Volumes:', style: Theme.of(context).textTheme.titleMedium),
            ...(statistics['assetVolumes'] as Map<String, double>).entries.map(
              (entry) => Text('${entry.key}: \$${entry.value.toStringAsFixed(2)}'),
            ),
          ],
        ),
      ),
    );
  }
}
```

./lib/features/trade_history/ui/widgets/filters.dart:
```
import 'package:flutter/material.dart';

class Filters extends StatefulWidget {
  final Function(DateTime?, DateTime?, String?) onFilterApplied;

  const Filters({super.key, required this.onFilterApplied});

  @override
  FiltersState createState() => FiltersState();
}

class FiltersState extends State<Filters> {
  DateTime? _startDate;
  DateTime? _endDate;
  String? _selectedAssetPair;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Filters', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    decoration: const InputDecoration(labelText: 'Start Date'),
                    onTap: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: DateTime.now(),
                        firstDate: DateTime(2000),
                        lastDate: DateTime.now(),
                      );
                      if (date != null) {
                        setState(() => _startDate = date);
                      }
                    },
                    controller: TextEditingController(
                      text: _startDate != null
                          ? '${_startDate!.toLocal()}'.split(' ')[0]
                          : '',
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: TextFormField(
                    decoration: const InputDecoration(labelText: 'End Date'),
                    onTap: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: DateTime.now(),
                        firstDate: DateTime(2000),
                        lastDate: DateTime.now(),
                      );
                      if (date != null) {
                        setState(() => _endDate = date);
                      }
                    },
                    controller: TextEditingController(
                      text: _endDate != null
                          ? '${_endDate!.toLocal()}'.split(' ')[0]
                          : '',
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              decoration: const InputDecoration(labelText: 'Asset Pair'),
              value: _selectedAssetPair,
              items: ['BTC/USDT', 'ETH/USDT', 'XRP/USDT']
                  .map((pair) =>
                      DropdownMenuItem(value: pair, child: Text(pair)))
                  .toList(),
              onChanged: (value) => setState(() => _selectedAssetPair = value),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => widget.onFilterApplied(
                  _startDate, _endDate, _selectedAssetPair),
              child: const Text('Apply Filters'),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/trade_history/ui/widgets/trade_filters.dart:
```
// lib/features/trade_history/ui/widgets/trade_filters.dart

import 'package:flutter/material.dart';

class TradeFilters extends StatefulWidget {
  final Function(DateTime?, DateTime?, String?) onFilterApplied;

  const TradeFilters({super.key, required this.onFilterApplied});

  @override
  TradeFiltersState createState() => TradeFiltersState();
}

class TradeFiltersState extends State<TradeFilters> {
  DateTime? _startDate;
  DateTime? _endDate;
  String? _selectedAssetPair;

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Filters', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: TextFormField(
                    decoration: const InputDecoration(labelText: 'Start Date'),
                    onTap: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: DateTime.now(),
                        firstDate: DateTime(2000),
                        lastDate: DateTime.now(),
                      );
                      if (date != null) {
                        setState(() => _startDate = date);
                      }
                    },
                    controller: TextEditingController(
                      text: _startDate != null
                          ? '${_startDate!.toLocal()}'.split(' ')[0]
                          : '',
                    ),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: TextFormField(
                    decoration: const InputDecoration(labelText: 'End Date'),
                    onTap: () async {
                      final date = await showDatePicker(
                        context: context,
                        initialDate: DateTime.now(),
                        firstDate: DateTime(2000),
                        lastDate: DateTime.now(),
                      );
                      if (date != null) {
                        setState(() => _endDate = date);
                      }
                    },
                    controller: TextEditingController(
                      text: _endDate != null
                          ? '${_endDate!.toLocal()}'.split(' ')[0]
                          : '',
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              decoration: const InputDecoration(labelText: 'Asset Pair'),
              value: _selectedAssetPair,
              items: ['BTC/USDT', 'ETH/USDT', 'XRP/USDT']
                  .map((pair) =>
                      DropdownMenuItem(value: pair, child: Text(pair)))
                  .toList(),
              onChanged: (value) => setState(() => _selectedAssetPair = value),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => widget.onFilterApplied(
                  _startDate, _endDate, _selectedAssetPair),
              child: const Text('Apply Filters'),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/trade_history/ui/widgets/trade_list.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class TradeList extends StatelessWidget {
  final List<CoreTrade> trades;

  const TradeList({super.key, required this.trades});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: trades.length,
      itemBuilder: (context, index) {
        final trade = trades[index];
        return Card(
          child: ListTile(
            title: Text('${trade.type.name.toUpperCase()} ${trade.amount} ${trade.symbol}'),
            subtitle: Text('Price: ${trade.price} | ${DateFormat.yMd().add_Hms().format(trade.timestamp)}'),
            trailing: Text(
              '${trade.type.name == 'buy' ? '-' : '+'}${(trade.amount * trade.price).toStringAsFixed(2)}',
              style: TextStyle(
                color: trade.type.name == 'buy' ? Colors.red : Colors.green,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        );
      },
    );
  }
}
```

./lib/features/trade_history/ui/pages/trade_history_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/widgets/shared_widgets.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_bloc.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_state.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_event.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/widgets/trade_list.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/widgets/trade_filters.dart';
import 'package:cost_averaging_trading_app/features/trade_history/ui/widgets/trade_stats.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class TradeHistoryPage extends StatelessWidget {
  const TradeHistoryPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<TradeHistoryBloc, TradeHistoryState>(
      builder: (context, state) {
        if (state is TradeHistoryInitial || state is TradeHistoryLoading) {
          return const LoadingIndicator(message: 'Loading trade history...');
        } else if (state is TradeHistoryLoaded) {
          return _buildLoadedContent(context, state);
        } else if (state is TradeHistoryError) {
          return ErrorMessage(message: state.message);
        }
        return const ErrorMessage(message: 'Unknown state');
      },
    );
  }

  Widget _buildLoadedContent(BuildContext context, TradeHistoryLoaded state) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth > 600) {
          return _buildWideLayout(context, state);
        } else {
          return _buildNarrowLayout(context, state);
        }
      },
    );
  }

  Widget _buildWideLayout(BuildContext context, TradeHistoryLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Trade History',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 16),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  flex: 2,
                  child: Column(
                    children: [
                      CustomCard(
                        child: TradeFilters(
                          onFilterApplied: (startDate, endDate, assetPair) {
                            context.read<TradeHistoryBloc>().add(
                                  FilterTradeHistory(
                                    startDate: startDate,
                                    endDate: endDate,
                                    assetPair: assetPair,
                                  ),
                                );
                          },
                        ),
                      ),
                      const SizedBox(height: 16),
                      CustomCard(
                        child: TradeStats(stats: state.statistics),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  flex: 3,
                  child: CustomCard(
                    child: TradeList(trades: state.trades),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNarrowLayout(BuildContext context, TradeHistoryLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Trade History',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: TradeFilters(
                onFilterApplied: (startDate, endDate, assetPair) {
                  context.read<TradeHistoryBloc>().add(
                        FilterTradeHistory(
                          startDate: startDate,
                          endDate: endDate,
                          assetPair: assetPair,
                        ),
                      );
                },
              ),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: TradeStats(stats: state.statistics),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: TradeList(trades: state.trades),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/trade_history/blocs/trade_history_state.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

abstract class TradeHistoryState {}

class TradeHistoryInitial extends TradeHistoryState {}

class TradeHistoryLoading extends TradeHistoryState {}

class TradeHistoryLoaded extends TradeHistoryState {
  final List<CoreTrade> trades;
  final Map<String, dynamic> statistics;

  TradeHistoryLoaded({required this.trades, required this.statistics});
}

class TradeHistoryError extends TradeHistoryState {
  final String message;

  TradeHistoryError(this.message);
}
```

./lib/features/trade_history/blocs/trade_history_event.dart:
```
abstract class TradeHistoryEvent {}

class LoadTradeHistory extends TradeHistoryEvent {}

class FilterTradeHistory extends TradeHistoryEvent {
  final DateTime? startDate;
  final DateTime? endDate;
  final String? assetPair;

  FilterTradeHistory({this.startDate, this.endDate, this.assetPair});
}
```

./lib/features/trade_history/blocs/trade_history_bloc.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_event.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_state.dart';
import 'package:cost_averaging_trading_app/features/trade_history/repositories/trade_history_repository.dart';

class TradeHistoryBloc extends Bloc<TradeHistoryEvent, TradeHistoryState> {
  final TradeHistoryRepository _repository;

  TradeHistoryBloc(this._repository) : super(TradeHistoryInitial()) {
    on<LoadTradeHistory>(_onLoadTradeHistory);
    on<FilterTradeHistory>(_onFilterTradeHistory);

    // Aggiungiamo questa riga per caricare i dati all'inizializzazione
    add(LoadTradeHistory());
  }

  Future<void> _onLoadTradeHistory(
    LoadTradeHistory event,
    Emitter<TradeHistoryState> emit,
  ) async {
    emit(TradeHistoryLoading());
    try {
      final trades = await _repository.getTradeHistory();
      final statistics = _calculateStatistics(trades);
      emit(TradeHistoryLoaded(trades: trades, statistics: statistics));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error loading trade history', e, stackTrace);
      emit(TradeHistoryError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }

  Future<void> _onFilterTradeHistory(
    FilterTradeHistory event,
    Emitter<TradeHistoryState> emit,
  ) async {
    emit(TradeHistoryLoading());
    try {
      final trades = await _repository.getFilteredTradeHistory(
        startDate: event.startDate,
        endDate: event.endDate,
        assetPair: event.assetPair,
      );
      final statistics = _calculateStatistics(trades);
      emit(TradeHistoryLoaded(trades: trades, statistics: statistics));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error filtering trade history', e, stackTrace);
      emit(TradeHistoryError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }

  Map<String, dynamic> _calculateStatistics(List<CoreTrade> trades) {
    final totalTrades = trades.length;
    final buyTrades =
        trades.where((trade) => trade.type.name.toLowerCase() == 'buy').length;
    final sellTrades = totalTrades - buyTrades;

    double totalVolume = 0;
    double totalProfit = 0;
    Map<String, double> assetVolumes = {};

    for (var trade in trades) {
      final tradeVolume = trade.amount * trade.price;
      totalVolume += tradeVolume;

      if (trade.type.name.toLowerCase() == 'sell') {
        totalProfit += tradeVolume;
      } else {
        totalProfit -= tradeVolume;
      }

      assetVolumes[trade.symbol] =
          (assetVolumes[trade.symbol] ?? 0) + tradeVolume;
    }

    return {
      'totalTrades': totalTrades,
      'buyTrades': buyTrades,
      'sellTrades': sellTrades,
      'totalVolume': totalVolume,
      'totalProfit': totalProfit,
      'assetVolumes': assetVolumes,
    };
  }
}

```

./lib/features/trade_history/repositories/trade_history_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class TradeHistoryRepository {
  Future<List<CoreTrade>> getTradeHistory() async {
    // Simulazione di una chiamata API
    await Future.delayed(const Duration(seconds: 1));
    
    // Dati di esempio
    return [
      CoreTrade(
        id: '1',
        symbol: 'BTC/USDT',
        amount: 0.1,
        price: 50000,
        timestamp: DateTime.now().subtract(const Duration(days: 1)),
        type: CoreTradeType.sell,
      ),
      CoreTrade(
        id: '2',
        symbol: 'ETH/USDT',
        amount: 1.5,
        price: 3000,
        timestamp: DateTime.now().subtract(const Duration(hours: 12)),
        type: CoreTradeType.sell,
      ),
      // Aggiungi altri trade di esempio qui
    ];
  }

  Future<List<CoreTrade>> getFilteredTradeHistory({
    DateTime? startDate,
    DateTime? endDate,
    String? assetPair,
  }) async {
    // Simulazione di una chiamata API con filtri
    await Future.delayed(const Duration(seconds: 1));
    
    List<CoreTrade> allTrades = await getTradeHistory();
    
    return allTrades.where((trade) {
      bool dateCondition = true;
      if (startDate != null) {
        dateCondition = dateCondition && trade.timestamp.isAfter(startDate);
      }
      if (endDate != null) {
        dateCondition = dateCondition && trade.timestamp.isBefore(endDate);
      }
      bool assetCondition = assetPair == null || trade.symbol == assetPair;
      
      return dateCondition && assetCondition;
    }).toList();
  }
}
```

./lib/features/trade_history/models/trade_history_model.dart:
```
class TradeHistoryTrade {
  final String id;
  final String assetPair;
  final double amount;
  final double price;
  final DateTime timestamp;
  final String type; // 'buy' o 'sell'

  TradeHistoryTrade({
    required this.id,
    required this.assetPair,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  factory TradeHistoryTrade.fromJson(Map<String, dynamic> json) {
    return TradeHistoryTrade(
      id: json['id'],
      assetPair: json['assetPair'],
      amount: json['amount'].toDouble(),
      price: json['price'].toDouble(),
      timestamp: DateTime.parse(json['timestamp']),
      type: json['type'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'assetPair': assetPair,
      'amount': amount,
      'price': price,
      'timestamp': timestamp.toIso8601String(),
      'type': type,
    };
  }
}

class TradeHistoryModel {
  final List<TradeHistoryTrade> trades;

  TradeHistoryModel({required this.trades});

  factory TradeHistoryModel.fromJson(Map<String, dynamic> json) {
    var tradeList = json['trades'] as List;
    List<TradeHistoryTrade> trades =
        tradeList.map((i) => TradeHistoryTrade.fromJson(i)).toList();
    return TradeHistoryModel(trades: trades);
  }

  Map<String, dynamic> toJson() {
    return {
      'trades': trades.map((trade) => trade.toJson()).toList(),
    };
  }
}

```

./lib/features/strategy/ui/widgets/backtest_result_view.dart:
```
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_event.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/backtest_progress_chart.dart';
import 'package:provider/provider.dart';

class BacktestResultView extends StatelessWidget {
  final BacktestResult result;

  const BacktestResultView({super.key, required this.result});

  @override
  Widget build(BuildContext context) {
    final spots = result.investmentOverTime
        .asMap()
        .entries
        .map((entry) => FlSpot(entry.key.toDouble(), entry.value['value']))
        .toList();

    final minY = spots.map((spot) => spot.y).reduce((a, b) => a < b ? a : b);
    final maxY = spots.map((spot) => spot.y).reduce((a, b) => a > b ? a : b);

    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Backtest Results',
                style: Theme.of(context).textTheme.headlineSmall),
            const SizedBox(height: 16),
            BacktestProgressChart(spots: spots, minY: minY, maxY: maxY),
            const SizedBox(height: 16),
            Text('Performance Metrics:',
                style: Theme.of(context).textTheme.titleLarge),
            Text(
                'Total Profit: \$${result.performance.totalProfit.toStringAsFixed(2)}'),
            Text(
                'Total Return: ${(result.performance.totalReturn * 100).toStringAsFixed(2)}%'),
            Text(
                'Max Drawdown: ${(result.performance.maxDrawdown * 100).toStringAsFixed(2)}%'),
            Text(
                'Win Rate: ${(result.performance.winRate * 100).toStringAsFixed(2)}%'),
            Text(
                'Sharpe Ratio: ${result.performance.sharpeRatio.toStringAsFixed(2)}'),
            const SizedBox(height: 16),
            ElevatedButton(
              child: const Text('Back to Strategy'),
              onPressed: () =>
                  context.read<StrategyBloc>().add(LoadStrategyData()),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/risk_info_card.dart:
```
import 'package:flutter/material.dart';

class RiskInfoCard extends StatelessWidget {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  const RiskInfoCard({
    super.key,
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Risk Management Settings',
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            _buildInfoRow('Max Loss Percentage',
                '${maxLossPercentage.toStringAsFixed(2)}%'),
            _buildInfoRow(
                'Max Concurrent Trades', maxConcurrentTrades.toString()),
            _buildInfoRow('Max Position Size',
                '${maxPositionSizePercentage.toStringAsFixed(2)}%'),
            _buildInfoRow('Daily Exposure Limit',
                '\$${dailyExposureLimit.toStringAsFixed(2)}'),
            _buildInfoRow('Max Allowed Volatility',
                '${(maxAllowedVolatility * 100).toStringAsFixed(2)}%'),
            _buildInfoRow('Max Rebuy Count', maxRebuyCount.toString()),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),
          Text(value),
        ],
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_monitor.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class StrategyMonitor extends StatelessWidget {
  final double totalInvested;
  final double currentProfit;
  final int tradeCount;
  final double averageBuyPrice;
  final double currentMarketPrice;
  final List<CoreTrade> recentTrades;

  const StrategyMonitor({
    super.key,
    required this.totalInvested,
    required this.currentProfit,
    required this.tradeCount,
    required this.averageBuyPrice,
    required this.currentMarketPrice,
    required this.recentTrades,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Strategy Monitor',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 16),
        _buildOverview(context),
        const SizedBox(height: 16),
        _buildPriceChart(context),
        const SizedBox(height: 16),
        _buildRecentTrades(context),
      ],
    );
  }

  Widget _buildOverview(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Total Invested: \$${totalInvested.toStringAsFixed(2)}'),
            Text('Current Profit/Loss: \$${currentProfit.toStringAsFixed(2)}'),
            Text('Number of Trades: $tradeCount'),
            Text('Average Buy Price: \$${averageBuyPrice.toStringAsFixed(2)}'),
            Text(
                'Current Market Price: \$${currentMarketPrice.toStringAsFixed(2)}'),
          ],
        ),
      ),
    );
  }

  Widget _buildPriceChart(BuildContext context) {
    if (recentTrades.isEmpty) {
      return const Center(child: Text('No recent trades available'));
    }

    // Create data points for the chart
    final dataPoints = recentTrades.map((trade) {
      return FlSpot(
        trade.timestamp.millisecondsSinceEpoch.toDouble(),
        trade.price,
      );
    }).toList();

    return SizedBox(
      height: 200,
      child: LineChart(
        LineChartData(
          gridData: const FlGridData(show: false),
          titlesData: const FlTitlesData(show: false),
          borderData: FlBorderData(show: true),
          minX: dataPoints.isNotEmpty ? dataPoints.first.x : 0,
          maxX: dataPoints.isNotEmpty ? dataPoints.last.x : 0,
          minY: dataPoints.isNotEmpty ? dataPoints.map((e) => e.y).reduce((a, b) => a < b ? a : b) : 0,
          maxY: dataPoints.isNotEmpty ? dataPoints.map((e) => e.y).reduce((a, b) => a > b ? a : b) : 0,
          lineBarsData: [
            LineChartBarData(
              spots: dataPoints,
              isCurved: true,
              color: Colors.blue,
              barWidth: 2,
              isStrokeCapRound: true,
              dotData: const FlDotData(show: false),
              belowBarData: BarAreaData(show: false),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRecentTrades(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Recent Trades',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        const SizedBox(height: 8),
        SizedBox(
          height: 200,
          child: ListView.builder(
            itemCount: recentTrades.length,
            itemBuilder: (context, index) {
              final trade = recentTrades[index];
              return ListTile(
                title: Text(
                    '${trade.type == CoreTradeType.buy ? 'Buy' : 'Sell'} ${trade.amount.toStringAsFixed(8)} ${trade.symbol}'),
                subtitle: Text('Price: \$${trade.price.toStringAsFixed(2)}'),
                trailing: Text(trade.timestamp.toString().split(' ')[0]),
              );
            },
          ),
        ),
      ],
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_status.dart:
```
import 'package:flutter/material.dart';

enum StrategyStatus { inactive, active, paused }

class StrategyStatusWidget extends StatelessWidget {
  final StrategyStatus status;
  final VoidCallback onStart;
  final VoidCallback onStop;
  final VoidCallback onSellEntirePortfolio;

  const StrategyStatusWidget({
    super.key,
    required this.status,
    required this.onStart,
    required this.onStop,
    required this.onSellEntirePortfolio,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Strategy Status: ${status.toString().split('.').last}'),
        ElevatedButton(
          onPressed: status == StrategyStatus.inactive ? onStart : null,
          child: const Text('Start Strategy'),
        ),
        ElevatedButton(
          onPressed: status == StrategyStatus.active ? onStop : null,
          child: const Text('Stop Strategy'),
        ),
        ElevatedButton(
          onPressed:
              status == StrategyStatus.active ? onSellEntirePortfolio : null,
          child: const Text('Sell Entire Portfolio'),
        ),
      ],
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_chart.dart:
```
// lib/features/strategy/ui/widgets/strategy_chart.dart

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class StrategyChart extends StatelessWidget {
  final List<Map<String, dynamic>> chartData;

  const StrategyChart({super.key, required this.chartData});

  @override
  Widget build(BuildContext context) {
    if (chartData.isEmpty) {
      return const Center(child: Text('No chart data available'));
    }
    final minY = chartData
        .map((d) => (d['value'] as num).toDouble())
        .reduce((a, b) => a < b ? a : b);
    final maxY = chartData
        .map((d) => (d['value'] as num).toDouble())
        .reduce((a, b) => a > b ? a : b);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SizedBox(
          height: 300,
          child: LineChart(
            LineChartData(
              gridData: const FlGridData(show: false),
              titlesData: const FlTitlesData(show: false),
              borderData: FlBorderData(show: true),
              minX: 0,
              maxX: chartData.length.toDouble() - 1,
              minY: minY,
              maxY: maxY,
              lineBarsData: [
                LineChartBarData(
                  spots: chartData.asMap().entries.map((entry) {
                    return FlSpot(
                      entry.key.toDouble(),
                      (entry.value['value'] as num).toDouble(),
                    );
                  }).toList(),
                  isCurved: true,
                  color: Theme.of(context).primaryColor,
                  dotData: const FlDotData(show: false),
                  belowBarData: BarAreaData(
                      show: true,
                      color: Theme.of(context).primaryColor.withOpacity(0.3)),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/backtest_results.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class BacktestResults extends StatelessWidget {
  final BacktestResult? backtestResult;
  final Function(DateTime startDate, DateTime endDate) onRunBacktest;

  const BacktestResults({
    super.key,
    this.backtestResult,
    required this.onRunBacktest,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Backtest Results',
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 16),
        _buildBacktestControls(context),
        if (backtestResult != null) ...[
          const SizedBox(height: 16),
          _buildPerformanceSummary(context),
          const SizedBox(height: 16),
          _buildPerformanceChart(context),
          const SizedBox(height: 16),
          _buildTradesList(context),
        ],
      ],
    );
  }

  Widget _buildBacktestControls(BuildContext context) {
    return Row(
      children: [
        ElevatedButton(
          onPressed: () {
            final now = DateTime.now();
            final oneYearAgo = now.subtract(const Duration(days: 365));
            onRunBacktest(oneYearAgo, now);
          },
          child: const Text('Run Backtest (Last Year)'),
        ),
      ],
    );
  }

  Widget _buildPerformanceSummary(BuildContext context) {
    final performance = backtestResult!.performance;
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Performance Summary',
                style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Text(
                'Total Profit: \$${performance.totalProfit.toStringAsFixed(2)}'),
            Text(
                'Total Return: ${(performance.totalReturn * 100).toStringAsFixed(2)}%'),
            Text(
                'Max Drawdown: ${(performance.maxDrawdown * 100).toStringAsFixed(2)}%'),
            Text(
                'Win Rate: ${(performance.winRate * 100).toStringAsFixed(2)}%'),
            Text('Sharpe Ratio: ${performance.sharpeRatio.toStringAsFixed(2)}'),
          ],
        ),
      ),
    );
  }

  Widget _buildPerformanceChart(BuildContext context) {
    // Create data points for the chart
    final trades = backtestResult!.trades;
    final dataPoints = trades.map((trade) {
      return FlSpot(
        trade.timestamp.millisecondsSinceEpoch.toDouble(),
        trade.price,
      );
    }).toList();

    return SizedBox(
      height: 300,
      child: LineChart(
        LineChartData(
          gridData: const FlGridData(show: false),
          titlesData: const FlTitlesData(show: false),
          borderData: FlBorderData(show: true),
          minX: dataPoints.first.x,
          maxX: dataPoints.last.x,
          minY: dataPoints.map((e) => e.y).reduce((a, b) => a < b ? a : b),
          maxY: dataPoints.map((e) => e.y).reduce((a, b) => a > b ? a : b),
          lineBarsData: [
            LineChartBarData(
              spots: dataPoints,
              isCurved: true,
              color: Colors.blue,
              barWidth: 2,
              isStrokeCapRound: true,
              dotData: const FlDotData(show: false),
              belowBarData: BarAreaData(show: false),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTradesList(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Trades',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        const SizedBox(height: 8),
        SizedBox(
          height: 200,
          child: ListView.builder(
            itemCount: backtestResult!.trades.length,
            itemBuilder: (context, index) {
              final trade = backtestResult!.trades[index];
              return ListTile(
                title: Text(
                    '${trade.type == CoreTradeType.buy ? 'Buy' : 'Sell'} ${trade.amount.toStringAsFixed(8)} ${trade.symbol}'),
                subtitle: Text('Price: \$${trade.price.toStringAsFixed(2)}'),
                trailing: Text(trade.timestamp.toString().split(' ')[0]),
              );
            },
          ),
        ),
      ],
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_control_panel.dart:
```
import 'package:flutter/material.dart';

class StrategyControlPanel extends StatelessWidget {
  final bool isRunning;
  final VoidCallback onStartLive;
  final VoidCallback onStartDemo;
  final VoidCallback onStop;
  final VoidCallback onBacktest; // Nuovo callback per il backtest

  const StrategyControlPanel({
    super.key,
    required this.isRunning,
    required this.onStartLive,
    required this.onStartDemo,
    required this.onStop,
    required this.onBacktest, // Aggiunto il nuovo parametro
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Strategy Control',
                style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            Wrap(
              spacing: 8.0,
              runSpacing: 8.0,
              alignment: WrapAlignment.spaceAround,
              children: [
                ElevatedButton(
                  onPressed: isRunning ? null : onStartLive,
                  child: const Text('Start Live'),
                ),
                ElevatedButton(
                  onPressed: isRunning ? null : onStartDemo,
                  child: const Text('Start Demo'),
                ),
                ElevatedButton(
                  onPressed: isRunning ? onStop : null,
                  style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                  child: const Text('Stop'),
                ),
                ElevatedButton(
                  onPressed: isRunning
                      ? null
                      : onBacktest,
                  style: ElevatedButton.styleFrom(backgroundColor: Colors.orange), // Nuovo pulsante per il backtest
                  child: const Text('Run Backtest'),
                ),
              ],
            ),
            if (isRunning)
              const Padding(
                padding: EdgeInsets.only(top: 16.0),
                child: Text(
                  'Strategy is currently running',
                  style: TextStyle(
                      color: Colors.green, fontWeight: FontWeight.bold),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/widgets/strategy_parameters_form.dart:
```
import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class StrategyParametersForm extends StatefulWidget {
  final StrategyParameters initialParameters;
  final Function(StrategyParameters) onParametersChanged;

  const StrategyParametersForm({
    super.key,
    required this.initialParameters,
    required this.onParametersChanged,
  });

  @override
  StrategyParametersFormState createState() => StrategyParametersFormState();
}

class StrategyParametersFormState extends State<StrategyParametersForm> {
  late TextEditingController _symbolController;
  late TextEditingController _investmentAmountController;
  late TextEditingController _purchaseFrequencyController;
  late TextEditingController _targetProfitPercentageController;
  late TextEditingController _stopLossPercentageController;
  late bool _useAutoMinTradeAmount;
  late bool _isVariableInvestmentAmount;
  late bool _reinvestProfits;

  @override
  void initState() {
    super.initState();
    _symbolController =
        TextEditingController(text: widget.initialParameters.symbol);
    _investmentAmountController = TextEditingController(
        text: widget.initialParameters.investmentAmount.toString());
    _purchaseFrequencyController = TextEditingController(
        text: widget.initialParameters.purchaseFrequency.toString());
    _targetProfitPercentageController = TextEditingController(
        text: widget.initialParameters.targetProfitPercentage.toString());
    _stopLossPercentageController = TextEditingController(
        text: widget.initialParameters.stopLossPercentage.toString());
    _useAutoMinTradeAmount = widget.initialParameters.useAutoMinTradeAmount;
    _isVariableInvestmentAmount =
        widget.initialParameters.isVariableInvestmentAmount;
    _reinvestProfits = widget.initialParameters.reinvestProfits;
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          TextFormField(
            controller: _symbolController,
            decoration: const InputDecoration(
                labelText: 'Trading Symbol (e.g., BTCUSDT)'),
            onChanged: (_) => _updateParameters(),
          ),
          TextFormField(
            controller: _investmentAmountController,
            decoration: const InputDecoration(
                labelText: 'Investment Amount per Purchase'),
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          TextFormField(
            controller: _purchaseFrequencyController,
            decoration: const InputDecoration(
                labelText: 'Purchase Frequency (in hours)'),
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          TextFormField(
            controller: _targetProfitPercentageController,
            decoration: const InputDecoration(labelText: 'Target Profit (%)'),
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          TextFormField(
            controller: _stopLossPercentageController,
            decoration: const InputDecoration(labelText: 'Stop Loss (%)'),
            keyboardType: TextInputType.number,
            onChanged: (_) => _updateParameters(),
          ),
          SwitchListTile(
            title: const Text('Use Auto Minimum Trade Amount'),
            value: _useAutoMinTradeAmount,
            onChanged: (value) {
              setState(() {
                _useAutoMinTradeAmount = value;
              });
              _updateParameters();
            },
          ),
          SwitchListTile(
            title: const Text('Use Variable Investment Amount'),
            value: _isVariableInvestmentAmount,
            onChanged: (value) {
              setState(() {
                _isVariableInvestmentAmount = value;
              });
              _updateParameters();
            },
          ),
          SwitchListTile(
            title: const Text('Reinvest Profits'),
            value: _reinvestProfits,
            onChanged: (value) {
              setState(() {
                _reinvestProfits = value;
              });
              _updateParameters();
            },
          ),
        ],
      ),
    );
  }

  void _updateParameters() {
    final updatedParameters = StrategyParameters(
      symbol: _symbolController.text,
      investmentAmount: double.tryParse(_investmentAmountController.text) ?? 0,
      purchaseFrequency: int.tryParse(_purchaseFrequencyController.text) ?? 0,
      targetProfitPercentage:
          double.tryParse(_targetProfitPercentageController.text) ?? 0,
      stopLossPercentage:
          double.tryParse(_stopLossPercentageController.text) ?? 0,
      useAutoMinTradeAmount: _useAutoMinTradeAmount,
      isVariableInvestmentAmount: _isVariableInvestmentAmount,
      reinvestProfits: _reinvestProfits,
      // Altri parametri rimangono invariati
      intervalDays: widget.initialParameters.intervalDays,
      maxInvestmentSize: widget.initialParameters.maxInvestmentSize,
      manualMinTradeAmount: widget.initialParameters.manualMinTradeAmount,
      variableInvestmentPercentage:
          widget.initialParameters.variableInvestmentPercentage,
    );
    widget.onParametersChanged(updatedParameters);
  }

  @override
  void dispose() {
    _symbolController.dispose();
    _investmentAmountController.dispose();
    _purchaseFrequencyController.dispose();
    _targetProfitPercentageController.dispose();
    _stopLossPercentageController.dispose();
    super.dispose();
  }
}

```

./lib/features/strategy/ui/widgets/backtest_progress_chart.dart:
```
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class BacktestProgressChart extends StatelessWidget {
  final List<FlSpot> spots;
  final double minY;
  final double maxY;

  const BacktestProgressChart({
    super.key,
    required this.spots,
    required this.minY,
    required this.maxY,
  });

  @override
  Widget build(BuildContext context) {
    return AspectRatio(
      aspectRatio: 1.70,
      child: LineChart(
        LineChartData(
          gridData: const FlGridData(show: false),
          titlesData: const FlTitlesData(show: false),
          borderData: FlBorderData(show: true),
          minX: 0,
          maxX: spots.length.toDouble() - 1,
          minY: minY,
          maxY: maxY,
          lineBarsData: [
            LineChartBarData(
              spots: spots,
              isCurved: true,
              color: Theme.of(context).primaryColor,
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: const FlDotData(show: false),
              belowBarData: BarAreaData(show: false),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/strategy/ui/pages/strategy_page.dart:
```
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_event.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/backtest_progress_chart.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/backtest_result_view.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_parameters_form.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_monitor.dart';
import 'package:cost_averaging_trading_app/features/strategy/ui/widgets/strategy_control_panel.dart';

class StrategyPage extends StatelessWidget {
  const StrategyPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<StrategyBloc, StrategyState>(
      builder: (context, state) {
        if (state is StrategyLoaded) {
          return SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Strategy Configuration',
                      style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  StrategyParametersForm(
                    initialParameters: state.parameters,
                    onParametersChanged: (parameters) {
                      context
                          .read<StrategyBloc>()
                          .add(UpdateStrategyParameters(parameters));
                    },
                  ),
                  const SizedBox(height: 24),
                  StrategyControlPanel(
                    isRunning: state.status == StrategyStateStatus.active,
                    onStartLive: () =>
                        context.read<StrategyBloc>().add(StartLiveStrategy()),
                    onStartDemo: () =>
                        context.read<StrategyBloc>().add(StartDemoStrategy()),
                    onStop: () =>
                        context.read<StrategyBloc>().add(StopStrategy()),
                    onBacktest: () => _showBacktestDialog(context),
                  ),
                  if (state.status == StrategyStateStatus.active)
                    StrategyMonitor(
                      totalInvested: state.totalInvested,
                      currentProfit: state.currentProfit,
                      tradeCount: state.tradeCount,
                      averageBuyPrice: state.averageBuyPrice,
                      currentMarketPrice: state.currentMarketPrice,
                      recentTrades: state.recentTrades,
                    ),
                ],
              ),
            ),
          );
        } else if (state is BacktestInProgress) {
          return const Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                CircularProgressIndicator(),
                SizedBox(height: 16),
                Text('Running Backtest...'),
              ],
            ),
          );
        } else if (state is BacktestCompleted) {
          return BacktestResultView(result: state.result);
        } else if (state is BacktestError) {
          return Center(child: Text('Backtest Error: ${state.error}'));
        } else if (state is BacktestProgressUpdate) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                CircularProgressIndicator(value: state.progress),
                const SizedBox(height: 16),
                Text(
                    'Running Backtest: ${(state.progress * 100).toStringAsFixed(1)}%'),
                const SizedBox(height: 16),
                BacktestProgressChart(
                  spots: state.currentInvestmentOverTime
                      .asMap()
                      .entries
                      .map((entry) =>
                          FlSpot(entry.key.toDouble(), entry.value['value']))
                      .toList(),
                  minY: state.currentInvestmentOverTime
                      .map((e) => e['value'] as double)
                      .reduce((a, b) => a < b ? a : b),
                  maxY: state.currentInvestmentOverTime
                      .map((e) => e['value'] as double)
                      .reduce((a, b) => a > b ? a : b),
                ),
              ],
            ),
          );
        }
        return const Center(child: CircularProgressIndicator());
      },
    );
  }

  void _showBacktestDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Run Backtest'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('Select backtest period:'),
              ElevatedButton(
                child: const Text('Last 30 days'),
                onPressed: () {
                  Navigator.of(context).pop();
                  context.read<StrategyBloc>().add(RunBacktestEvent(
                        DateTime.now().subtract(const Duration(days: 30)),
                        DateTime.now(),
                      ));
                },
              ),
              ElevatedButton(
                child: const Text('Last 90 days'),
                onPressed: () {
                  Navigator.of(context).pop();
                  context.read<StrategyBloc>().add(RunBacktestEvent(
                        DateTime.now().subtract(const Duration(days: 90)),
                        DateTime.now(),
                      ));
                },
              ),
            ],
          ),
        );
      },
    );
  }
}

```

./lib/features/strategy/blocs/strategy_bloc.dart:
```
import 'package:cost_averaging_trading_app/core/services/trading_service.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_event.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';
import 'package:cost_averaging_trading_app/core/services/risk_management_service.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';

class StrategyBloc extends Bloc<StrategyEvent, StrategyState> {
  final StrategyRepository _strategyRepository;
  final RiskManagementService _riskManagementService;
  final BacktestingService _backtestingService;
  final TradingService _tradingService;

  StrategyBloc(
    this._strategyRepository,
    this._riskManagementService,
    this._backtestingService,
    this._tradingService,
  ) : super(StrategyInitial()) {
    on<LoadStrategyData>(_onLoadStrategyData);
    on<UpdateStrategyParameters>(_onUpdateStrategyParameters);
    on<StartStrategyEvent>(_onStartStrategy);
    on<StopStrategy>(_onStopStrategy);
    on<RunBacktestEvent>(_onRunBacktest);
    on<StartDemoStrategy>(_onStartDemoStrategy);
    on<StartLiveStrategy>(_onStartLiveStrategy);
    on<ForceStartStrategy>(_onForceStartStrategy);
    on<SellEntirePortfolio>(_onSellEntirePortfolio);
    on<UpdateUseAutoMinTradeAmount>(_onUpdateUseAutoMinTradeAmount);
    on<UpdateManualMinTradeAmount>(_onUpdateManualMinTradeAmount);
    on<UpdateIsVariableInvestmentAmount>(_onUpdateIsVariableInvestmentAmount);
    on<UpdateVariableInvestmentPercentage>(
        _onUpdateVariableInvestmentPercentage);
    on<UpdateReinvestProfits>(_onUpdateReinvestProfits);
    on<StartMonitoring>(_onStartMonitoring);
    on<StopMonitoring>(_onStopMonitoring);
    on<UpdateMonitoringData>(_onUpdateMonitoringData);
    // Carica i dati iniziali automaticamente
    add(LoadStrategyData());
  }

  Future<void> _onLoadStrategyData(
    LoadStrategyData event,
    Emitter<StrategyState> emit,
  ) async {
    try {
      emit(StrategyLoading());
      final parameters = await _strategyRepository.getStrategyParameters();
      final status = await _strategyRepository.getStrategyStatus();
      final chartData = await _strategyRepository.getStrategyChartData();
      final riskManagementSettings =
          await _riskManagementService.getRiskManagementSettings();
      final statistics = await _strategyRepository.getStrategyStatistics();
      final recentTrades = await _strategyRepository.getRecentTrades(10);

      emit(StrategyLoaded(
        parameters: parameters,
        status: status,
        chartData: chartData,
        riskManagementSettings: riskManagementSettings,
        totalInvested: statistics['totalInvested'] ?? 0,
        currentProfit: statistics['totalProfit'] ?? 0,
        tradeCount: statistics['totalTrades'] ?? 0,
        averageBuyPrice: statistics['averageBuyPrice'] ?? 0,
        currentMarketPrice:
            await _tradingService.getCurrentPrice(parameters.symbol),
        recentTrades: recentTrades,
      ));
    } catch (e) {
      emit(StrategyError('Failed to load strategy data: ${e.toString()}'));
    }
  }

  Future<void> _onUpdateStrategyParameters(
    UpdateStrategyParameters event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository.saveStrategyParameters(event.parameters);
        emit(currentState.copyWith(parameters: event.parameters));
      } catch (e) {
        emit(StrategyError(
            'Failed to update strategy parameters: ${e.toString()}'));
      }
    }
  }

  Future<void> _onStartStrategy(
    StartStrategyEvent event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        final isStrategySafe = await _riskManagementService
            .isStrategySafe(currentState.parameters);
        if (isStrategySafe) {
          await _strategyRepository
              .updateStrategyStatus(StrategyStateStatus.active);
          emit(currentState.copyWith(status: StrategyStateStatus.active));
        } else {
          emit(StrategyUnsafe(
            message:
                'Strategy is not safe to start based on current risk management settings.',
            parameters: currentState.parameters,
            status: currentState.status,
            chartData: currentState.chartData,
            riskManagementSettings: currentState.riskManagementSettings,
            isNowDemo: false,
          ));
        }
      } catch (e) {
        emit(StrategyError('Failed to start strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onStopStrategy(
    StopStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository
            .updateStrategyStatus(StrategyStateStatus.inactive);
        emit(currentState.copyWith(status: StrategyStateStatus.inactive));
      } catch (e) {
        emit(StrategyError('Failed to stop strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onRunBacktest(
      RunBacktestEvent event, Emitter<StrategyState> emit) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      emit(BacktestInProgress());

      try {
        final backtestResult = await _backtestingService.runBacktest(
          currentState.parameters.symbol,
          event.startDate,
          event.endDate,
          currentState.parameters,
          (progress, currentInvestmentOverTime) {
            emit(BacktestProgressUpdate(progress, currentInvestmentOverTime));
          },
        );
        emit(BacktestCompleted(backtestResult));
      } catch (e) {
        emit(BacktestError('Failed to run backtest: $e'));
      }
    } else {
      emit(const BacktestError('Strategy not loaded'));
    }
  }

  Future<void> _onStartDemoStrategy(
    StartDemoStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository
            .updateStrategyStatus(StrategyStateStatus.active);
        // Implementa la logica specifica per la modalità demo
        emit(currentState.copyWith(
            status: StrategyStateStatus.active, isDemo: true));
      } catch (e) {
        emit(StrategyError('Failed to start demo strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onStartLiveStrategy(
    StartLiveStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        final isStrategySafe = await _riskManagementService
            .isStrategySafe(currentState.parameters);
        if (isStrategySafe) {
          await _strategyRepository
              .updateStrategyStatus(StrategyStateStatus.active);
          emit(currentState.copyWith(
              status: StrategyStateStatus.active, isDemo: false));
        } else {
          emit(StrategyUnsafe(
            message:
                'Strategy is not safe to start in live mode based on current risk management settings.',
            parameters: currentState.parameters,
            status: currentState.status,
            chartData: currentState.chartData,
            riskManagementSettings: currentState.riskManagementSettings,
            isNowDemo: false,
          ));
        }
      } catch (e) {
        emit(StrategyError('Failed to start live strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onForceStartStrategy(
    ForceStartStrategy event,
    Emitter<StrategyState> emit,
  ) async {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      try {
        await _strategyRepository
            .updateStrategyStatus(StrategyStateStatus.active);
        emit(currentState.copyWith(status: StrategyStateStatus.active));
      } catch (e) {
        emit(StrategyError('Failed to force start strategy: ${e.toString()}'));
      }
    }
  }

  Future<void> _onSellEntirePortfolio(
    SellEntirePortfolio event,
    Emitter<StrategyState> emit,
  ) async {
    try {
      emit(StrategyLoading()); // Emettiamo uno stato di caricamento

      await _strategyRepository.sellEntirePortfolio(
        event.symbol,
        event.targetProfit,
        _tradingService,
      );

      // Otteniamo le statistiche aggiornate dopo la vendita
      final updatedStatistics =
          await _strategyRepository.getStrategyStatistics();

      // Emettiamo lo stato appropriato dopo la vendita
      emit(StrategyLoaded(
        parameters: (state as StrategyLoaded).parameters,
        status: StrategyStateStatus
            .inactive, // Assumiamo che la strategia sia ora inattiva
        chartData: (state as StrategyLoaded).chartData,
        riskManagementSettings:
            (state as StrategyLoaded).riskManagementSettings,
        totalInvested:
            0, // Il portafoglio è stato venduto, quindi l'investimento è 0
        currentProfit: updatedStatistics['totalProfit'] ?? 0,
        tradeCount: updatedStatistics['totalTrades'] ?? 0,
        averageBuyPrice: 0, // Non c'è più un prezzo medio di acquisto
        currentMarketPrice: await _tradingService.getCurrentPrice(event.symbol),
        recentTrades: await _strategyRepository
            .getRecentTrades(10), // Aggiorniamo le trade recenti
      ));

      // Potremmo anche voler emettere un evento di successo o mostrare una notifica
      // all'utente che la vendita è stata completata con successo
    } catch (e) {
      // Gestiamo l'errore e emettiamo lo stato appropriato
      emit(StrategyError('Failed to sell entire portfolio: ${e.toString()}'));

      // Potremmo anche voler loggare l'errore o mostrare una notifica all'utente
    }
  }

  void _onUpdateUseAutoMinTradeAmount(
    UpdateUseAutoMinTradeAmount event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        useAutoMinTradeAmount: event.useAutoMinTradeAmount,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateManualMinTradeAmount(
    UpdateManualMinTradeAmount event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        manualMinTradeAmount: event.manualMinTradeAmount,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateIsVariableInvestmentAmount(
    UpdateIsVariableInvestmentAmount event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        isVariableInvestmentAmount: event.isVariableInvestmentAmount,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateVariableInvestmentPercentage(
    UpdateVariableInvestmentPercentage event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        variableInvestmentPercentage: event.variableInvestmentPercentage,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  void _onUpdateReinvestProfits(
    UpdateReinvestProfits event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      final updatedParameters = currentState.parameters.copyWith(
        reinvestProfits: event.reinvestProfits,
      );
      emit(currentState.copyWith(parameters: updatedParameters));
    }
  }

  Future<void> _onStartMonitoring(
    StartMonitoring event,
    Emitter<StrategyState> emit,
  ) async {
    // Implementa la logica per iniziare il monitoraggio
  }

  Future<void> _onStopMonitoring(
    StopMonitoring event,
    Emitter<StrategyState> emit,
  ) async {
    // Implementa la logica per fermare il monitoraggio
  }

  void _onUpdateMonitoringData(
    UpdateMonitoringData event,
    Emitter<StrategyState> emit,
  ) {
    if (state is StrategyLoaded) {
      final currentState = state as StrategyLoaded;
      emit(currentState.copyWith(
        totalInvested: event.totalInvested ?? currentState.totalInvested,
        currentProfit: event.currentProfit ?? currentState.currentProfit,
        tradeCount: event.tradeCount ?? currentState.tradeCount,
        averageBuyPrice: event.averageBuyPrice ?? currentState.averageBuyPrice,
        currentMarketPrice:
            event.currentMarketPrice ?? currentState.currentMarketPrice,
        recentTrades: event.recentTrades ?? currentState.recentTrades,
      ));
    }
  }
}

class BacktestProgressUpdate extends StrategyState {
  final double progress;
  final List<Map<String, dynamic>> currentInvestmentOverTime;

  const BacktestProgressUpdate(this.progress, this.currentInvestmentOverTime);

  @override
  List<Object?> get props => [progress, currentInvestmentOverTime];
}

```

./lib/features/strategy/blocs/strategy_state.dart:
```
import 'package:cost_averaging_trading_app/core/models/risk_management_settings.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:equatable/equatable.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';

enum StrategyStateStatus { inactive, active, paused, backtesting }

abstract class StrategyState extends Equatable {
  const StrategyState();

  @override
  List<Object?> get props => [];
}

class StrategyInitial extends StrategyState {}

class StrategyLoading extends StrategyState {}

class StrategyLoaded extends StrategyState {
  final StrategyParameters parameters;
  final StrategyStateStatus status;
  final List<Map<String, dynamic>> chartData;
  final RiskManagementSettings riskManagementSettings;
  final BacktestResult? backtestResult;
  final double totalInvested;
  final double currentProfit;
  final int tradeCount;
  final double averageBuyPrice;
  final double currentMarketPrice;
  final List<CoreTrade> recentTrades;
  final bool isDemo;

  const StrategyLoaded({
    required this.parameters,
    required this.status,
    required this.chartData,
    required this.riskManagementSettings,
    this.backtestResult,
    this.totalInvested = 0,
    this.currentProfit = 0,
    this.tradeCount = 0,
    this.averageBuyPrice = 0,
    this.currentMarketPrice = 0,
    this.recentTrades = const [],
    this.isDemo = false,
  });

  StrategyLoaded copyWith({
    StrategyParameters? parameters,
    StrategyStateStatus? status,
    List<Map<String, dynamic>>? chartData,
    RiskManagementSettings? riskManagementSettings,
    BacktestResult? backtestResult,
    double? totalInvested,
    double? currentProfit,
    int? tradeCount,
    double? averageBuyPrice,
    double? currentMarketPrice,
    List<CoreTrade>? recentTrades,
    bool? isDemo,
  }) {
    return StrategyLoaded(
      parameters: parameters ?? this.parameters,
      status: status ?? this.status,
      chartData: chartData ?? this.chartData,
      riskManagementSettings:
          riskManagementSettings ?? this.riskManagementSettings,
      backtestResult: backtestResult ?? this.backtestResult,
      totalInvested: totalInvested ?? this.totalInvested,
      currentProfit: currentProfit ?? this.currentProfit,
      tradeCount: tradeCount ?? this.tradeCount,
      averageBuyPrice: averageBuyPrice ?? this.averageBuyPrice,
      currentMarketPrice: currentMarketPrice ?? this.currentMarketPrice,
      recentTrades: recentTrades ?? this.recentTrades,
      isDemo: isDemo ?? this.isDemo,
    );
  }

  @override
  List<Object?> get props => [
        parameters,
        status,
        chartData,
        riskManagementSettings,
        backtestResult,
        totalInvested,
        currentProfit,
        tradeCount,
        averageBuyPrice,
        currentMarketPrice,
        recentTrades
      ];
}

class StrategyError extends StrategyState {
  final String message;

  const StrategyError(this.message);

  @override
  List<Object> get props => [message];
}

class StrategyUnsafe extends StrategyLoaded {
  final String message;

  final bool isNowDemo;

  const StrategyUnsafe({
    required this.message,
    required super.parameters,
    required super.status,
    required super.chartData,
    required super.riskManagementSettings,
    required this.isNowDemo,
  });

  @override
  List<Object> get props => [super.props, message, isNowDemo];
}

class BacktestInProgress extends StrategyState {}

class BacktestCompleted extends StrategyState {
  final BacktestResult result;

  const BacktestCompleted(this.result);

  @override
  List<Object?> get props => [result];
}

class BacktestError extends StrategyState {
  final String error;

  const BacktestError(this.error);

  @override
  List<Object?> get props => [error];
}

```

./lib/features/strategy/blocs/strategy_event.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:equatable/equatable.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';

abstract class StrategyEvent extends Equatable {
  const StrategyEvent();

  @override
  List<Object?> get props => [];
}

class LoadStrategyData extends StrategyEvent {}

class UpdateStrategyParameters extends StrategyEvent {
  final StrategyParameters parameters;

  const UpdateStrategyParameters(this.parameters);

  @override
  List<Object?> get props => [parameters];
}

class UpdateStrategyStatus extends StrategyEvent {
  final StrategyStateStatus status;

  const UpdateStrategyStatus(this.status);

  @override
  List<Object?> get props => [status];
}

class RunBacktestEvent extends StrategyEvent {
  final DateTime startDate;
  final DateTime endDate;

  const RunBacktestEvent(this.startDate, this.endDate);

  @override
  List<Object?> get props => [startDate, endDate];
}

class StartDemoStrategy extends StrategyEvent {}

class StartLiveStrategy extends StrategyEvent {}

class StopStrategy extends StrategyEvent {}

class ForceStartStrategy extends StrategyEvent {}

class SellEntirePortfolio extends StrategyEvent {
  final String symbol;
  final double targetProfit;

  const SellEntirePortfolio({required this.symbol, required this.targetProfit});

  @override
  List<Object?> get props => [symbol, targetProfit];
}

// Nuovi eventi
class UpdateUseAutoMinTradeAmount extends StrategyEvent {
  final bool useAutoMinTradeAmount;

  const UpdateUseAutoMinTradeAmount(this.useAutoMinTradeAmount);

  @override
  List<Object?> get props => [useAutoMinTradeAmount];
}

class UpdateManualMinTradeAmount extends StrategyEvent {
  final double manualMinTradeAmount;

  const UpdateManualMinTradeAmount(this.manualMinTradeAmount);

  @override
  List<Object?> get props => [manualMinTradeAmount];
}

class UpdateIsVariableInvestmentAmount extends StrategyEvent {
  final bool isVariableInvestmentAmount;

  const UpdateIsVariableInvestmentAmount(this.isVariableInvestmentAmount);

  @override
  List<Object?> get props => [isVariableInvestmentAmount];
}

class UpdateVariableInvestmentPercentage extends StrategyEvent {
  final double variableInvestmentPercentage;

  const UpdateVariableInvestmentPercentage(this.variableInvestmentPercentage);

  @override
  List<Object?> get props => [variableInvestmentPercentage];
}

class UpdateReinvestProfits extends StrategyEvent {
  final bool reinvestProfits;

  const UpdateReinvestProfits(this.reinvestProfits);

  @override
  List<Object?> get props => [reinvestProfits];
}

class StartMonitoring extends StrategyEvent {}

class StopMonitoring extends StrategyEvent {}

class UpdateMonitoringData extends StrategyEvent {
  final double? totalInvested;
  final double? currentProfit;
  final int? tradeCount;
  final double? averageBuyPrice;
  final double? currentMarketPrice;
  final List<CoreTrade>? recentTrades;

  const UpdateMonitoringData({
    this.totalInvested,
    this.currentProfit,
    this.tradeCount,
    this.averageBuyPrice,
    this.currentMarketPrice,
    this.recentTrades,
  });

  @override
  List<Object?> get props => [
        totalInvested,
        currentProfit,
        tradeCount,
        averageBuyPrice,
        currentMarketPrice,
        recentTrades
      ];
}

class StartStrategyEvent extends StrategyEvent {}

class StopStrategyEvent extends StrategyEvent {}

```

./lib/features/strategy/repositories/strategy_repository.dart:
```
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/core/services/trading_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_state.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class StrategyRepository {
  final DatabaseService databaseService;

  StrategyRepository({
    required this.databaseService,
  });

  Future<void> saveStrategyParameters(StrategyParameters params) async {
    try {
      await databaseService.saveStrategyParameters(params);
    } catch (e) {
      throw Exception('Failed to save strategy parameters: $e');
    }
  }

  Future<void> sellEntirePortfolio(
      String symbol, double targetProfit, TradingService tradingService) async {
    await tradingService.sellEntirePortfolio(symbol, targetProfit);
  }

  Future<StrategyParameters> getStrategyParameters() async {
    try {
      final params = await databaseService.getStrategyParameters();
      return params ??
          StrategyParameters(
            symbol: 'BTCUSDT',
            investmentAmount: 100.0,
            intervalDays: 7,
            targetProfitPercentage: 5.0,
            stopLossPercentage: 3.0,
            purchaseFrequency: 1,
            maxInvestmentSize: 1000.0,
            useAutoMinTradeAmount: true,
            manualMinTradeAmount: 10.0,
            isVariableInvestmentAmount: false,
            variableInvestmentPercentage: 10.0,
            reinvestProfits: false,
          );
    } catch (e) {
      throw Exception('Failed to get strategy parameters: $e');
    }
  }

  Future<Map<String, dynamic>> getStrategyStatistics() async {
    try {
      final trades = await databaseService.query('trades');

      int totalTrades = trades.length;
      int profitableTrades = trades
          .where((t) => (t['price'] as num) > (t['averageEntryPrice'] as num))
          .length;
      double totalProfit = trades.fold(
          0.0,
          (sum, t) =>
              sum +
              ((t['price'] as num) - (t['averageEntryPrice'] as num)) *
                  (t['amount'] as num));
      double winRate = totalTrades > 0 ? profitableTrades / totalTrades : 0;

      int variableInvestmentTrades =
          trades.where((t) => t['isVariableInvestment'] == 1).length;

      double totalReinvestedProfit = trades
          .where((t) => t['reinvestedProfit'] != null)
          .fold(0.0, (sum, t) => sum + (t['reinvestedProfit'] as num));

      return {
        'totalTrades': totalTrades,
        'profitableTrades': profitableTrades,
        'totalProfit': totalProfit,
        'winRate': winRate,
        'variableInvestmentTrades': variableInvestmentTrades,
        'totalReinvestedProfit': totalReinvestedProfit,
      };
    } catch (e) {
      throw Exception('Failed to get strategy statistics: $e');
    }
  }

  Future<List<CoreTrade>> getRecentTrades(int limit) async {
    try {
      final trades = await databaseService.query('trades',
          orderBy: 'timestamp DESC', limit: limit);

      return trades.map((t) => CoreTrade.fromJson(t)).toList();
    } catch (e) {
      throw Exception('Failed to get recent trades: $e');
    }
  }

  Future<void> saveTradeWithNewFields(CoreTrade trade,
      bool isVariableInvestment, double? reinvestedProfit) async {
    try {
      Map<String, dynamic> tradeData = trade.toJson();
      tradeData['isVariableInvestment'] = isVariableInvestment ? 1 : 0;
      tradeData['reinvestedProfit'] = reinvestedProfit;

      await databaseService.insert('trades', tradeData);
    } catch (e) {
      throw Exception('Failed to save trade with new fields: $e');
    }
  }

  Future<void> updateStrategyStatus(StrategyStateStatus status) async {
    try {
      await databaseService.update(
          'strategy_status', {'status': status.toString().split('.').last});
    } catch (e) {
      throw Exception('Failed to update strategy status: $e');
    }
  }

  Future<StrategyParameters?> getActiveStrategy() async {
    try {
      final status = await getStrategyStatus();
      if (status == StrategyStateStatus.active) {
        return await getStrategyParameters();
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  Future<StrategyStateStatus> getStrategyStatus() async {
    try {
      final result = await databaseService.query('strategy_status');
      if (result.isNotEmpty) {
        final statusString = result.first['status'] as String;
        return StrategyStateStatus.values.firstWhere(
          (e) => e.toString().split('.').last == statusString,
          orElse: () => StrategyStateStatus.inactive,
        );
      }
      return StrategyStateStatus.inactive;
    } catch (e) {
      return StrategyStateStatus.inactive;
    }
  }

  Future<List<Map<String, dynamic>>> getStrategyChartData() async {
    try {
      final trades = await databaseService.query('trades',
          orderBy: 'timestamp DESC', limit: 100);

      return trades.map((trade) {
        return {
          'date':
              DateTime.fromMillisecondsSinceEpoch(trade['timestamp'] as int),
          'value': trade['price'],
        };
      }).toList();
    } catch (e) {
      throw Exception('Failed to get strategy chart data: $e');
    }
  }
}

```

./lib/features/strategy/models/strategy_parameters.dart:
```
import 'package:equatable/equatable.dart';

class StrategyParameters extends Equatable {
  final String symbol;
  final double investmentAmount;
  final int intervalDays;
  final double targetProfitPercentage;
  final double stopLossPercentage;
  final int purchaseFrequency;
  final double maxInvestmentSize;
  // Nuovi campi aggiunti
  final bool useAutoMinTradeAmount;
  final double manualMinTradeAmount;
  final bool isVariableInvestmentAmount;
  final double variableInvestmentPercentage;
  final bool reinvestProfits;

  StrategyParameters({
    required this.symbol,
    required this.investmentAmount,
    required this.intervalDays,
    required this.targetProfitPercentage,
    required this.stopLossPercentage,
    required this.purchaseFrequency,
    required this.maxInvestmentSize,
    // Nuovi campi aggiunti al costruttore
    this.useAutoMinTradeAmount = true,
    this.manualMinTradeAmount = 0.0,
    this.isVariableInvestmentAmount = false,
    this.variableInvestmentPercentage = 0.0,
    this.reinvestProfits = false,
  }) {
    assert(investmentAmount > 0, 'Investment amount must be positive');
    assert(intervalDays > 0, 'Interval days must be positive');
    assert(targetProfitPercentage > 0 && targetProfitPercentage <= 100,
        'Target profit must be between 0 and 100');
    assert(stopLossPercentage > 0 && stopLossPercentage <= 100,
        'Stop loss must be between 0 and 100');
    assert(purchaseFrequency > 0, 'Purchase frequency must be positive');
    assert(maxInvestmentSize > 0, 'Max investment size must be positive');
    // Nuove asserzioni per i nuovi campi
    assert(manualMinTradeAmount >= 0,
        'Manual min trade amount must be non-negative');
    assert(
        variableInvestmentPercentage >= 0 &&
            variableInvestmentPercentage <= 100,
        'Variable investment percentage must be between 0 and 100');
  }

  @override
  List<Object?> get props => [
        symbol,
        investmentAmount,
        intervalDays,
        targetProfitPercentage,
        stopLossPercentage,
        purchaseFrequency,
        maxInvestmentSize,
        // Nuovi campi aggiunti alla lista props
        useAutoMinTradeAmount,
        manualMinTradeAmount,
        isVariableInvestmentAmount,
        variableInvestmentPercentage,
        reinvestProfits,
      ];

  StrategyParameters copyWith({
    String? symbol,
    double? investmentAmount,
    int? intervalDays,
    double? targetProfitPercentage,
    double? stopLossPercentage,
    int? purchaseFrequency,
    double? maxInvestmentSize,
    // Nuovi campi aggiunti al metodo copyWith
    bool? useAutoMinTradeAmount,
    double? manualMinTradeAmount,
    bool? isVariableInvestmentAmount,
    double? variableInvestmentPercentage,
    bool? reinvestProfits,
  }) {
    return StrategyParameters(
      symbol: symbol ?? this.symbol,
      investmentAmount: investmentAmount ?? this.investmentAmount,
      intervalDays: intervalDays ?? this.intervalDays,
      targetProfitPercentage:
          targetProfitPercentage ?? this.targetProfitPercentage,
      stopLossPercentage: stopLossPercentage ?? this.stopLossPercentage,
      purchaseFrequency: purchaseFrequency ?? this.purchaseFrequency,
      maxInvestmentSize: maxInvestmentSize ?? this.maxInvestmentSize,
      // Nuovi campi aggiunti al metodo copyWith
      useAutoMinTradeAmount:
          useAutoMinTradeAmount ?? this.useAutoMinTradeAmount,
      manualMinTradeAmount: manualMinTradeAmount ?? this.manualMinTradeAmount,
      isVariableInvestmentAmount:
          isVariableInvestmentAmount ?? this.isVariableInvestmentAmount,
      variableInvestmentPercentage:
          variableInvestmentPercentage ?? this.variableInvestmentPercentage,
      reinvestProfits: reinvestProfits ?? this.reinvestProfits,
    );
  }

  factory StrategyParameters.fromJson(Map<String, dynamic> json) {
    return StrategyParameters(
      symbol: json['symbol'],
      investmentAmount: json['investmentAmount'],
      intervalDays: json['intervalDays'],
      targetProfitPercentage: json['targetProfitPercentage'],
      stopLossPercentage: json['stopLossPercentage'],
      purchaseFrequency: json['purchaseFrequency'],
      maxInvestmentSize: json['maxInvestmentSize'],
      // Nuovi campi aggiunti al metodo fromJson
      useAutoMinTradeAmount: json['useAutoMinTradeAmount'] ?? true,
      manualMinTradeAmount: json['manualMinTradeAmount'] ?? 0.0,
      isVariableInvestmentAmount: json['isVariableInvestmentAmount'] ?? false,
      variableInvestmentPercentage: json['variableInvestmentPercentage'] ?? 0.0,
      reinvestProfits: json['reinvestProfits'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'symbol': symbol,
      'investmentAmount': investmentAmount,
      'intervalDays': intervalDays,
      'targetProfitPercentage': targetProfitPercentage,
      'stopLossPercentage': stopLossPercentage,
      'purchaseFrequency': purchaseFrequency,
      'maxInvestmentSize': maxInvestmentSize,
      // Nuovi campi aggiunti al metodo toJson
      'useAutoMinTradeAmount': useAutoMinTradeAmount,
      'manualMinTradeAmount': manualMinTradeAmount,
      'isVariableInvestmentAmount': isVariableInvestmentAmount,
      'variableInvestmentPercentage': variableInvestmentPercentage,
      'reinvestProfits': reinvestProfits,
    };
  }
}

```

./lib/features/strategy/models/strategy_model.dart:
```
class StrategyModel {
  final double initialCapital;
  final double riskPercentage;
  final double minProfitTarget;
  final double maxLossPercentage;
  final int maxTrades;
  final bool isActive;

  StrategyModel({
    required this.initialCapital,
    required this.riskPercentage,
    required this.minProfitTarget,
    required this.maxLossPercentage,
    required this.maxTrades,
    required this.isActive,
  });

  StrategyModel copyWith({
    double? initialCapital,
    double? riskPercentage,
    double? minProfitTarget,
    double? maxLossPercentage,
    int? maxTrades,
    bool? isActive,
  }) {
    return StrategyModel(
      initialCapital: initialCapital ?? this.initialCapital,
      riskPercentage: riskPercentage ?? this.riskPercentage,
      minProfitTarget: minProfitTarget ?? this.minProfitTarget,
      maxLossPercentage: maxLossPercentage ?? this.maxLossPercentage,
      maxTrades: maxTrades ?? this.maxTrades,
      isActive: isActive ?? this.isActive,
    );
  }
}

```

./lib/features/chart/blocs/chart_event.dart:
```
import 'package:equatable/equatable.dart';
import 'package:candlesticks/candlesticks.dart';

abstract class ChartEvent extends Equatable {
  const ChartEvent();

  @override
  List<Object> get props => [];
}

class LoadChartData extends ChartEvent {}

class UpdateChartData extends ChartEvent {
  final Candle latestCandle;

  const UpdateChartData({required this.latestCandle});

  @override
  List<Object> get props => [latestCandle];
}

class ChangeInterval extends ChartEvent {
  final String interval;

  const ChangeInterval(this.interval);

  @override
  List<Object> get props => [interval];
}

class ToggleOrderMarkers extends ChartEvent {}

class UpdateTicker extends ChartEvent {
  final Map<String, dynamic> tickerData;
  const UpdateTicker(this.tickerData);

  @override
  List<Object> get props => [tickerData];
}

```

./lib/features/chart/blocs/chart_state.dart:
```
// lib/features/chart/blocs/chart_state.dart

import 'package:equatable/equatable.dart';
import 'package:candlesticks/candlesticks.dart';

abstract class ChartState extends Equatable {
  const ChartState();

  @override
  List<Object> get props => [];
}

class ChartLoading extends ChartState {}

class ChartLoaded extends ChartState {
  final List<Candle> candles;
  final String interval;
  final bool showOrderMarkers;

  const ChartLoaded({
    required this.candles,
    required this.interval,
    required this.showOrderMarkers,
  });

  @override
  List<Object> get props => [candles, interval, showOrderMarkers];
}

class ChartError extends ChartState {
  final String message;

  const ChartError({required this.message});

  @override
  List<Object> get props => [message];
}

```

./lib/features/chart/blocs/chart_bloc.dart:
```
import 'dart:async';
import 'package:candlesticks/candlesticks.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_event.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_state.dart';

class ChartBloc extends Bloc<ChartEvent, ChartState> {
  final ApiService _apiService;
  final String symbol;
  StreamSubscription<Map<String, dynamic>>? _klineSubscription;
  static const List<String> intervals = [
    '1m',
    '3m',
    '5m',
    '15m',
    '30m',
    '1h',
    '2h',
    '4h',
    '6h',
    '8h',
    '12h',
    '1d',
    '3d',
    '1w',
    '1M'
  ];

  ChartBloc({required this.symbol, required ApiService apiService})
      : _apiService = apiService,
        super(ChartLoading()) {
    on<LoadChartData>(_onLoadChartData);
    on<UpdateChartData>(_onUpdateChartData);
    on<ChangeInterval>(_onChangeInterval);
    on<ToggleOrderMarkers>(_onToggleOrderMarkers);
  }

  Future<void> _onLoadChartData(
      LoadChartData event, Emitter<ChartState> emit) async {
    try {
      emit(ChartLoading());
      final candles = await _fetchInitialCandles();
      _subscribeToKlineUpdates('1m');
      emit(ChartLoaded(
          candles: candles, interval: '1m', showOrderMarkers: true));
    } catch (e) {
      emit(ChartError(message: e.toString()));
    }
  }

  void _onUpdateChartData(UpdateChartData event, Emitter<ChartState> emit) {
    if (state is ChartLoaded) {
      final currentState = state as ChartLoaded;
      List<Candle> updatedCandles = List.from(currentState.candles);

      if (updatedCandles.isNotEmpty &&
          updatedCandles[0].date == event.latestCandle.date &&
          updatedCandles[0].open == event.latestCandle.open) {
        // Update last candle
        updatedCandles[0] = event.latestCandle;
      } else if (event.latestCandle.date.difference(updatedCandles[0].date) ==
          updatedCandles[0].date.difference(updatedCandles[1].date)) {
        // Add new candle
        updatedCandles.insert(0, event.latestCandle);
        if (updatedCandles.length > 100) {
          updatedCandles.removeLast();
        }
      }

      emit(ChartLoaded(
        candles: updatedCandles,
        interval: currentState.interval,
        showOrderMarkers: currentState.showOrderMarkers,
      ));
    }
  }

  Future<void> _onChangeInterval(
      ChangeInterval event, Emitter<ChartState> emit) async {
    try {
      emit(ChartLoading());
      final candles = await _fetchInitialCandles(interval: event.interval);
      _subscribeToKlineUpdates(event.interval);
      emit(ChartLoaded(
        candles: candles,
        interval: event.interval,
        showOrderMarkers: (state as ChartLoaded).showOrderMarkers,
      ));
    } catch (e) {
      emit(ChartError(message: e.toString()));
    }
  }

  void _onToggleOrderMarkers(
      ToggleOrderMarkers event, Emitter<ChartState> emit) {
    if (state is ChartLoaded) {
      final currentState = state as ChartLoaded;
      emit(ChartLoaded(
        candles: currentState.candles,
        interval: currentState.interval,
        showOrderMarkers: !currentState.showOrderMarkers,
      ));
    }
  }

  Future<List<Candle>> _fetchInitialCandles({String interval = '1m'}) async {
    final klines = await _apiService.getKlines(
      symbol: symbol,
      interval: interval,
      limit: 100,
    );
    return klines
        .map((kline) => Candle.fromJson(kline))
        .toList()
        .reversed
        .toList();
  }

  void _subscribeToKlineUpdates(String interval) {
    _klineSubscription?.cancel();
    _klineSubscription =
        _apiService.getKlineStream(symbol, interval).listen((event) {
      if (event['e'] == 'kline') {
        final kline = event['k'];
        final candle = Candle(
          date: DateTime.fromMillisecondsSinceEpoch(kline['t']),
          high: double.parse(kline['h']),
          low: double.parse(kline['l']),
          open: double.parse(kline['o']),
          close: double.parse(kline['c']),
          volume: double.parse(kline['v']),
        );
        add(UpdateChartData(latestCandle: candle));
      }
    });
  }

  @override
  Future<void> close() {
    _klineSubscription?.cancel();
    return super.close();
  }
}

```

./lib/features/settings/ui/widgets/backtesting_settings.dart:
```
import 'package:flutter/material.dart';

class BacktestingSettings extends StatelessWidget {
  final bool isBacktestingEnabled;
  final VoidCallback onToggleBacktesting;
  final VoidCallback onRunBacktest;

  const BacktestingSettings({
    super.key,
    required this.isBacktestingEnabled,
    required this.onToggleBacktesting,
    required this.onRunBacktest,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Backtesting', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('Enable Backtesting',
                    style: Theme.of(context).textTheme.titleMedium),
                Switch(
                  value: isBacktestingEnabled,
                  onChanged: (_) => onToggleBacktesting(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: isBacktestingEnabled ? onRunBacktest : null,
              child: const Text('Run Backtest'),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/settings/ui/widgets/api_settings.dart:
```
// lib/features/settings/ui/widgets/api_settings.dart

import 'package:flutter/material.dart';

class ApiSettings extends StatelessWidget {
  final String apiKey;
  final String secretKey;
  final Function(String) onApiKeyChanged;
  final Function(String) onSecretKeyChanged;

  const ApiSettings({
    super.key,
    required this.apiKey,
    required this.secretKey,
    required this.onApiKeyChanged,
    required this.onSecretKeyChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('API Settings', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            TextFormField(
              initialValue: apiKey,
              decoration: const InputDecoration(
                labelText: 'API Key',
                border: OutlineInputBorder(),
              ),
              onChanged: onApiKeyChanged,
            ),
            const SizedBox(height: 16),
            TextFormField(
              initialValue: secretKey,
              decoration: const InputDecoration(
                labelText: 'Secret Key',
                border: OutlineInputBorder(),
              ),
              obscureText: true,
              onChanged: onSecretKeyChanged,
            ),
          ],
        ),
      ),
    );
  }
}
```

./lib/features/settings/ui/widgets/demo_mode_toggle.dart:
```
import 'package:flutter/material.dart';

class DemoModeToggle extends StatelessWidget {
  final bool isDemoMode;
  final ValueChanged<bool> onToggle;

  const DemoModeToggle({
    super.key,
    required this.isDemoMode,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text('Demo Mode', style: Theme.of(context).textTheme.titleMedium),
            Switch(
              value: isDemoMode,
              onChanged: onToggle,
            ),
          ],
        ),
      ),
    );
  }
}
```

./lib/features/settings/ui/widgets/risk_management.dart:
```
import 'package:flutter/material.dart';

class RiskManagement extends StatelessWidget {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;
  final Function(double, int, double, double, double, int)
      onUpdateRiskManagement;

  const RiskManagement({
    super.key,
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
    required this.onUpdateRiskManagement,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Risk Management', style: Theme.of(context).textTheme.titleLarge),
        const SizedBox(height: 16),
        _buildSlider(
          context,
          'Max Loss Percentage',
          maxLossPercentage,
          0.0,
          10.0,
          (value) => onUpdateRiskManagement(
              value,
              maxConcurrentTrades,
              maxPositionSizePercentage,
              dailyExposureLimit,
              maxAllowedVolatility,
              maxRebuyCount),
        ),
        _buildSlider(
          context,
          'Max Concurrent Trades',
          maxConcurrentTrades.toDouble(),
          1,
          10,
          (value) => onUpdateRiskManagement(
              maxLossPercentage,
              value.toInt(),
              maxPositionSizePercentage,
              dailyExposureLimit,
              maxAllowedVolatility,
              maxRebuyCount),
        ),
        _buildSlider(
          context,
          'Max Position Size Percentage',
          maxPositionSizePercentage,
          1.0,
          100.0,
          (value) => onUpdateRiskManagement(
              maxLossPercentage,
              maxConcurrentTrades,
              value,
              dailyExposureLimit,
              maxAllowedVolatility,
              maxRebuyCount),
        ),
        _buildSlider(
          context,
          'Daily Exposure Limit',
          dailyExposureLimit,
          100.0,
          10000.0,
          (value) => onUpdateRiskManagement(
              maxLossPercentage,
              maxConcurrentTrades,
              maxPositionSizePercentage,
              value,
              maxAllowedVolatility,
              maxRebuyCount),
        ),
        _buildSlider(
          context,
          'Max Allowed Volatility',
          maxAllowedVolatility,
          0.0,
          1.0,
          (value) => onUpdateRiskManagement(
              maxLossPercentage,
              maxConcurrentTrades,
              maxPositionSizePercentage,
              dailyExposureLimit,
              value,
              maxRebuyCount),
        ),
        _buildSlider(
          context,
          'Max Rebuy Count',
          maxRebuyCount.toDouble(),
          1,
          10,
          (value) => onUpdateRiskManagement(
              maxLossPercentage,
              maxConcurrentTrades,
              maxPositionSizePercentage,
              dailyExposureLimit,
              maxAllowedVolatility,
              value.toInt()),
        ),
      ],
    );
  }

  Widget _buildSlider(BuildContext context, String label, double value,
      double min, double max, Function(double) onChanged) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.titleMedium),
        Slider(
          value: value,
          min: min,
          max: max,
          divisions: 100,
          label: value.toStringAsFixed(2),
          onChanged: onChanged,
        ),
      ],
    );
  }
}

```

./lib/features/settings/ui/pages/settings_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/widgets/shared_widgets.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_event.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_state.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/api_settings.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/backtesting_settings.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/demo_mode_toggle.dart';
import 'package:cost_averaging_trading_app/features/settings/ui/widgets/risk_management.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class SettingsPage extends StatelessWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<SettingsBloc, SettingsState>(
      listener: (context, state) {
        if (state is SettingsError) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.message)),
          );
        }
      },
      builder: (context, state) {
        if (state is SettingsLoading) {
          return const LoadingIndicator(message: 'Loading settings...');
        } else if (state is SettingsLoaded) {
          return _buildSettingsContent(context, state);
        } else if (state is SettingsError) {
          return ErrorMessage(message: state.message);
        }
        return const ErrorMessage(message: 'Unknown state');
      },
    );
  }

  Widget _buildSettingsContent(BuildContext context, SettingsLoaded state) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth > 600) {
          return _buildWideLayout(context, state);
        } else {
          return _buildNarrowLayout(context, state);
        }
      },
    );
  }

  Widget _buildWideLayout(BuildContext context, SettingsLoaded state) {
    return SingleChildScrollView(
        child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          ResponsiveText(
            'Settings',
            style: Theme.of(context).textTheme.headlineMedium,
          ),
          const SizedBox(height: 16),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Column(
                  children: [
                    CustomCard(
                      child: ApiSettings(
                        apiKey: state.apiKey,
                        secretKey: state.secretKey,
                        onApiKeyChanged: (newKey) {
                          context
                              .read<SettingsBloc>()
                              .add(UpdateApiKey(newKey));
                        },
                        onSecretKeyChanged: (newKey) {
                          context
                              .read<SettingsBloc>()
                              .add(UpdateSecretKey(newKey));
                        },
                      ),
                    ),
                    const SizedBox(height: 16),
                    CustomCard(
                      child: DemoModeToggle(
                        isDemoMode: state.isDemoMode,
                        onToggle: (isDemo) {
                          context.read<SettingsBloc>().add(ToggleDemoMode());
                        },
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  children: [
                    CustomCard(
                      child: BacktestingSettings(
                        isBacktestingEnabled: state.isBacktestingEnabled,
                        onToggleBacktesting: () {
                          context.read<SettingsBloc>().add(ToggleBacktesting());
                        },
                        onRunBacktest: () {
                          // Implementare la logica per eseguire il backtesting
                        },
                      ),
                    ),
                    const SizedBox(height: 16),
                    CustomCard(
                      child: RiskManagement(
                        maxLossPercentage: state.maxLossPercentage,
                        maxConcurrentTrades: state.maxConcurrentTrades,
                        maxPositionSizePercentage:
                            state.maxPositionSizePercentage,
                        dailyExposureLimit: state.dailyExposureLimit,
                        maxAllowedVolatility: state.maxAllowedVolatility,
                        maxRebuyCount: state.maxRebuyCount,
                        onUpdateRiskManagement: (
                          maxLoss,
                          maxTrades,
                          maxPositionSize,
                          dailyExposure,
                          maxVolatility,
                          rebuyCount,
                        ) {
                          context.read<SettingsBloc>().add(UpdateRiskManagement(
                                maxLoss,
                                maxTrades,
                                maxPositionSize,
                                dailyExposure,
                                maxVolatility,
                                rebuyCount,
                              ));
                        },
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    ));
  }

  Widget _buildNarrowLayout(BuildContext context, SettingsLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Settings',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: ApiSettings(
                apiKey: state.apiKey,
                secretKey: state.secretKey,
                onApiKeyChanged: (newKey) {
                  context.read<SettingsBloc>().add(UpdateApiKey(newKey));
                },
                onSecretKeyChanged: (newKey) {
                  context.read<SettingsBloc>().add(UpdateSecretKey(newKey));
                },
              ),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: DemoModeToggle(
                isDemoMode: state.isDemoMode,
                onToggle: (isDemo) {
                  context.read<SettingsBloc>().add(ToggleDemoMode());
                },
              ),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: BacktestingSettings(
                isBacktestingEnabled: state.isBacktestingEnabled,
                onToggleBacktesting: () {
                  context.read<SettingsBloc>().add(ToggleBacktesting());
                },
                onRunBacktest: () {
                  // Implementare la logica per eseguire il backtesting
                },
              ),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: RiskManagement(
                maxLossPercentage: state.maxLossPercentage,
                maxConcurrentTrades: state.maxConcurrentTrades,
                maxPositionSizePercentage: state.maxPositionSizePercentage,
                dailyExposureLimit: state.dailyExposureLimit,
                maxAllowedVolatility: state.maxAllowedVolatility,
                maxRebuyCount: state.maxRebuyCount,
                onUpdateRiskManagement: (
                  maxLoss,
                  maxTrades,
                  maxPositionSize,
                  dailyExposure,
                  maxVolatility,
                  rebuyCount,
                ) {
                  context.read<SettingsBloc>().add(UpdateRiskManagement(
                        maxLoss,
                        maxTrades,
                        maxPositionSize,
                        dailyExposure,
                        maxVolatility,
                        rebuyCount,
                      ));
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/settings/blocs/settings_event.dart:
```
// lib/features/settings/blocs/settings_event.dart

import 'package:equatable/equatable.dart';

abstract class SettingsEvent extends Equatable {
  const SettingsEvent();

  @override
  List<Object> get props => [];
}

class LoadSettings extends SettingsEvent {}

class UpdateApiKey extends SettingsEvent {
  final String apiKey;

  const UpdateApiKey(this.apiKey);

  @override
  List<Object> get props => [apiKey];
}

class UpdateSecretKey extends SettingsEvent {
  final String secretKey;

  const UpdateSecretKey(this.secretKey);

  @override
  List<Object> get props => [secretKey];
}

class ToggleDemoMode extends SettingsEvent {}

class ToggleBacktesting extends SettingsEvent {}

class UpdateRiskManagement extends SettingsEvent {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  const UpdateRiskManagement(
    this.maxLossPercentage,
    this.maxConcurrentTrades,
    this.maxPositionSizePercentage,
    this.dailyExposureLimit,
    this.maxAllowedVolatility,
    this.maxRebuyCount,
  );

  @override
  List<Object> get props => [
        maxLossPercentage,
        maxConcurrentTrades,
        maxPositionSizePercentage,
        dailyExposureLimit,
        maxAllowedVolatility,
        maxRebuyCount,
      ];
}

```

./lib/features/settings/blocs/settings_state.dart:
```
// lib/features/settings/blocs/settings_state.dart

import 'package:equatable/equatable.dart';

abstract class SettingsState extends Equatable {
  const SettingsState();

  @override
  List<Object> get props => [];
}

class SettingsInitial extends SettingsState {}

class SettingsLoading extends SettingsState {}

class SettingsLoaded extends SettingsState {
  final String apiKey;
  final String secretKey;
  final bool isDemoMode;
  final bool isBacktestingEnabled;
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  const SettingsLoaded({
    required this.apiKey,
    required this.secretKey,
    required this.isDemoMode,
    required this.isBacktestingEnabled,
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
  });

  @override
  List<Object> get props => [
        apiKey,
        secretKey,
        isDemoMode,
        isBacktestingEnabled,
        maxLossPercentage,
        maxConcurrentTrades,
        maxPositionSizePercentage,
        dailyExposureLimit,
        maxAllowedVolatility,
        maxRebuyCount,
      ];
}

class SettingsError extends SettingsState {
  final String message;

  const SettingsError(this.message);

  @override
  List<Object> get props => [message];
}

```

./lib/features/settings/blocs/settings_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_event.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_state.dart';
import 'package:cost_averaging_trading_app/features/settings/repositories/settings_repository.dart';

class SettingsBloc extends Bloc<SettingsEvent, SettingsState> {
  final SettingsRepository _repository;

  SettingsBloc(this._repository) : super(SettingsInitial()) {
    on<LoadSettings>(_onLoadSettings);
    on<UpdateApiKey>(_onUpdateApiKey);
    on<UpdateSecretKey>(_onUpdateSecretKey);
    on<ToggleDemoMode>(_onToggleDemoMode);
    on<ToggleBacktesting>(_onToggleBacktesting);
    on<UpdateRiskManagement>(_onUpdateRiskManagement);
    add(LoadSettings());
  }

  Future<void> _onLoadSettings(
    LoadSettings event,
    Emitter<SettingsState> emit,
  ) async {
    emit(SettingsLoading());
    try {
      final settings = await _repository.getSettings();
      emit(SettingsLoaded(
        apiKey: settings.apiKey,
        secretKey: settings.secretKey,
        isDemoMode: settings.isDemoMode,
        isBacktestingEnabled: settings.isBacktestingEnabled,
        maxLossPercentage: settings.maxLossPercentage,
        maxConcurrentTrades: settings.maxConcurrentTrades,
        maxPositionSizePercentage: settings.maxPositionSizePercentage,
        dailyExposureLimit: settings.dailyExposureLimit,
        maxAllowedVolatility: settings.maxAllowedVolatility,
        maxRebuyCount: settings.maxRebuyCount,
      ));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error loading settings', e, stackTrace);
      emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }

  Future<void> _onUpdateApiKey(
    UpdateApiKey event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        await _repository.updateApiKey(event.apiKey);
        emit(SettingsLoaded(
          apiKey: event.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error updating API key', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onUpdateSecretKey(
    UpdateSecretKey event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        await _repository.updateSecretKey(event.secretKey);
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: event.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error updating Secret key', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onToggleDemoMode(
    ToggleDemoMode event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        final newDemoMode = !currentState.isDemoMode;
        await _repository.updateDemoMode(newDemoMode);
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: newDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError('Error toggle demoMode settings', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onToggleBacktesting(
    ToggleBacktesting event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        final newBacktestingMode = !currentState.isBacktestingEnabled;
        await _repository.updateBacktestingMode(newBacktestingMode);
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: newBacktestingMode,
          maxLossPercentage: currentState.maxLossPercentage,
          maxConcurrentTrades: currentState.maxConcurrentTrades,
          maxPositionSizePercentage: currentState.maxPositionSizePercentage,
          dailyExposureLimit: currentState.dailyExposureLimit,
          maxAllowedVolatility: currentState.maxAllowedVolatility,
          maxRebuyCount: currentState.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError(
            'Error toggle backtesting settings', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }

  Future<void> _onUpdateRiskManagement(
    UpdateRiskManagement event,
    Emitter<SettingsState> emit,
  ) async {
    if (state is SettingsLoaded) {
      final currentState = state as SettingsLoaded;
      try {
        await _repository.updateRiskManagement(
          maxLossPercentage: event.maxLossPercentage,
          maxConcurrentTrades: event.maxConcurrentTrades,
          maxPositionSizePercentage: event.maxPositionSizePercentage,
          dailyExposureLimit: event.dailyExposureLimit,
          maxAllowedVolatility: event.maxAllowedVolatility,
          maxRebuyCount: event.maxRebuyCount,
        );
        emit(SettingsLoaded(
          apiKey: currentState.apiKey,
          secretKey: currentState.secretKey,
          isDemoMode: currentState.isDemoMode,
          isBacktestingEnabled: currentState.isBacktestingEnabled,
          maxLossPercentage: event.maxLossPercentage,
          maxConcurrentTrades: event.maxConcurrentTrades,
          maxPositionSizePercentage: event.maxPositionSizePercentage,
          dailyExposureLimit: event.dailyExposureLimit,
          maxAllowedVolatility: event.maxAllowedVolatility,
          maxRebuyCount: event.maxRebuyCount,
        ));
      } catch (e, stackTrace) {
        ErrorHandler.logError(
            'Error updating risk management settings', e, stackTrace);
        emit(SettingsError(ErrorHandler.getUserFriendlyErrorMessage(e)));
      }
    }
  }
}

```

./lib/features/settings/repositories/settings_repository.dart:
```
// lib/features/settings/repositories/settings_repository.dart

import 'package:cost_averaging_trading_app/core/services/secure_storage_service.dart';
import 'package:cost_averaging_trading_app/features/settings/models/settings_model.dart';

class SettingsRepository {
  final SecureStorageService _secureStorage;

  SettingsRepository(this._secureStorage);

   Future<SettingsModel> getSettings() async {
    final apiKey = await _secureStorage.getApiKey() ?? '';
    final secretKey = await _secureStorage.getSecretKey() ?? '';
    final isDemoMode = await _secureStorage.getValue('isDemoMode') == 'true';
    final isBacktestingEnabled = await _secureStorage.getValue('isBacktestingEnabled') == 'true';
    final maxLossPercentage = double.parse(await _secureStorage.getValue('maxLossPercentage') ?? '2.0');
    final maxConcurrentTrades = int.parse(await _secureStorage.getValue('maxConcurrentTrades') ?? '3');
    final maxPositionSizePercentage = double.parse(await _secureStorage.getValue('maxPositionSizePercentage') ?? '5.0');
    final dailyExposureLimit = double.parse(await _secureStorage.getValue('dailyExposureLimit') ?? '1000.0');
    final maxAllowedVolatility = double.parse(await _secureStorage.getValue('maxAllowedVolatility') ?? '0.05');
    final maxRebuyCount = int.parse(await _secureStorage.getValue('maxRebuyCount') ?? '3');
    final maxVariableInvestmentPercentage = double.parse(await _secureStorage.getValue('maxVariableInvestmentPercentage') ?? '20.0');

    return SettingsModel(
      apiKey: apiKey,
      secretKey: secretKey,
      isDemoMode: isDemoMode,
      isBacktestingEnabled: isBacktestingEnabled,
      maxLossPercentage: maxLossPercentage,
      maxConcurrentTrades: maxConcurrentTrades,
      maxPositionSizePercentage: maxPositionSizePercentage,
      dailyExposureLimit: dailyExposureLimit,
      maxAllowedVolatility: maxAllowedVolatility,
      maxRebuyCount: maxRebuyCount,
      maxVariableInvestmentPercentage: maxVariableInvestmentPercentage,
    );
  }

  Future<void> updateSettings(SettingsModel settings) async {
    await _secureStorage.saveApiKey(settings.apiKey);
    await _secureStorage.saveSecretKey(settings.secretKey);
    await _secureStorage.saveValue('isDemoMode', settings.isDemoMode.toString());
    await _secureStorage.saveValue('isBacktestingEnabled', settings.isBacktestingEnabled.toString());
    await _secureStorage.saveValue('maxLossPercentage', settings.maxLossPercentage.toString());
    await _secureStorage.saveValue('maxConcurrentTrades', settings.maxConcurrentTrades.toString());
    await _secureStorage.saveValue('maxPositionSizePercentage', settings.maxPositionSizePercentage.toString());
    await _secureStorage.saveValue('dailyExposureLimit', settings.dailyExposureLimit.toString());
    await _secureStorage.saveValue('maxAllowedVolatility', settings.maxAllowedVolatility.toString());
    await _secureStorage.saveValue('maxRebuyCount', settings.maxRebuyCount.toString());
    await _secureStorage.saveValue('maxVariableInvestmentPercentage', settings.maxVariableInvestmentPercentage.toString());
  }

  Future<void> updateApiKey(String apiKey) async {
    await _secureStorage.saveApiKey(apiKey);
  }

  Future<void> updateSecretKey(String secretKey) async {
    await _secureStorage.saveSecretKey(secretKey);
  }

  Future<void> updateDemoMode(bool isDemoMode) async {
    await _secureStorage.saveValue('isDemoMode', isDemoMode.toString());
  }

  Future<void> updateBacktestingMode(bool isBacktestingEnabled) async {
    await _secureStorage.saveValue(
        'isBacktestingEnabled', isBacktestingEnabled.toString());
  }

  Future<void> updateRiskManagement({
    required double maxLossPercentage,
    required int maxConcurrentTrades,
    required double maxPositionSizePercentage,
    required double dailyExposureLimit,
    required double maxAllowedVolatility,
    required int maxRebuyCount,
  }) async {
    await _secureStorage.saveValue(
        'maxLossPercentage', maxLossPercentage.toString());
    await _secureStorage.saveValue(
        'maxConcurrentTrades', maxConcurrentTrades.toString());
    await _secureStorage.saveValue(
        'maxPositionSizePercentage', maxPositionSizePercentage.toString());
    await _secureStorage.saveValue(
        'dailyExposureLimit', dailyExposureLimit.toString());
    await _secureStorage.saveValue(
        'maxAllowedVolatility', maxAllowedVolatility.toString());
    await _secureStorage.saveValue('maxRebuyCount', maxRebuyCount.toString());
  }
}



```

./lib/features/settings/models/settings_model.dart:
```
import 'package:equatable/equatable.dart';

class SettingsModel extends Equatable {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;
  final double maxVariableInvestmentPercentage;
  final bool isDemoMode;
  final bool isBacktestingEnabled;
  final String apiKey;
  final String secretKey;

  const SettingsModel({
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
    required this.maxVariableInvestmentPercentage,
    required this.isDemoMode,
    required this.isBacktestingEnabled,
    required this.apiKey,
    required this.secretKey,
  });

  factory SettingsModel.defaultSettings() {
    return const SettingsModel(
      maxLossPercentage: 2.0,
      maxConcurrentTrades: 3,
      maxPositionSizePercentage: 5.0,
      dailyExposureLimit: 1000.0,
      maxAllowedVolatility: 0.05,
      maxRebuyCount: 3,
      maxVariableInvestmentPercentage: 20.0,
      isDemoMode: true,
      isBacktestingEnabled: false,
      apiKey: '',
      secretKey: '',
    );
  }

  SettingsModel copyWith({
    double? maxLossPercentage,
    int? maxConcurrentTrades,
    double? maxPositionSizePercentage,
    double? dailyExposureLimit,
    double? maxAllowedVolatility,
    int? maxRebuyCount,
    double? maxVariableInvestmentPercentage,
    bool? isDemoMode,
    bool? isBacktestingEnabled,
    String? apiKey,
    String? secretKey,
  }) {
    return SettingsModel(
      maxLossPercentage: maxLossPercentage ?? this.maxLossPercentage,
      maxConcurrentTrades: maxConcurrentTrades ?? this.maxConcurrentTrades,
      maxPositionSizePercentage:
          maxPositionSizePercentage ?? this.maxPositionSizePercentage,
      dailyExposureLimit: dailyExposureLimit ?? this.dailyExposureLimit,
      maxAllowedVolatility: maxAllowedVolatility ?? this.maxAllowedVolatility,
      maxRebuyCount: maxRebuyCount ?? this.maxRebuyCount,
      maxVariableInvestmentPercentage: maxVariableInvestmentPercentage ??
          this.maxVariableInvestmentPercentage,
      isDemoMode: isDemoMode ?? this.isDemoMode,
      isBacktestingEnabled: isBacktestingEnabled ?? this.isBacktestingEnabled,
      apiKey: apiKey ?? this.apiKey,
      secretKey: secretKey ?? this.secretKey,
    );
  }

  factory SettingsModel.fromJson(Map<String, dynamic> json) {
    return SettingsModel(
      maxLossPercentage: json['maxLossPercentage'],
      maxConcurrentTrades: json['maxConcurrentTrades'],
      maxPositionSizePercentage: json['maxPositionSizePercentage'],
      dailyExposureLimit: json['dailyExposureLimit'],
      maxAllowedVolatility: json['maxAllowedVolatility'],
      maxRebuyCount: json['maxRebuyCount'],
      maxVariableInvestmentPercentage: json['maxVariableInvestmentPercentage'],
      isDemoMode: json['isDemoMode'],
      isBacktestingEnabled: json['isBacktestingEnabled'],
      apiKey: json['apiKey'],
      secretKey: json['secretKey'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'maxLossPercentage': maxLossPercentage,
      'maxConcurrentTrades': maxConcurrentTrades,
      'maxPositionSizePercentage': maxPositionSizePercentage,
      'dailyExposureLimit': dailyExposureLimit,
      'maxAllowedVolatility': maxAllowedVolatility,
      'maxRebuyCount': maxRebuyCount,
      'maxVariableInvestmentPercentage': maxVariableInvestmentPercentage,
      'isDemoMode': isDemoMode,
      'isBacktestingEnabled': isBacktestingEnabled,
      'apiKey': apiKey,
      'secretKey': secretKey,
    };
  }

  @override
  List<Object?> get props => [
        maxLossPercentage,
        maxConcurrentTrades,
        maxPositionSizePercentage,
        dailyExposureLimit,
        maxAllowedVolatility,
        maxRebuyCount,
        maxVariableInvestmentPercentage,
        isDemoMode,
        isBacktestingEnabled,
        apiKey,
        secretKey,
      ];
}

```

./lib/features/dashboard/ui/widgets/portfolio_overview.dart:
```
// lib/features/dashboard/ui/widgets/portfolio_overview.dart

import 'package:flutter/material.dart';
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';

class PortfolioOverview extends StatelessWidget {
  final Portfolio portfolio;

  const PortfolioOverview({super.key, required this.portfolio});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Portfolio Overview',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            Text('Total Value: \$${portfolio.totalValue.toStringAsFixed(2)}'),
            const SizedBox(height: 8),
            ...portfolio.assets.entries
                .map((entry) =>
                    Text('${entry.key}: ${entry.value.toStringAsFixed(8)}'))
                ,
          ],
        ),
      ),
    );
  }
}

```

./lib/features/dashboard/ui/widgets/recent_trades_widget.dart:
```
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class RecentTradesWidget extends StatelessWidget {
  final List<CoreTrade> trades;
  final int currentPage;
  final int tradesPerPage;
  final Function(int) onPageChanged;
  final Function(int) onChangeTradesPerPage;

  const RecentTradesWidget({
    super.key,
    required this.trades,
    required this.currentPage,
    required this.tradesPerPage,
    required this.onPageChanged,
    required this.onChangeTradesPerPage,
  });

  @override
  Widget build(BuildContext context) {
    final displayedTrades = trades
        .skip((currentPage - 1) * tradesPerPage)
        .take(tradesPerPage)
        .toList();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Recent Trades',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: displayedTrades.length,
              itemBuilder: (context, index) {
                final trade = displayedTrades[index];
                return _buildTradeItem(trade);
              },
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.chevron_left),
                      onPressed: currentPage > 1
                          ? () => onPageChanged(currentPage - 1)
                          : null,
                    ),
                    Text('$currentPage'),
                    IconButton(
                      icon: const Icon(Icons.chevron_right),
                      onPressed: currentPage * tradesPerPage < trades.length
                          ? () => onPageChanged(currentPage + 1)
                          : null,
                    ),
                  ],
                ),
                DropdownButton<int>(
                  value: tradesPerPage,
                  items: [5, 10, 20].map((int value) {
                    return DropdownMenuItem<int>(
                      value: value,
                      child: Text('$value'),
                    );
                  }).toList(),
                  onChanged: (int? newValue) {
                    if (newValue != null) {
                      onChangeTradesPerPage(newValue);
                    }
                  },
                  isDense: true,
                  underline: Container(),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTradeItem(CoreTrade trade) {
    return ListTile(
      title: Text(
        '${trade.type.name.toUpperCase()} ${trade.symbol}',
        style: TextStyle(
          fontWeight: FontWeight.bold,
          color: trade.type == CoreTradeType.buy ? Colors.green : Colors.red,
        ),
      ),
      subtitle: Text(
        'Amount: ${trade.amount.toStringAsFixed(8)} | Price: \$${trade.price.toStringAsFixed(2)}',
      ),
      trailing: Text(DateFormat('yyyy-MM-dd HH:mm').format(trade.timestamp)),
    );
  }
}

```

./lib/features/dashboard/ui/widgets/performance_chart.dart:
```
// lib/features/dashboard/ui/widgets/performance_chart.dart

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class PerformanceChart extends StatelessWidget {
  final List<Map<String, dynamic>> performanceData;

  const PerformanceChart({super.key, required this.performanceData});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Performance Chart',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 200,
              child: LineChart(
                LineChartData(
                  gridData: const FlGridData(show: false),
                  titlesData: const FlTitlesData(show: false),
                  borderData: FlBorderData(show: false),
                  lineBarsData: [
                    LineChartBarData(
                      spots: performanceData.asMap().entries.map((entry) {
                        // Converti esplicitamente sia la chiave che il valore in double
                        return FlSpot(
                          entry.key.toDouble(),
                          (entry.value['value'] is int)
                              ? (entry.value['value'] as int).toDouble()
                              : entry.value['value'] as double,
                        );
                      }).toList(),
                      isCurved: true,
                      color: Theme.of(context).primaryColor,
                      dotData: const FlDotData(show: false),
                      belowBarData: BarAreaData(
                        show: true,
                        color: Theme.of(context).primaryColor.withOpacity(0.3),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/dashboard/ui/pages/dashboard_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/widgets/shared_widgets.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_bloc.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_state.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_event.dart';
import 'package:cost_averaging_trading_app/features/dashboard/ui/widgets/portfolio_overview.dart';
import 'package:cost_averaging_trading_app/features/dashboard/ui/widgets/performance_chart.dart';
import 'package:cost_averaging_trading_app/features/dashboard/ui/widgets/recent_trades_widget.dart';
import 'package:cost_averaging_trading_app/core/widgets/custom_candlestick_chart.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class DashboardPage extends StatelessWidget {
  const DashboardPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<DashboardBloc, DashboardState>(
      builder: (context, state) {
        if (state is DashboardInitial) {
          context.read<DashboardBloc>().add(LoadDashboardData());
          return const LoadingIndicator(message: 'Loading dashboard...');
        } else if (state is DashboardLoading) {
          return const LoadingIndicator(message: 'Updating dashboard...');
        } else if (state is DashboardLoaded) {
          return _buildLoadedContent(context, state);
        } else if (state is DashboardError) {
          return ErrorMessage(message: state.message);
        }
        return const ErrorMessage(message: 'Unknown state');
      },
    );
  }

  Widget _buildLoadedContent(BuildContext context, DashboardLoaded state) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth > 600) {
          return _buildWideLayout(context, state);
        } else {
          return _buildNarrowLayout(context, state);
        }
      },
    );
  }

  Widget _buildWideLayout(BuildContext context, DashboardLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Dashboard',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 16),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  flex: 2,
                  child: Column(
                    children: [
                      CustomCard(
                        child: PortfolioOverview(portfolio: state.portfolio),
                      ),
                      const SizedBox(height: 16),
                      CustomCard(
                        child: RecentTradesWidget(
                          trades: state.recentTrades,
                          currentPage: state.currentPage,
                          tradesPerPage: state.tradesPerPage,
                          onPageChanged: (newPage) {
                            context
                                .read<DashboardBloc>()
                                .add(ChangePage(newPage));
                          },
                          onChangeTradesPerPage: (newValue) {
                            context
                                .read<DashboardBloc>()
                                .add(ChangeTradesPerPage(newValue));
                          },
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  flex: 3,
                  child: Column(
                    children: [
                      CustomCard(
                        child: SizedBox(
                          height: 400,
                          child: CustomCandlestickChart(
                            symbol: state.activeStrategy?.symbol ?? 'BTCUSDT',
                            trades: state.recentTrades,
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      CustomCard(
                        child: PerformanceChart(
                            performanceData: state.performanceData),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNarrowLayout(BuildContext context, DashboardLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Dashboard',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: SizedBox(
                height: 400,
                child: CustomCandlestickChart(
                  symbol: state.activeStrategy?.symbol ?? 'BTCUSDT',
                  trades: state.recentTrades,
                ),
              ),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: PortfolioOverview(portfolio: state.portfolio),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: PerformanceChart(performanceData: state.performanceData),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: RecentTradesWidget(
                trades: state.recentTrades,
                currentPage: state.currentPage,
                tradesPerPage: state.tradesPerPage,
                onPageChanged: (newPage) {
                  context.read<DashboardBloc>().add(ChangePage(newPage));
                },
                onChangeTradesPerPage: (newValue) {
                  context
                      .read<DashboardBloc>()
                      .add(ChangeTradesPerPage(newValue));
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/dashboard/blocs/dashboard_event.dart:
```
abstract class DashboardEvent {}

class LoadDashboardData extends DashboardEvent {}

class ChangePage extends DashboardEvent {
  final int newPage;

  ChangePage(this.newPage);
}

class ChangeTradesPerPage extends DashboardEvent {
  final int tradesPerPage;

  ChangeTradesPerPage(this.tradesPerPage);
}

```

./lib/features/dashboard/blocs/dashboard_state.dart:
```
import 'package:equatable/equatable.dart';
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

abstract class DashboardState extends Equatable {
  const DashboardState();

  @override
  List<Object?> get props => [];
}

class DashboardInitial extends DashboardState {}

class DashboardLoading extends DashboardState {}

class DashboardLoaded extends DashboardState {
  final Portfolio portfolio;
  final List<CoreTrade> recentTrades;
  final List<Map<String, dynamic>> performanceData;
  final int currentPage;
  final int tradesPerPage;
  final StrategyParameters? activeStrategy; // Aggiunto questo campo

  const DashboardLoaded({
    required this.portfolio,
    required this.recentTrades,
    required this.performanceData,
    required this.currentPage,
    required this.tradesPerPage,
    this.activeStrategy, // Aggiunto questo parametro
  });

  DashboardLoaded copyWith({
    Portfolio? portfolio,
    List<CoreTrade>? recentTrades,
    List<Map<String, dynamic>>? performanceData,
    int? currentPage,
    int? tradesPerPage,
    StrategyParameters? activeStrategy, // Aggiunto questo parametro
  }) {
    return DashboardLoaded(
      portfolio: portfolio ?? this.portfolio,
      recentTrades: recentTrades ?? this.recentTrades,
      performanceData: performanceData ?? this.performanceData,
      currentPage: currentPage ?? this.currentPage,
      tradesPerPage: tradesPerPage ?? this.tradesPerPage,
      activeStrategy:
          activeStrategy ?? this.activeStrategy, // Aggiunto questo campo
    );
  }

  @override
  List<Object?> get props => [
        portfolio,
        recentTrades,
        performanceData,
        currentPage,
        tradesPerPage,
        activeStrategy
      ];
}

class DashboardError extends DashboardState {
  final String message;

  const DashboardError(this.message);

  @override
  List<Object> get props => [message];
}

```

./lib/features/dashboard/blocs/dashboard_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_event.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_state.dart';
import 'package:cost_averaging_trading_app/features/dashboard/repositories/dashboard_repository.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';

class DashboardBloc extends Bloc<DashboardEvent, DashboardState> {
  final DashboardRepository _repository;
  final StrategyRepository _strategyRepository;

  DashboardBloc(this._repository, this._strategyRepository) : super(DashboardInitial()) {
    on<LoadDashboardData>(_onLoadDashboardData);
    on<ChangePage>(_onChangePage);
    on<ChangeTradesPerPage>(_onChangeTradesPerPage);
  }

  Future<void> _onLoadDashboardData(
    LoadDashboardData event,
    Emitter<DashboardState> emit,
  ) async {
    emit(DashboardLoading());
    try {
      final portfolio = await _repository.getPortfolio();
      final recentTrades = await _repository.getRecentTrades();
      final performanceData = await _repository.getPerformanceData();
      final activeStrategy = await _strategyRepository.getActiveStrategy();

      emit(DashboardLoaded(
        portfolio: portfolio,
        recentTrades: recentTrades,
        performanceData: performanceData,
        currentPage: 1,
        tradesPerPage: 10,
        activeStrategy: activeStrategy, // Aggiungi questa riga
      ));
    } catch (e) {
      emit(DashboardError(e.toString()));
    }
  }

  void _onChangePage(
    ChangePage event,
    Emitter<DashboardState> emit,
  ) {
    if (state is DashboardLoaded) {
      final currentState = state as DashboardLoaded;
      emit(currentState.copyWith(currentPage: event.newPage));
    }
  }

  void _onChangeTradesPerPage(
    ChangeTradesPerPage event,
    Emitter<DashboardState> emit,
  ) {
    if (state is DashboardLoaded) {
      final currentState = state as DashboardLoaded;
      emit(currentState.copyWith(
        tradesPerPage: event.tradesPerPage,
        currentPage: 1, // Reset to first page when changing trades per page
      ));
    }
  }
}

```

./lib/features/dashboard/repositories/dashboard_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';

class DashboardRepository {
  final ApiService apiService;
  final DatabaseService databaseService;

  DashboardRepository(
      {required this.apiService, required this.databaseService});

  Future<Portfolio> getPortfolio() async {
    try {
      final accountInfo = await apiService.getAccountInfo();
      final balances = accountInfo['balances'] as List;
      final assets = Map<String, double>.fromEntries(
        balances.where((b) => double.parse(b['free']) > 0).map(
              (b) => MapEntry(b['asset'], double.parse(b['free'])),
            ),
      );

      double totalValue = 0;
      for (var entry in assets.entries) {
        if (entry.key != 'USDT') {
          try {
            final price = await apiService.getCurrentPrice('${entry.key}USDT');
            if (price > 0) {
              totalValue += entry.value * price;
            }
          } catch (e) {
            throw Exception('No local portfolio data available');
          }
        } else {
          totalValue += entry.value;
        }
      }

      return Portfolio(
        id: accountInfo['accountType'],
        assets: assets,
        totalValue: totalValue,
      );
    } catch (e) {
      return _getLocalPortfolio();
    }
  }

  Future<Portfolio> _getLocalPortfolio() async {
    final localData = await databaseService.query('portfolio');
    if (localData.isNotEmpty) {
      return Portfolio.fromJson(localData.first);
    }
    return const Portfolio(
        id: 'local', assets: {}, totalValue: 0); // Return an empty portfolio
  }

  Future<List<CoreTrade>> getRecentTrades() async {
    try {
      final trades =
          await apiService.getMyTrades(symbol: 'BTCUSDT', limit: 100);
      return trades.map((trade) => CoreTrade.fromJson(trade)).toList();
    } catch (e) {
      return _getLocalTrades();
    }
  }

  Future<List<CoreTrade>> _getLocalTrades() async {
    final localData = await databaseService.query('trades');
    return localData.map((trade) => CoreTrade.fromJson(trade)).toList();
  }

  Future<List<Map<String, dynamic>>> getPerformanceData() async {
    try {
      final klines = await apiService.getKlines(
        symbol: 'BTCUSDT',
        interval: '1d',
        limit: 30,
      );
      return klines
          .map((kline) => {
                'date': DateTime.fromMillisecondsSinceEpoch(kline[0]),
                'value': double.parse(kline[4]), // Closing price
              })
          .toList();
    } catch (e) {
      // Fallback to example data if API call fails
      return [
        {
          'date': DateTime.now().subtract(const Duration(days: 30)),
          'value': 30000
        },
        {
          'date': DateTime.now().subtract(const Duration(days: 20)),
          'value': 32000
        },
        {
          'date': DateTime.now().subtract(const Duration(days: 10)),
          'value': 31000
        },
        {'date': DateTime.now(), 'value': 33000},
      ];
    }
  }
}

```

./lib/features/dashboard/models/dashboard_model.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

class DashboardModel {
  final String portfolioValue;
  final String activeTrades;
  final String totalProfit;
  final String totalLoss;
  final List<CoreTrade> recentTrades;
  final List<PortfolioItem> portfolioItems;
  final List<Notification> notifications;

  DashboardModel({
    required this.portfolioValue,
    required this.activeTrades,
    required this.totalProfit,
    required this.totalLoss,
    required this.recentTrades,
    required this.portfolioItems,
    required this.notifications,
  });

  factory DashboardModel.fromJson(Map<String, dynamic> json) {
    return DashboardModel(
      portfolioValue: json['portfolioValue'],
      activeTrades: json['activeTrades'],
      totalProfit: json['totalProfit'],
      totalLoss: json['totalLoss'],
      recentTrades: (json['recentTrades'] as List)
          .map((i) => CoreTrade.fromJson(i))
          .toList(),
      portfolioItems: (json['portfolioItems'] as List)
          .map((i) => PortfolioItem.fromJson(i))
          .toList(),
      notifications: (json['notifications'] as List)
          .map((i) => Notification.fromJson(i))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'portfolioValue': portfolioValue,
      'activeTrades': activeTrades,
      'totalProfit': totalProfit,
      'totalLoss': totalLoss,
      'recentTrades': recentTrades.map((e) => e.toJson()).toList(),
      'portfolioItems': portfolioItems.map((e) => e.toJson()).toList(),
      'notifications': notifications.map((e) => e.toJson()).toList(),
    };
  }
}

class PortfolioItem {
  final String asset;
  final double amount;
  final double value;

  PortfolioItem({
    required this.asset,
    required this.amount,
    required this.value,
  });

  factory PortfolioItem.fromJson(Map<String, dynamic> json) {
    return PortfolioItem(
      asset: json['asset'],
      amount: json['amount'],
      value: json['value'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'asset': asset,
      'amount': amount,
      'value': value,
    };
  }
}

class Notification {
  final String id;
  final String title;
  final String message;
  final DateTime timestamp;

  Notification({
    required this.id,
    required this.title,
    required this.message,
    required this.timestamp,
  });

  factory Notification.fromJson(Map<String, dynamic> json) {
    return Notification(
      id: json['id'],
      title: json['title'],
      message: json['message'],
      timestamp: DateTime.parse(json['timestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'message': message,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}
```

./lib/features/portfolio/ui/widgets/asset_list.dart:
```
// lib/features/portfolio/ui/widgets/asset_list.dart

import 'package:flutter/material.dart';

class AssetList extends StatelessWidget {
  final Map<String, double> assets;

  const AssetList({super.key, required this.assets});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Assets',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            ...assets.entries
                .map((entry) => _buildAssetItem(entry.key, entry.value))
                ,
          ],
        ),
      ),
    );
  }

  Widget _buildAssetItem(String asset, double amount) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(asset),
          Text(amount.toStringAsFixed(8)),
        ],
      ),
    );
  }
}

```

./lib/features/portfolio/ui/widgets/portfolio_summary.dart:
```
// lib/features/portfolio/ui/widgets/portfolio_summary.dart

import 'package:flutter/material.dart';

class PortfolioSummary extends StatelessWidget {
  final double totalValue;

  const PortfolioSummary({super.key, required this.totalValue});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Portfolio Summary',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            Text(
              'Total Value: \$${totalValue.toStringAsFixed(2)}',
              style: Theme.of(context).textTheme.titleMedium,
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/portfolio/ui/widgets/portfolio_chart.dart:
```
// lib/features/portfolio/ui/widgets/portfolio_chart.dart

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';

class PortfolioChart extends StatelessWidget {
  final List<Map<String, dynamic>> chartData;

  const PortfolioChart({super.key, required this.chartData});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Portfolio Performance',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            SizedBox(
              height: 200,
              child: LineChart(
                LineChartData(
                  gridData: const FlGridData(show: false),
                  titlesData: const FlTitlesData(show: false),
                  borderData: FlBorderData(show: false),
                  lineBarsData: [
                    LineChartBarData(
                      spots: chartData
                          .asMap()
                          .entries
                          .map((entry) => FlSpot(
                              entry.key.toDouble(), entry.value['value']))
                          .toList(),
                      isCurved: true,
                      color: Theme.of(context).primaryColor,
                      dotData: const FlDotData(show: false),
                      belowBarData: BarAreaData(
                          show: true,
                          color:
                              Theme.of(context).primaryColor.withOpacity(0.3)),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

./lib/features/portfolio/ui/pages/portfolio_page.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/widgets/shared_widgets.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_bloc.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_event.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_state.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/widgets/asset_list.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/widgets/portfolio_summary.dart';
import 'package:cost_averaging_trading_app/features/portfolio/ui/widgets/portfolio_chart.dart';
import 'package:cost_averaging_trading_app/ui/widgets/responsive_text.dart';

class PortfolioPage extends StatelessWidget {
  const PortfolioPage({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<PortfolioBloc, PortfolioState>(
      listener: (context, state) {
        if (state is PortfolioError) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.message)),
          );
        }
      },
      builder: (context, state) {
        if (state is PortfolioInitial) {
          context.read<PortfolioBloc>().add(LoadPortfolio());
          return const LoadingIndicator(message: 'Loading portfolio...');
        } else if (state is PortfolioLoading) {
          return const LoadingIndicator(message: 'Updating portfolio...');
        } else if (state is PortfolioLoaded) {
          return _buildLoadedContent(context, state);
        } else if (state is PortfolioError) {
          return ErrorMessage(message: state.message);
        }
        return const ErrorMessage(message: 'Unknown state');
      },
    );
  }

  Widget _buildLoadedContent(BuildContext context, PortfolioLoaded state) {
    return LayoutBuilder(
      builder: (context, constraints) {
        if (constraints.maxWidth > 600) {
          return _buildWideLayout(context, state);
        } else {
          return _buildNarrowLayout(context, state);
        }
      },
    );
  }

  Widget _buildWideLayout(BuildContext context, PortfolioLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Portfolio',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 16),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  flex: 2,
                  child: Column(
                    children: [
                      CustomCard(
                        child: PortfolioSummary(
                            totalValue: state.portfolio.totalValue),
                      ),
                      const SizedBox(height: 16),
                      CustomCard(
                        child: AssetList(assets: state.portfolio.assets),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  flex: 3,
                  child: CustomCard(
                    child: PortfolioChart(chartData: state.performanceData),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNarrowLayout(BuildContext context, PortfolioLoaded state) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ResponsiveText(
              'Portfolio',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: PortfolioSummary(totalValue: state.portfolio.totalValue),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: PortfolioChart(chartData: state.performanceData),
            ),
            const SizedBox(height: 16),
            CustomCard(
              child: AssetList(assets: state.portfolio.assets),
            ),
          ],
        ),
      ),
    );
  }
}
```

./lib/features/portfolio/blocs/portfolio_bloc.dart:
```
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_event.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_state.dart';
import 'package:cost_averaging_trading_app/features/portfolio/repositories/portfolio_repository.dart';

class PortfolioBloc extends Bloc<PortfolioEvent, PortfolioState> {
  final PortfolioRepository _repository;

  PortfolioBloc(this._repository) : super(PortfolioInitial()) {
    on<LoadPortfolio>(_onLoadPortfolio);
  }

  Future<void> _onLoadPortfolio(
    LoadPortfolio event,
    Emitter<PortfolioState> emit,
  ) async {
    emit(PortfolioLoading());
    try {
      final portfolio = await _repository.getPortfolio();
      final performanceData = await _repository.getPerformanceData();
      emit(PortfolioLoaded(
          portfolio: portfolio, performanceData: performanceData));
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error loading portfolio data', e, stackTrace);
      emit(PortfolioError(ErrorHandler.getUserFriendlyErrorMessage(e)));
    }
  }
}

```

./lib/features/portfolio/blocs/portfolio_state.dart:
```
// lib/features/portfolio/blocs/portfolio_state.dart

import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:equatable/equatable.dart';

abstract class PortfolioState extends Equatable {
  const PortfolioState();

  @override
  List<Object> get props => [];
}

class PortfolioInitial extends PortfolioState {}

class PortfolioLoading extends PortfolioState {}

class PortfolioLoaded extends PortfolioState {
  final Portfolio portfolio;
  final List<Map<String, dynamic>> performanceData;

  const PortfolioLoaded({
    required this.portfolio,
    required this.performanceData,
  });

  @override
  List<Object> get props => [portfolio, performanceData];
}

class PortfolioError extends PortfolioState {
  final String message;

  const PortfolioError(this.message);

  @override
  List<Object> get props => [message];
}

```

./lib/features/portfolio/blocs/portfolio_event.dart:
```
// lib/features/portfolio/blocs/portfolio_event.dart

import 'package:equatable/equatable.dart';

abstract class PortfolioEvent extends Equatable {
  const PortfolioEvent();

  @override
  List<Object> get props => [];
}

class LoadPortfolio extends PortfolioEvent {}

```

./lib/features/portfolio/repositories/portfolio_repository.dart:
```
// lib/features/portfolio/repositories/portfolio_repository.dart

import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';

class PortfolioRepository {
  final ApiService apiService;
  final DatabaseService databaseService;

  PortfolioRepository(
      {required this.apiService, required this.databaseService});

  Future<Portfolio> getPortfolio() async {
    // Implementa la logica per ottenere il portfolio
    // Usa apiService o databaseService a seconda delle necessità
    // Per ora, restituiamo dati di esempio
    return const Portfolio(
      id: '1',
      assets: {'BTC': 0.5, 'ETH': 2.0, 'USDT': 1000.0},
      totalValue: 10000.0,
    );
  }

  Future<List<Map<String, dynamic>>> getPerformanceData() async {
    // Implementa la logica per ottenere i dati di performance
    // Usa apiService o databaseService a seconda delle necessità
    // Per ora, restituiamo dati di esempio
    return [
      {
        'date': DateTime.now().subtract(const Duration(days: 30)),
        'value': 9000.0
      },
      {
        'date': DateTime.now().subtract(const Duration(days: 20)),
        'value': 9500.0
      },
      {
        'date': DateTime.now().subtract(const Duration(days: 10)),
        'value': 9800.0
      },
      {'date': DateTime.now(), 'value': 10000.0},
    ];
  }
}

```

./lib/features/portfolio/models/portfolio_model.dart:
```
class PortfolioModel {
  final Map<String, double> assets;
  final List<Transaction> transactions;

  PortfolioModel({
    required this.assets,
    required this.transactions,
  });
}

class Transaction {
  final String id;
  final String assetSymbol;
  final double amount;
  final double price;
  final DateTime timestamp;

  Transaction({
    required this.id,
    required this.assetSymbol,
    required this.amount,
    required this.price,
    required this.timestamp,
  });
}
```

./lib/core/widgets/shared_widgets.dart:
```
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;
  final double elevation;

  const CustomCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(16.0),
    this.elevation = 2.0,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: elevation,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: padding,
        child: child,
      ),
    );
  }
}

class ErrorMessage extends StatelessWidget {
  final String message;

  const ErrorMessage({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error_outline, color: Colors.red, size: 48),
            const SizedBox(height: 16),
            Text(
              'An error occurred',
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              message,
              style: Theme.of(context).textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class LoadingIndicator extends StatelessWidget {
  final String message;

  const LoadingIndicator({super.key, this.message = 'Loading...'});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            message,
            style: Theme.of(context).textTheme.bodyLarge,
          ),
        ],
      ),
    );
  }
}

```

./lib/core/widgets/custom_candlestick_chart.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:candlesticks/candlesticks.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_bloc.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_event.dart';
import 'package:cost_averaging_trading_app/features/chart/blocs/chart_state.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';

class CustomCandlestickChart extends StatefulWidget {
  final String symbol;
  final List<CoreTrade> trades;

  const CustomCandlestickChart({
    super.key,
    required this.symbol,
    required this.trades,
  });

  @override
  CustomCandlestickChartState createState() => CustomCandlestickChartState();
}

class CustomCandlestickChartState extends State<CustomCandlestickChart> {
  late ChartBloc _chartBloc;

  @override
  void initState() {
    super.initState();
    _chartBloc = ChartBloc(
      symbol: widget.symbol,
      apiService: context.read<ApiService>(),
    );
    _chartBloc.add(LoadChartData());
  }

  @override
  void dispose() {
    _chartBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: _chartBloc,
      child: BlocConsumer<ChartBloc, ChartState>(
        listener: (context, state) {
          if (state is ChartError) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(state.message)),
            );
          }
        },
        builder: (context, state) {
          if (state is ChartLoading) {
            return const Center(child: CircularProgressIndicator());
          } else if (state is ChartLoaded) {
            return _buildChart(context, state);
          } else if (state is ChartError) {
            return Center(child: Text('Error: ${state.message}'));
          }
          return const SizedBox.shrink();
        },
      ),
    );
  }

  Widget _buildChart(BuildContext context, ChartLoaded state) {
    return Stack(
      children: [
        Candlesticks(
          candles: state.candles,
          // Rimuovi onIntervalChange da qui
          actions: [
            ToolBarAction(
              onPressed: () => _chartBloc.add(ToggleOrderMarkers()),
              child: Icon(
                state.showOrderMarkers
                    ? Icons.visibility
                    : Icons.visibility_off,
              ),
            ),
            ToolBarAction(
              onPressed: () => _showIntervalPicker(context),
              child: const Text('Interval'),
            ),
          ],
        ),
        Positioned(
          top: 10,
          right: 10,
          child: _buildIntervalMenu(context),
        ),
        if (state.showOrderMarkers) ..._buildOrderMarkers(context, state),
      ],
    );
  }

  Widget _buildIntervalMenu(BuildContext context) {
    return PopupMenuButton<String>(
      icon: const Icon(Icons.more_vert),
      onSelected: (String newInterval) {
        _chartBloc.add(ChangeInterval(newInterval));
      },
      itemBuilder: (BuildContext context) {
        return ChartBloc.intervals.map((String interval) {
          return PopupMenuItem<String>(
            value: interval,
            child: Text(interval),
          );
        }).toList();
      },
    );
  }

  void _showIntervalPicker(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Select Interval'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: ChartBloc.intervals
                .map((interval) => ListTile(
                      title: Text(interval),
                      onTap: () {
                        Navigator.of(context).pop();
                        _chartBloc.add(ChangeInterval(interval));
                      },
                    ))
                .toList(),
          ),
        );
      },
    );
  }

  List<Widget> _buildOrderMarkers(BuildContext context, ChartLoaded state) {
    return widget.trades.map((trade) {
      final index = state.candles
          .indexWhere((candle) => candle.date.isAfter(trade.timestamp));
      if (index == -1) return const SizedBox.shrink();

      final x = index / state.candles.length;
      final y = (trade.price - state.candles[index].low) /
          (state.candles[index].high - state.candles[index].low);

      return Positioned(
        left: x * MediaQuery.of(context).size.width,
        top: y * MediaQuery.of(context).size.height,
        child: Icon(
          trade.type == CoreTradeType.buy
              ? Icons.arrow_upward
              : Icons.arrow_downward,
          color: trade.type == CoreTradeType.buy ? Colors.green : Colors.red,
          size: 16,
        ),
      );
    }).toList();
  }
}

```

./lib/core/dtos/portfolio_dto.dart:
```
import 'dart:convert';

class PortfolioDTO {
  final String id;
  final Map<String, double> assets;
  final double totalValue;

  PortfolioDTO({
    required this.id,
    required this.assets,
    required this.totalValue,
  });

  factory PortfolioDTO.fromJson(Map<String, dynamic> json) {
    return PortfolioDTO(
      id: json['id'],
      assets: Map<String, double>.from(json['assets']),
      totalValue: json['totalValue'].toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'assets': assets,
      'totalValue': totalValue,
    };
  }

  factory PortfolioDTO.fromDatabase(Map<String, dynamic> data) {
    return PortfolioDTO(
      id: data['id'],
      assets: Map<String, double>.from(json.decode(data['assets'])),
      totalValue: data['totalValue'],
    );
  }

  Map<String, dynamic> toDatabase() {
    return {
      'id': id,
      'assets': json.encode(assets),
      'totalValue': totalValue,
    };
  }
}

```

./lib/core/dtos/trade_dto.dart:
```
class TradeDTO {
  final String id;
  final String symbol;
  final double amount;
  final double price;
  final DateTime timestamp;
  final String type;

  TradeDTO({
    required this.id,
    required this.symbol,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  factory TradeDTO.fromJson(Map<String, dynamic> json) {
    return TradeDTO(
      id: json['id'],
      symbol: json['symbol'],
      amount: json['amount'],
      price: json['price'],
      timestamp: DateTime.parse(json['timestamp']),
      type: json['type'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'symbol': symbol,
      'amount': amount,
      'price': price,
      'timestamp': timestamp.toIso8601String(),
      'type': type,
    };
  }
}

```

./lib/core/theme/app_theme.dart:
```
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      primarySwatch: Colors.blue,
      scaffoldBackgroundColor: Colors.white,
      appBarTheme: const AppBarTheme(
        color: Colors.blue,
        elevation: 0,
        iconTheme: IconThemeData(color: Colors.white),
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      textTheme: const TextTheme(
        titleLarge: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
      ),
      buttonTheme: ButtonThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        buttonColor: Colors.blue,
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      brightness: Brightness.dark,
      primarySwatch: Colors.blue,
      scaffoldBackgroundColor: Colors.grey[900],
      appBarTheme: AppBarTheme(
        color: Colors.grey[800],
        elevation: 0,
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      cardTheme: CardTheme(
        color: Colors.grey[800],
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
      textTheme: const TextTheme(
        titleLarge: TextStyle(
            fontSize: 18, fontWeight: FontWeight.bold, color: Colors.white),
        bodyLarge: TextStyle(fontSize: 16, color: Colors.white70),
        bodyMedium: TextStyle(fontSize: 14, color: Colors.white70),
      ),
      buttonTheme: ButtonThemeData(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
        buttonColor: Colors.blue,
      ),
    );
  }
}

```

./lib/core/domain/enums/trading_enums.dart:
```
enum TradeType { buy, sell }

enum OrderType { market, limit, stopLoss, takeProfit }

enum TradingMode { demo, live }

enum TimeFrame { m1, m5, m15, m30, h1, h4, d1, w1, mn1 }

```

./lib/core/domain/entities/trade_entity.dart:
```
import 'package:equatable/equatable.dart';

enum TradeType { buy, sell }

class TradeEntity extends Equatable {
  final String id;
  final String symbol;
  final double amount;
  final double price;
  final DateTime timestamp;
  final TradeType type;

  const TradeEntity({
    required this.id,
    required this.symbol,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  @override
  List<Object?> get props => [id, symbol, amount, price, timestamp, type];
}
```

./lib/core/domain/entities/portfolio_entity.dart:
```
import 'package:equatable/equatable.dart';

class PortfolioEntity extends Equatable {
  final String id;
  final Map<String, double> assets;
  final double totalValue;

  const PortfolioEntity({
    required this.id,
    required this.assets,
    required this.totalValue,
  });

  @override
  List<Object?> get props => [id, assets, totalValue];
}
```

./lib/core/providers/app_providers.dart:
```
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/backtesting_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/core/services/risk_management_service.dart';
import 'package:cost_averaging_trading_app/core/services/secure_storage_service.dart';
import 'package:cost_averaging_trading_app/core/services/trading_service.dart';
import 'package:cost_averaging_trading_app/features/dashboard/blocs/dashboard_bloc.dart';
import 'package:cost_averaging_trading_app/features/dashboard/repositories/dashboard_repository.dart';
import 'package:cost_averaging_trading_app/features/portfolio/blocs/portfolio_bloc.dart';
import 'package:cost_averaging_trading_app/features/portfolio/repositories/portfolio_repository.dart';
import 'package:cost_averaging_trading_app/features/settings/blocs/settings_bloc.dart';
import 'package:cost_averaging_trading_app/features/settings/repositories/settings_repository.dart';
import 'package:cost_averaging_trading_app/features/strategy/blocs/strategy_bloc.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';
import 'package:cost_averaging_trading_app/features/trade_history/blocs/trade_history_bloc.dart';
import 'package:cost_averaging_trading_app/features/trade_history/repositories/trade_history_repository.dart';

class AppProviders extends StatelessWidget {
  final Widget child;

  const AppProviders({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return MultiRepositoryProvider(
      providers: [
        RepositoryProvider<ApiService>(
          create: (context) => ApiService(
            apiKey: dotenv.env['API_KEY'] ?? '',
            secretKey: dotenv.env['SECRET_KEY'] ?? '',
          ),
        ),
        RepositoryProvider<DatabaseService>(
          create: (context) => DatabaseService(),
        ),
        RepositoryProvider<SecureStorageService>(
          create: (context) => SecureStorageService(),
        ),
        RepositoryProvider<SettingsRepository>(
          create: (context) =>
              SettingsRepository(context.read<SecureStorageService>()),
        ),
        RepositoryProvider<RiskManagementService>(
          create: (context) => RiskManagementService(
            context.read<SettingsRepository>(),
            context.read<ApiService>(),
            context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<StrategyRepository>(
          create: (context) => StrategyRepository(
            databaseService: context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<TradingService>(
          create: (context) => TradingService(
            context.read<ApiService>(),
            context.read<DatabaseService>(),
            context.read<StrategyRepository>(),
          ),
        ),
        RepositoryProvider<DashboardRepository>(
          create: (context) => DashboardRepository(
            apiService: context.read<ApiService>(),
            databaseService: context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<PortfolioRepository>(
          create: (context) => PortfolioRepository(
            apiService: context.read<ApiService>(),
            databaseService: context.read<DatabaseService>(),
          ),
        ),
        RepositoryProvider<TradeHistoryRepository>(
          create: (context) => TradeHistoryRepository(),
        ),
        RepositoryProvider<BacktestingService>(
          create: (context) => BacktestingService(context.read<ApiService>()),
        ),
      ],
      child: MultiBlocProvider(
        providers: [
          BlocProvider<DashboardBloc>(
            create: (context) => DashboardBloc(
              context.read<DashboardRepository>(),
              context.read<StrategyRepository>(),
            ),
          ),
          BlocProvider<PortfolioBloc>(
            create: (context) =>
                PortfolioBloc(context.read<PortfolioRepository>()),
          ),
          BlocProvider<StrategyBloc>(
            create: (context) => StrategyBloc(
              context.read<StrategyRepository>(),
              context.read<RiskManagementService>(),
              context.read<BacktestingService>(),
              context.read<TradingService>(),
            ),
          ),
          BlocProvider<TradeHistoryBloc>(
            create: (context) =>
                TradeHistoryBloc(context.read<TradeHistoryRepository>()),
          ),
          BlocProvider<SettingsBloc>(
            create: (context) =>
                SettingsBloc(context.read<SettingsRepository>()),
          ),
        ],
        child: child,
      ),
    );
  }
}

```

./lib/core/mappers/trade_mapper.dart:
```
import 'package:cost_averaging_trading_app/core/dtos/trade_dto.dart';
import 'package:cost_averaging_trading_app/core/domain/entities/trade_entity.dart';

class TradeMapper {
  static TradeEntity fromDTO(TradeDTO dto) {
    return TradeEntity(
      id: dto.id,
      symbol: dto.symbol,
      amount: dto.amount,
      price: dto.price,
      timestamp: dto.timestamp,
      type: TradeType.values
          .firstWhere((e) => e.toString().split('.').last == dto.type),
    );
  }

  static TradeDTO toDTO(TradeEntity entity) {
    return TradeDTO(
      id: entity.id,
      symbol: entity.symbol,
      amount: entity.amount,
      price: entity.price,
      timestamp: entity.timestamp,
      type: entity.type.toString().split('.').last,
    );
  }
}

```

./lib/core/mappers/portfolio_mapper.dart:
```
import 'package:cost_averaging_trading_app/core/dtos/portfolio_dto.dart';
import 'package:cost_averaging_trading_app/core/domain/entities/portfolio_entity.dart';

class PortfolioMapper {
  static PortfolioEntity fromDTO(PortfolioDTO dto) {
    return PortfolioEntity(
      id: dto.id,
      assets: dto.assets,
      totalValue: dto.totalValue,
    );
  }

  static PortfolioDTO toDTO(PortfolioEntity entity) {
    return PortfolioDTO(
      id: entity.id,
      assets: entity.assets,
      totalValue: entity.totalValue,
    );
  }
}

```

./lib/core/animations/custom_animations.dart:
```
import 'package:flutter/material.dart';

class FadeInAnimation extends StatefulWidget {
  final Widget child;
  final Duration duration;

  const FadeInAnimation({
    super.key,
    required this.child,
    this.duration = const Duration(milliseconds: 500),
  });

  @override
  FadeInAnimationState createState() => FadeInAnimationState();
}

class FadeInAnimationState extends State<FadeInAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: widget.duration);
    _animation = Tween<double>(begin: 0.0, end: 1.0).animate(_controller);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: widget.child,
    );
  }
}

class SlideInAnimation extends StatefulWidget {
  final Widget child;
  final Duration duration;
  final Offset beginOffset;

  const SlideInAnimation({
    super.key,
    required this.child,
    this.duration = const Duration(milliseconds: 500),
    this.beginOffset = const Offset(0.0, 0.35),
  });

  @override
  SlideInAnimationState createState() => SlideInAnimationState();
}

class SlideInAnimationState extends State<SlideInAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Offset> _animation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this, duration: widget.duration);
    _animation =
        Tween<Offset>(begin: widget.beginOffset, end: Offset.zero).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeOut),
    );
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SlideTransition(
      position: _animation,
      child: widget.child,
    );
  }
}

```

./lib/core/services/risk_management_service.dart:
```
import 'dart:math';
import 'package:cost_averaging_trading_app/core/models/risk_management_settings.dart';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/core/error/error_handler.dart';
import 'package:cost_averaging_trading_app/features/settings/repositories/settings_repository.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class RiskManagementService {
  final SettingsRepository settingsRepository;
  final ApiService apiService;
  final DatabaseService databaseService;

  RiskManagementService(
      this.settingsRepository, this.apiService, this.databaseService);

  Future<bool> isCoreTradeAllowed(
      CoreTrade proposedCoreTrade, double currentPortfolioValue) async {
    try {
      final strategyParameters = await _getStrategyParameters();

      if (!await _isWithinVolatilityLimits(proposedCoreTrade)) {
        return false;
      }

      if (!await _isWithinMaxRebuyLimit(proposedCoreTrade)) {
        return false;
      }

      if (!await _isAboveStopLoss(proposedCoreTrade, currentPortfolioValue)) {
        return false;
      }

      if (!await _isWithinMaxPositionSize(
          proposedCoreTrade, currentPortfolioValue, strategyParameters)) {
        return false;
      }

      if (!await _isWithinDailyExposureLimit(proposedCoreTrade)) {
        return false;
      }

      if (!_isWithinCoolingOffPeriod(proposedCoreTrade)) {
        return false;
      }

      return true;
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in isCoreTradeAllowed', e, stackTrace);
      return false;
    }
  }

  Future<bool> isStrategySafe(StrategyParameters parameters) async {
    try {
      final settings = await settingsRepository.getSettings();

      // Check if the investment amount is within limits
      if (parameters.investmentAmount >
          settings.maxPositionSizePercentage *
              await _getCurrentPortfolioValue()) {
        return false;
      }

      // Check if the symbol's volatility is within acceptable limits
      double volatility = await _calculateVolatility(parameters.symbol);
      if (volatility > settings.maxAllowedVolatility) {
        return false;
      }

      // Check if the variable investment amount is within acceptable limits
      if (parameters.isVariableInvestmentAmount &&
          parameters.variableInvestmentPercentage >
              settings.maxVariableInvestmentPercentage) {
        return false;
      }

      return true;
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in isStrategySafe', e, stackTrace);
      return false;
    }
  }

  Future<bool> _isWithinVolatilityLimits(CoreTrade trade) async {
    try {
      double volatility = await _calculateVolatility(trade.symbol);
      final settings = await settingsRepository.getSettings();

      return volatility <= settings.maxAllowedVolatility;
    } catch (e, stackTrace) {
      ErrorHandler.logError(
          'Error in _isWithinVolatilityLimits', e, stackTrace);
      return false;
    }
  }

  Future<bool> _isWithinMaxRebuyLimit(CoreTrade trade) async {
    try {
      int rebuyCount = await _getRebuyCount(trade.symbol);
      final settings = await settingsRepository.getSettings();

      return rebuyCount < settings.maxRebuyCount;
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in _isWithinMaxRebuyLimit', e, stackTrace);
      return false;
    }
  }

  Future<bool> _isAboveStopLoss(
      CoreTrade trade, double currentPortfolioValue) async {
    final settings = await settingsRepository.getSettings();
    double potentialLoss =
        (currentPortfolioValue - (trade.amount * trade.price)) /
            currentPortfolioValue;
    return potentialLoss <= settings.maxLossPercentage;
  }

  Future<bool> _isWithinMaxPositionSize(
      CoreTrade trade,
      double currentPortfolioValue,
      StrategyParameters strategyParameters) async {
    final settings = await settingsRepository.getSettings();
    double tradeValue = trade.amount * trade.price;

    double maxPositionSize =
        currentPortfolioValue * settings.maxPositionSizePercentage;

    if (strategyParameters.isVariableInvestmentAmount) {
      double variationFactor =
          1 + (strategyParameters.variableInvestmentPercentage / 100);
      maxPositionSize *= variationFactor;
    }

    return tradeValue <= maxPositionSize;
  }

  Future<bool> _isWithinDailyExposureLimit(CoreTrade trade) async {
    try {
      double dailyExposure = await _calculateDailyExposure(trade.symbol);
      final settings = await settingsRepository.getSettings();
      return dailyExposure + (trade.amount * trade.price) <=
          settings.dailyExposureLimit;
    } catch (e, stackTrace) {
      ErrorHandler.logError(
          'Error in _isWithinDailyExposureLimit', e, stackTrace);
      return false;
    }
  }

  bool _isWithinCoolingOffPeriod(CoreTrade trade) {
    // Implement cooling off logic here
    // For example, check if there's been a recent loss and if enough time has passed
    return true; // Placeholder
  }

  Future<double> _calculateVolatility(String symbol) async {
    try {
      var klineData = await apiService.getKlines(
        symbol: symbol,
        interval: '1d',
        limit: 30,
      );

      List<double> closePrices =
          klineData.map<double>((k) => double.parse(k[4])).toList();

      List<double> logReturns = [];
      for (int i = 1; i < closePrices.length; i++) {
        logReturns.add(log(closePrices[i] / closePrices[i - 1]));
      }

      double mean = logReturns.reduce((a, b) => a + b) / logReturns.length;
      double variance =
          logReturns.map((x) => pow(x - mean, 2)).reduce((a, b) => a + b) /
              logReturns.length;
      double stdDev = sqrt(variance);

      return stdDev * sqrt(365);
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error in _calculateVolatility', e, stackTrace);
      return double.infinity;
    }
  }

  Future<int> _getRebuyCount(String symbol) async {
    try {
      var sevenDaysAgo = DateTime.now().subtract(const Duration(days: 7));
      var recentTrades = await databaseService.query(
        'trades',
        where: 'symbol = ? AND timestamp > ? AND type = ?',
        whereArgs: [symbol, sevenDaysAgo.millisecondsSinceEpoch, 'buy'],
      );
      return recentTrades.length;
    } catch (e, stackTrace) {
      final settings = await settingsRepository.getSettings();

      ErrorHandler.logError('Error in _getRebuyCount', e, stackTrace);
      return settings.maxRebuyCount;
    }
  }

  Future<double> _calculateDailyExposure(String symbol) async {
  try {
    var startOfDay = DateTime.now().subtract(Duration(
        hours: DateTime.now().hour,
        minutes: DateTime.now().minute,
        seconds: DateTime.now().second,
        milliseconds: DateTime.now().millisecond,
        microseconds: DateTime.now().microsecond));
    var todayTrades = await databaseService.query(
      'trades',
      where: 'symbol = ? AND timestamp > ?',
      whereArgs: [symbol, startOfDay.millisecondsSinceEpoch],
    );

    double totalExposure = 0.0;
    for (var trade in todayTrades) {
      double amount = (trade['amount'] as num).toDouble();
      double price = (trade['price'] as num).toDouble();
      totalExposure += amount * price;
    }

    return totalExposure;
  } catch (e, stackTrace) {
    final settings = await settingsRepository.getSettings();
    ErrorHandler.logError('Error in _calculateDailyExposure', e, stackTrace);
    return settings.dailyExposureLimit;
  }
}

  Future<double> _getCurrentPortfolioValue() async {
    try {
      // Prova prima a ottenere il valore del portfolio dall'API
      final accountInfo = await apiService.getAccountInfo();
      double totalValue = 0.0;

      for (var balance in accountInfo['balances']) {
        String asset = balance['asset'];
        double free = double.parse(balance['free']);
        double locked = double.parse(balance['locked']);
        double totalAssetAmount = free + locked;

        if (totalAssetAmount > 0) {
          if (asset != 'USDT') {
            // Se l'asset non è USDT, ottieni il prezzo corrente e calcola il valore
            String symbol = '${asset}USDT';
            double price = await apiService.getCurrentPrice(symbol);
            totalValue += totalAssetAmount * price;
          } else {
            // Se l'asset è USDT, aggiungi direttamente il valore
            totalValue += totalAssetAmount;
          }
        }
      }

      // Salva il valore del portfolio nel database locale per uso futuro
      await databaseService.insert('portfolio_value', {
        'value': totalValue,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });

      return totalValue;
    } catch (e) {
      // Se c'è un errore nell'ottenere i dati dall'API, prova a recuperare l'ultimo valore salvato dal database
      try {
        final lastValue = await databaseService.query(
          'portfolio_value',
          orderBy: 'timestamp DESC',
          limit: 1,
        );

        if (lastValue.isNotEmpty) {
          return lastValue.first['value'];
        }
      } catch (dbError, stacktrace) {
        ErrorHandler.logError(
            'Error retrieving portfolio value from database: ',
            dbError,
            stacktrace);
      }

      // Se non è possibile recuperare il valore né dall'API né dal database, lancia un'eccezione
      throw Exception('Unable to get current portfolio value');
    }
  }

  Future<StrategyParameters> _getStrategyParameters() async {
    try {
      return await databaseService.getStrategyParameters() ??
          StrategyParameters(
            symbol: 'BTCUSDT',
            investmentAmount: 100,
            intervalDays: 7,
            targetProfitPercentage: 5,
            stopLossPercentage: 3,
            purchaseFrequency: 1,
            maxInvestmentSize: 1000,
            useAutoMinTradeAmount: true,
            manualMinTradeAmount: 10,
            isVariableInvestmentAmount: false,
            variableInvestmentPercentage: 10,
            reinvestProfits: false,
          );
    } catch (e, stackTrace) {
      ErrorHandler.logError('Error getting strategy parameters', e, stackTrace);
      throw Exception('Failed to get strategy parameters');
    }
  }

  Future<double> calculateRisk(StrategyParameters parameters) async {
    // Implement a risk calculation based on the strategy parameters
    // This is a simplified example and should be expanded based on your specific risk model
    double risk = 0;

    // Consider volatility
    double volatility = await _calculateVolatility(parameters.symbol);
    risk += volatility * 10; // Adjust the multiplier as needed

    // Consider investment amount
    double portfolioValue = await _getCurrentPortfolioValue();
    double investmentPercentage = parameters.investmentAmount / portfolioValue;
    risk += investmentPercentage * 100; // Adjust the multiplier as needed

    // Consider stop loss
    risk -= parameters.stopLossPercentage; // Lower stop loss increases risk

    // Consider variable investment
    if (parameters.isVariableInvestmentAmount) {
      risk += parameters.variableInvestmentPercentage / 2;
    }

    // Normalize risk to a 0-100 scale
    risk = risk.clamp(0, 100);

    return risk;
  }

  Future<RiskManagementSettings> getRiskManagementSettings() async {
    final settings = await settingsRepository.getSettings();
    return RiskManagementSettings(
      maxLossPercentage: settings.maxLossPercentage,
      maxConcurrentTrades: settings.maxConcurrentTrades,
      maxPositionSizePercentage: settings.maxPositionSizePercentage,
      dailyExposureLimit: settings.dailyExposureLimit,
      maxAllowedVolatility: settings.maxAllowedVolatility,
      maxRebuyCount: settings.maxRebuyCount,
    );
  }
}

```

./lib/core/services/backtesting_service.dart:
```
import 'dart:math';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class BacktestingService {
  final ApiService apiService;

  BacktestingService(this.apiService);

  Future<BacktestResult> runBacktest(
    String symbol,
    DateTime startDate,
    DateTime endDate,
    StrategyParameters parameters,
    void Function(double progress,
            List<Map<String, dynamic>> currentInvestmentOverTime)
        onProgress,
  ) async {
    try {
      List<HistoricalDataPoint> historicalData =
          await _fetchHistoricalData(symbol, startDate, endDate);

      List<CoreTrade> trades = [];
      double portfolioValue = parameters.investmentAmount;
      double btcAmount = 0;
      double averageEntryPrice = 0;
      int daysSinceLastPurchase = 0;

      double highestPortfolioValue = portfolioValue;
      double lowestPortfolioValue = portfolioValue;
      List<double> dailyReturns = [];
      double previousPortfolioValue = portfolioValue;
      List<Map<String, dynamic>> investmentOverTime = [];

      for (int i = 0; i < historicalData.length; i++) {
        HistoricalDataPoint currentData = historicalData[i];
        daysSinceLastPurchase++;

        double currentPortfolioValue =
            portfolioValue + (btcAmount * currentData.close);

        if (i > 0) {
          double dailyReturn =
              (currentPortfolioValue - previousPortfolioValue) /
                  previousPortfolioValue;
          dailyReturns.add(dailyReturn);
        }
        previousPortfolioValue = currentPortfolioValue;

        highestPortfolioValue =
            max(highestPortfolioValue, currentPortfolioValue);
        lowestPortfolioValue = min(lowestPortfolioValue, currentPortfolioValue);

        investmentOverTime.add({
          'date': currentData.timestamp,
          'value': currentPortfolioValue,
        });

        if (btcAmount > 0 &&
            currentData.close <=
                averageEntryPrice * (1 - parameters.stopLossPercentage / 100)) {
          trades.add(CoreTrade(
            id: (i + 2000000).toString(),
            symbol: symbol,
            amount: btcAmount,
            price: currentData.close,
            timestamp: currentData.timestamp,
            type: CoreTradeType.sell,
          ));

          portfolioValue += btcAmount * currentData.close;
          btcAmount = 0;
          averageEntryPrice = 0;
        }

        if (daysSinceLastPurchase >= parameters.purchaseFrequency) {
          double investmentAmount = parameters.investmentAmount;
          if (parameters.isVariableInvestmentAmount) {
            double variationPercentage =
                (parameters.variableInvestmentPercentage / 100);
            double randomFactor =
                1 + (Random().nextDouble() * 2 - 1) * variationPercentage;
            investmentAmount *= randomFactor;
          }

          double buyAmount = investmentAmount / currentData.close;
          if (parameters.useAutoMinTradeAmount) {
            double minTradeAmount = 0.00001;
            buyAmount =
                buyAmount.clamp(minTradeAmount, parameters.maxInvestmentSize);
          } else {
            buyAmount = buyAmount.clamp(
                parameters.manualMinTradeAmount, parameters.maxInvestmentSize);
          }

          if (portfolioValue >= buyAmount * currentData.close) {
            btcAmount += buyAmount;
            portfolioValue -= buyAmount * currentData.close;

            averageEntryPrice = (averageEntryPrice * (btcAmount - buyAmount) +
                    currentData.close * buyAmount) /
                btcAmount;

            trades.add(CoreTrade(
              id: i.toString(),
              symbol: symbol,
              amount: buyAmount,
              price: currentData.close,
              timestamp: currentData.timestamp,
              type: CoreTradeType.buy,
            ));

            daysSinceLastPurchase = 0;
          }
        }

        if (btcAmount > 0 &&
            currentData.close >=
                averageEntryPrice *
                    (1 + parameters.targetProfitPercentage / 100)) {
          trades.add(CoreTrade(
            id: (i + 1000000).toString(),
            symbol: symbol,
            amount: btcAmount,
            price: currentData.close,
            timestamp: currentData.timestamp,
            type: CoreTradeType.sell,
          ));

          double sellValue = btcAmount * currentData.close;
          portfolioValue += sellValue;

          if (parameters.reinvestProfits) {
            double profit = sellValue - (btcAmount * averageEntryPrice);
            double reinvestAmount = profit / currentData.close;
            btcAmount = reinvestAmount;
            averageEntryPrice = currentData.close;
          } else {
            btcAmount = 0;
            averageEntryPrice = 0;
          }
        }
        if (i % 10 == 0) {
          // Emetti un aggiornamento ogni 10 giorni
          onProgress(i / historicalData.length, List.from(investmentOverTime));
        }
      }

      double finalPortfolioValue =
          portfolioValue + (btcAmount * historicalData.last.close);
      double totalProfit = finalPortfolioValue - parameters.investmentAmount;
      double totalReturn = totalProfit / parameters.investmentAmount;
      double maxDrawdown = (highestPortfolioValue - lowestPortfolioValue) /
          highestPortfolioValue;

      int profitableTrades = trades
          .where((t) =>
              t.type == CoreTradeType.sell && t.price > averageEntryPrice)
          .length;
      double winRate = profitableTrades /
          trades.where((t) => t.type == CoreTradeType.sell).length;

      double averageDailyReturn =
          dailyReturns.reduce((a, b) => a + b) / dailyReturns.length;
      double stdDailyReturn = sqrt(dailyReturns
              .map((r) => pow(r - averageDailyReturn, 2))
              .reduce((a, b) => a + b) /
          dailyReturns.length);
      double sharpeRatio = sqrt(252) * averageDailyReturn / stdDailyReturn;

      double sortinoRatio = calculateSortinoRatio(dailyReturns,
          0.02 / 252); // Assumendo un tasso risk-free del 2% annuo
      int totalTrades = trades.length;
      double averageTradeProfit = totalProfit / totalTrades;

      return BacktestResult(
        trades: trades,
        performance: BacktestPerformance(
          totalProfit: totalProfit,
          totalReturn: totalReturn,
          maxDrawdown: maxDrawdown,
          winRate: winRate,
          sharpeRatio: sharpeRatio,
          sortinoRatio: sortinoRatio,
          totalTrades: totalTrades,
          averageTradeProfit: averageTradeProfit,
        ),
        investmentOverTime: investmentOverTime,
      );
    } catch (e) {
      rethrow;
    }
  }

  Future<double> getMinimumTradeAmount(String symbol) async {
    try {
      return await apiService.getMinimumTradeAmount(symbol);
    } catch (e) {
      return 0.00001; // Valore di fallback
    }
  }

  Future<List<HistoricalDataPoint>> _fetchHistoricalData(
      String symbol, DateTime startDate, DateTime endDate) async {
    final klines = await apiService.getKlines(
      symbol: symbol,
      interval: '1d',
      startTime: startDate.millisecondsSinceEpoch,
      endTime: endDate.millisecondsSinceEpoch,
    );

    return klines
        .map((kline) => HistoricalDataPoint(
              timestamp: DateTime.fromMillisecondsSinceEpoch(kline[0]),
              open: double.parse(kline[1]),
              high: double.parse(kline[2]),
              low: double.parse(kline[3]),
              close: double.parse(kline[4]),
              volume: double.parse(kline[5]),
            ))
        .toList();
  }
}

double calculateSortinoRatio(List<double> dailyReturns, double riskFreeRate) {
  double averageReturn =
      dailyReturns.reduce((a, b) => a + b) / dailyReturns.length;
  List<double> negativeReturns = dailyReturns.where((r) => r < 0).toList();
  double downsideDeviation = sqrt(negativeReturns
          .map((r) => pow(r - riskFreeRate, 2))
          .reduce((a, b) => a + b) /
      negativeReturns.length);
  return sqrt(252) * (averageReturn - riskFreeRate) / downsideDeviation;
}

class HistoricalDataPoint {
  final DateTime timestamp;
  final double open;
  final double high;
  final double low;
  final double close;
  final double volume;

  HistoricalDataPoint({
    required this.timestamp,
    required this.open,
    required this.high,
    required this.low,
    required this.close,
    required this.volume,
  });
}

class BacktestResult {
  final List<CoreTrade> trades;
  final BacktestPerformance performance;
  final List<Map<String, dynamic>> investmentOverTime;

  BacktestResult({
    required this.trades,
    required this.performance,
    required this.investmentOverTime,
  });
}

class BacktestPerformance {
  final double totalProfit;
  final double totalReturn;
  final double maxDrawdown;
  final double winRate;
  final double sharpeRatio;
  final double sortinoRatio; // Nuovo
  final int totalTrades; // Nuovo
  final double averageTradeProfit; // Nuovo

  BacktestPerformance({
    required this.totalProfit,
    required this.totalReturn,
    required this.maxDrawdown,
    required this.winRate,
    required this.sharpeRatio,
    required this.sortinoRatio,
    required this.totalTrades,
    required this.averageTradeProfit,
  });
}

```

./lib/core/services/api_service.dart:
```
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:crypto/crypto.dart';
import 'package:web_socket_channel/web_socket_channel.dart';

class ApiService {
  final String apiKey;
  final String secretKey;
  final String baseUrl = 'https://api.binance.com';

  ApiService({required this.apiKey, required this.secretKey});

  Future<int> getServerTime() async {
    try {
      final response = await http.get(Uri.parse('$baseUrl/api/v3/time'));
      if (response.statusCode == 200) {
        final serverTime = json.decode(response.body)['serverTime'];
        return serverTime;
      } else {
        throw Exception('Failed to get server time');
      }
    } catch (e) {
      rethrow;
    }
  }

  Stream<Map<String, dynamic>> getTickerStream(String symbol) {
    final wsUrl =
        'wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@ticker';
    final channel = WebSocketChannel.connect(Uri.parse(wsUrl));
    return channel.stream.map((event) => jsonDecode(event));
  }

  Future<double> getAccountBalance(String asset) async {
    try {
      final accountInfo = await getAccountInfo();
      final balances = accountInfo['balances'] as List<dynamic>;
      final assetBalance = balances.firstWhere(
        (balance) => balance['asset'] == asset,
        orElse: () => {'free': '0'},
      );
      return double.parse(assetBalance['free']);
    } catch (e) {
      throw Exception('Failed to get account balance: $e');
    }
  }

  Future<Map<String, dynamic>> createMarketSellOrder(
      String symbol, double quantity) async {
    try {
      final response = await createOrder(
        symbol: symbol,
        side: 'SELL',
        type: 'MARKET',
        quantity: quantity.toStringAsFixed(8),
      );
      return response;
    } catch (e) {
      throw Exception('Failed to create market sell order: $e');
    }
  }

  Future<dynamic> get(String endpoint,
      {Map<String, dynamic>? queryParams, bool requiresAuth = false}) async {
    try {
      var params = queryParams ?? {};
      if (requiresAuth) {
        final serverTime = await getServerTime();
        params['timestamp'] = serverTime.toString();
        params['recvWindow'] = '60000';
        params['signature'] = _generateSignature(params);
      }

      final uri =
          Uri.parse('$baseUrl$endpoint').replace(queryParameters: params);

      final response = await http.get(
        uri,
        headers: _getHeaders(requiresAuth),
      );
      return _handleResponse(response);
    } catch (e) {
      throw Exception('GET request failed: $endpoint. Error: $e');
    }
  }

  Future<dynamic> post(String endpoint, Map<String, dynamic> body,
      {bool requiresAuth = true}) async {
    try {
      if (requiresAuth) {
        final serverTime = await getServerTime();
        body['timestamp'] = serverTime.toString();
        body['recvWindow'] = '60000';
        body['signature'] = _generateSignature(body);
      }

      final uri = Uri.parse('$baseUrl$endpoint');

      final response = await http.post(
        uri,
        headers: _getHeaders(requiresAuth),
        body: body,
      );
      return _handleResponse(response);
    } catch (e) {
      throw Exception('POST request failed: $endpoint. Error: $e');
    }
  }

  Map<String, String> _getHeaders(bool requiresAuth) {
    var headers = {'Content-Type': 'application/x-www-form-urlencoded'};
    if (requiresAuth) {
      headers['X-MBX-APIKEY'] = apiKey;
    }
    return headers;
  }

  String _generateSignature(Map<String, dynamic> params) {
    final queryString = Uri(queryParameters: params).query;
    final hmac = Hmac(sha256, utf8.encode(secretKey));
    final signature = hmac.convert(utf8.encode(queryString)).toString();
    return signature;
  }

  dynamic _handleResponse(http.Response response) {
    if (response.statusCode >= 200 && response.statusCode < 300) {
      return json.decode(response.body);
    } else {
      throw Exception(
          'HTTP error ${response.statusCode}: ${response.reasonPhrase}\nBody: ${response.body}');
    }
  }

  Future<dynamic> getAccountInfo() async {
    return await get('/api/v3/account', requiresAuth: true);
  }

  Future<dynamic> createOrder({
    required String symbol,
    required String side,
    required String type,
    required String quantity,
    String? price,
    String? stopPrice,
  }) async {
    final body = {
      'symbol': symbol,
      'side': side,
      'type': type,
      'quantity': quantity,
      if (price != null) 'price': price,
      if (stopPrice != null) 'stopPrice': stopPrice,
    };
    return await post('/api/v3/order', body);
  }

  Future<dynamic> cancelOrder({
    required String symbol,
    String? orderId,
    String? origClientOrderId,
  }) async {
    final body = {
      'symbol': symbol,
      if (orderId != null) 'orderId': orderId,
      if (origClientOrderId != null) 'origClientOrderId': origClientOrderId,
    };
    return await post('/api/v3/order', body);
  }

  Future<dynamic> getOpenOrders({String? symbol}) async {
    return await get('/api/v3/openOrders',
        queryParams: symbol != null ? {'symbol': symbol} : null,
        requiresAuth: true);
  }

  Future<dynamic> getAllOrders({required String symbol}) async {
    return await get('/api/v3/allOrders',
        queryParams: {'symbol': symbol}, requiresAuth: true);
  }

  Future<dynamic> getExchangeInfo() async {
    return await get('/api/v3/exchangeInfo', requiresAuth: false);
  }

  Future<List<List<dynamic>>> getKlines({
    required String symbol,
    required String interval,
    int? limit,
    int? startTime,
    int? endTime,
  }) async {
    final queryParams = {
      'symbol': symbol,
      'interval': interval,
      if (limit != null) 'limit': limit.toString(),
      if (startTime != null) 'startTime': startTime.toString(),
      if (endTime != null) 'endTime': endTime.toString(),
    };

    final uri = Uri.parse('$baseUrl/api/v3/klines')
        .replace(queryParameters: queryParams);
    final response = await http.get(uri);

    if (response.statusCode == 200) {
      return List<List<dynamic>>.from(json.decode(response.body));
    } else {
      throw Exception('Failed to load klines');
    }
  }

  Future<Map<String, dynamic>> get24hrTickerPriceChange(String symbol) async {
    return await get('/api/v3/ticker/24hr',
        queryParams: {'symbol': symbol}, requiresAuth: false);
  }

  Stream<Map<String, dynamic>> getKlineStream(String symbol, String interval) {
    final wsUrl =
        'wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@kline_$interval';
    final channel = WebSocketChannel.connect(Uri.parse(wsUrl));

    return channel.stream.map((event) {
      return jsonDecode(event);
    });
  }

  Future<double> getCurrentPrice(String symbol) async {
    try {
      final response = await get('/api/v3/ticker/price',
          queryParams: {'symbol': symbol}, requiresAuth: false);
      if (response is Map<String, dynamic> && response.containsKey('price')) {
        return double.parse(response['price']);
      } else {
        throw Exception('Unexpected response format for price');
      }
    } catch (e) {
      return 0.0; // Return a default value or throw an exception based on your needs
    }
  }

  Future<List<String>> getValidTradingSymbols() async {
    final response = await get('/api/v3/exchangeInfo', requiresAuth: false);
    final symbols = (response['symbols'] as List<dynamic>)
        .map((symbol) => symbol['symbol'] as String)
        .toList();
    return symbols;
  }

  Future<List<Map<String, dynamic>>> getMyTrades(
      {required String symbol, int? limit, int? startTime}) async {
    try {
      final params = {
        'symbol': symbol,
        if (limit != null) 'limit': limit.toString(),
        if (startTime != null) 'startTime': startTime.toString(),
      };
      final response = await get('/api/v3/myTrades',
          queryParams: params, requiresAuth: true);
      if (response is List) {
        return response.cast<Map<String, dynamic>>();
      } else {
        return [];
      }
    } catch (e) {
      rethrow;
    }
  }

  Future<dynamic> getAccountTradeList({required String symbol}) async {
    return await get('/api/v3/myTrades',
        queryParams: {'symbol': symbol}, requiresAuth: true);
  }

  Future<dynamic> getDepositHistory() async {
    return await get('/sapi/v1/capital/deposit/hisrec', requiresAuth: true);
  }

  Future<dynamic> getWithdrawHistory() async {
    return await get('/sapi/v1/capital/withdraw/history', requiresAuth: true);
  }

  Future<dynamic> getDepositAddress({required String coin}) async {
    return await get('/sapi/v1/capital/deposit/address',
        queryParams: {'coin': coin}, requiresAuth: true);
  }

  Future<dynamic> withdraw({
    required String coin,
    required String address,
    required String amount,
    String? network,
  }) async {
    final body = {
      'coin': coin,
      'address': address,
      'amount': amount,
      if (network != null) 'network': network,
    };
    return await post('/sapi/v1/capital/withdraw/apply', body);
  }

  Future<double> getMinimumTradeAmount(String symbol) async {
    try {
      final response = await get('/api/v3/exchangeInfo',
          queryParams: {'symbol': symbol}, requiresAuth: false);
      final filters = response['symbols'][0]['filters'] as List<dynamic>;
      final lotSizeFilter =
          filters.firstWhere((filter) => filter['filterType'] == 'LOT_SIZE');
      return double.parse(lotSizeFilter['minQty']);
    } catch (e) {
      // In caso di errore, restituisci un valore di default
      return 0.00001; // Questo è un valore arbitrario, regolalo secondo le tue esigenze
    }
  }

  Stream<double> getPriceStream(String symbol) async* {
    final ws = await WebSocket.connect(
        'wss://stream.binance.com:9443/ws/$symbol@trade');

    try {
      await for (var message in ws) {
        final data = json.decode(message);
        yield double.parse(data['p']);
      }
    } finally {
      await ws.close();
    }
  }

  Future<String> createMarketBuyOrder(String symbol, double quantity) async {
    return await createOrder(
      symbol: symbol,
      side: 'BUY',
      type: 'MARKET',
      quantity: quantity.toStringAsFixed(8),
    );
  }

  Future<String> createLimitBuyOrder(
      String symbol, double quantity, double price) async {
    return await createOrder(
      symbol: symbol,
      side: 'BUY',
      type: 'LIMIT',
      quantity: quantity.toStringAsFixed(8),
      price: price.toStringAsFixed(8),
    );
  }

  Future<String> createLimitSellOrder(
      String symbol, double quantity, double price) async {
    return await createOrder(
      symbol: symbol,
      side: 'SELL',
      type: 'LIMIT',
      quantity: quantity.toStringAsFixed(8),
      price: price.toStringAsFixed(8),
    );
  }
}

```

./lib/core/services/trading_service.dart:
```
import 'dart:math';
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';
import 'package:cost_averaging_trading_app/features/strategy/repositories/strategy_repository.dart';

class TradingService {
  final ApiService _apiService;
  final DatabaseService _databaseService;
  final StrategyRepository _strategyRepository;

  TradingService(
    this._apiService,
    this._databaseService,
    this._strategyRepository,
  );

  Future<double> getCurrentPrice(String symbol) async {
    try {
      // Tenta di ottenere il prezzo corrente dall'API
      final price = await _apiService.getCurrentPrice(symbol);

      // Salva il prezzo nel database locale per uso futuro
      await _databaseService.insert('price_history', {
        'symbol': symbol,
        'price': price,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });

      return price;
    } catch (e) {

      // Se fallisce l'API, prova a ottenere l'ultimo prezzo salvato dal database
      try {
        final latestPrice = await _databaseService.query(
          'price_history',
          where: 'symbol = ?',
          whereArgs: [symbol],
          orderBy: 'timestamp DESC',
          limit: 1,
        );

        if (latestPrice.isNotEmpty) {
          return latestPrice.first['price'];
        }
      } catch (dbError) {
              throw Exception('dbError: $dbError');

      }

      // Se non riesce a ottenere il prezzo né dall'API né dal database, lancia un'eccezione
      throw Exception('Unable to get current price for $symbol');
    }
  }

  Future<void> sellEntirePortfolio(String symbol, double targetProfit) async {
    try {
      // Ottieni il saldo attuale per il simbolo specificato
      final balance = await _apiService.getAccountBalance(symbol);

      if (balance > 0) {
        // Crea un ordine di vendita al mercato per l'intero saldo
        final order = await _apiService.createMarketSellOrder(symbol, balance);

        // Assumiamo che l'API restituisca il prezzo medio di esecuzione
        final executionPrice = double.parse(order['avgPrice'] ?? '0');

        // Registra la transazione nel database
        await _databaseService.insert('trades', {
          'symbol': symbol,
          'amount': balance,
          'price': executionPrice,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
          'type': 'sell',
        });

        // Aggiorna le statistiche
        final currentStats = await _strategyRepository.getStrategyStatistics();
        final updatedStats = {
          ...currentStats,
          'totalInvested': 0.0,
          'totalProfit': currentStats['totalProfit'] + targetProfit,
          'totalTrades': currentStats['totalTrades'] + 1,
        };
        await _databaseService.insert('strategy_statistics', updatedStats);
      }
    } catch (e) {
      // Gestisci eventuali errori
      throw Exception('Failed to sell entire portfolio: $e');
    }
  }

  Future<void> executeStrategy(StrategyParameters params) async {
    try {
      double currentPrice = await _apiService.getCurrentPrice(params.symbol);
      double minimumTradableAmount = params.useAutoMinTradeAmount
          ? await _apiService.getMinimumTradeAmount(params.symbol)
          : params.manualMinTradeAmount;

      double amountToBuy =
          _calculateBuyAmount(params, minimumTradableAmount, currentPrice);

      if (await _shouldBuy(params, currentPrice)) {
        await _executeBuy(params.symbol, amountToBuy, currentPrice,
            params.isVariableInvestmentAmount);
      } else if (await _shouldSell(params, currentPrice)) {
        await _executeSell(params, currentPrice);
      }

      await _checkAndExecuteTakeProfit(params);
    } catch (e) {
      throw Exception('Failed to execute strategy: $e');
    }
  }

  double _calculateBuyAmount(StrategyParameters params,
      double minimumTradableAmount, double currentPrice) {
    double baseAmount = params.investmentAmount;
    if (params.isVariableInvestmentAmount) {
      double variationPercentage = (params.variableInvestmentPercentage / 100);
      double randomFactor =
          1 + (Random().nextDouble() * 2 - 1) * variationPercentage;
      baseAmount *= randomFactor;
    }
    return (baseAmount / currentPrice)
        .clamp(minimumTradableAmount, params.maxInvestmentSize);
  }

  Future<bool> _shouldBuy(
      StrategyParameters params, double currentPrice) async {
    Portfolio portfolio = await _getPortfolio(params.symbol);
    return currentPrice <=
        portfolio.averagePrice * (1 - params.stopLossPercentage / 100);
  }

  Future<bool> _shouldSell(
      StrategyParameters params, double currentPrice) async {
    Portfolio portfolio = await _getPortfolio(params.symbol);
    return currentPrice >=
        portfolio.averagePrice * (1 + params.targetProfitPercentage / 100);
  }

  Future<void> _executeBuy(String symbol, double amount, double price,
      bool isVariableInvestment) async {
    CoreTrade trade = CoreTrade(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      symbol: symbol,
      amount: amount,
      price: price,
      timestamp: DateTime.now(),
      type: CoreTradeType.buy,
    );

    await _strategyRepository.saveTradeWithNewFields(
        trade, isVariableInvestment, null);
  }

  Future<void> _executeSell(
      StrategyParameters params, double currentPrice) async {
    Portfolio portfolio = await _getPortfolio(params.symbol);
    CoreTrade trade = CoreTrade(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      symbol: params.symbol,
      amount: portfolio.totalAmount,
      price: currentPrice,
      timestamp: DateTime.now(),
      type: CoreTradeType.sell,
    );

    double profit =
        (currentPrice - portfolio.averagePrice) * portfolio.totalAmount;
    await _strategyRepository.saveTradeWithNewFields(trade, false, null);

    if (params.reinvestProfits) {
      await _reinvestProfit(params.symbol, profit, currentPrice);
    }
  }

  Future<void> _reinvestProfit(
      String symbol, double profit, double currentPrice) async {
    double amountToBuy = profit / currentPrice;
    CoreTrade reinvestmentTrade = CoreTrade(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      symbol: symbol,
      amount: amountToBuy,
      price: currentPrice,
      timestamp: DateTime.now(),
      type: CoreTradeType.buy,
    );

    await _strategyRepository.saveTradeWithNewFields(
        reinvestmentTrade, false, profit);
  }

  Future<void> _checkAndExecuteTakeProfit(StrategyParameters params) async {
    double currentPrice = await _apiService.getCurrentPrice(params.symbol);
    Portfolio portfolio = await _getPortfolio(params.symbol);

    if (currentPrice >=
        portfolio.averagePrice * (1 + params.targetProfitPercentage / 100)) {
      await _executeSell(params, currentPrice);
    }
  }

  Future<Portfolio> _getPortfolio(String symbol) async {
    List<CoreTrade> trades = await _strategyRepository.getRecentTrades(1000);
    trades = trades.where((trade) => trade.symbol == symbol).toList();

    double totalAmount = 0;
    double totalValue = 0;

    for (var trade in trades) {
      if (trade.type == CoreTradeType.buy) {
        totalAmount += trade.amount;
        totalValue += trade.amount * trade.price;
      } else {
        totalAmount -= trade.amount;
        totalValue -= trade.amount * trade.price;
      }
    }

    double averagePrice = totalAmount > 0 ? totalValue / totalAmount : 0;

    return Portfolio(
      symbol: symbol,
      totalAmount: totalAmount,
      averagePrice: averagePrice,
    );
  }
}

class Portfolio {
  final String symbol;
  final double totalAmount;
  final double averagePrice;

  Portfolio({
    required this.symbol,
    required this.totalAmount,
    required this.averagePrice,
  });
}

```

./lib/core/services/secure_storage_service.dart:
```
// lib/core/services/secure_storage_service.dart

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class SecureStorageService {
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  Future<void> saveApiKey(String apiKey) async {
    await _storage.write(key: 'apiKey', value: apiKey);
  }

  Future<String?> getApiKey() async {
    return await _storage.read(key: 'apiKey');
  }

  Future<void> saveSecretKey(String secretKey) async {
    await _storage.write(key: 'secretKey', value: secretKey);
  }

  Future<String?> getSecretKey() async {
    return await _storage.read(key: 'secretKey');
  }

  Future<void> saveValue(String key, String value) async {
    await _storage.write(key: key, value: value);
  }

  Future<String?> getValue(String key) async {
    return await _storage.read(key: key);
  }
}

```

./lib/core/services/database_service.dart:
```
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:cost_averaging_trading_app/features/strategy/models/strategy_parameters.dart';

class DatabaseService {
  static Database? _database;

  Future<void> initDatabase() async {
    if (_database != null) return;
    _database = await _initDatabase();
  }

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    String path = join(await getDatabasesPath(), 'trading_strategy_new2.db');
    //deleteDatabase(path);
    return await openDatabase(
      path,
      version: 2,
      onCreate: _createDb,
      onUpgrade: _upgradeDb,
    );
  }

  Future<void> _createDb(Database db, int version) async {
    await db.execute('''
      CREATE TABLE trades(
        id TEXT PRIMARY KEY,
        symbol TEXT,
        amount REAL,
        price REAL,
        timestamp INTEGER,
        type TEXT,
        isVariableInvestment INTEGER,
        reinvestedProfit REAL
      )
    ''');

    await db.execute('''
      CREATE TABLE strategy_parameters(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        symbol TEXT,
        investmentAmount REAL,
        intervalDays INTEGER,
        targetProfitPercentage REAL,
        stopLossPercentage REAL,
        purchaseFrequency INTEGER,
        maxInvestmentSize REAL,
        useAutoMinTradeAmount INTEGER,
        manualMinTradeAmount REAL,
        isVariableInvestmentAmount INTEGER,
        variableInvestmentPercentage REAL,
        reinvestProfits INTEGER
      )
    ''');

    await db.execute('''
      CREATE TABLE strategy_status(
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       status TEXT NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE price_history (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       symbol TEXT NOT NULL,
       price REAL NOT NULL,
       timestamp INTEGER NOT NULL
       )
    ''');
  }

  Future<void> _upgradeDb(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      await db.execute(
          'ALTER TABLE trades ADD COLUMN isVariableInvestment INTEGER');
      await db.execute('ALTER TABLE trades ADD COLUMN reinvestedProfit REAL');
    }
  }

  Future<int> insert(String table, Map<String, dynamic> data) async {
    Database db = await database;
    return await db.insert(table, data,
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<List<Map<String, dynamic>>> query(
    String table, {
    bool? distinct,
    List<String>? columns,
    String? where,
    List<Object?>? whereArgs,
    String? groupBy,
    String? having,
    String? orderBy,
    int? limit,
    int? offset,
  }) async {
    Database db = await database;
    return await db.query(
      table,
      distinct: distinct,
      columns: columns,
      where: where,
      whereArgs: whereArgs,
      groupBy: groupBy,
      having: having,
      orderBy: orderBy,
      limit: limit,
      offset: offset,
    );
  }

  Future<int> update(String table, Map<String, dynamic> data,
      {String? where, List<Object?>? whereArgs}) async {
    Database db = await database;
    return await db.update(table, data, where: where, whereArgs: whereArgs);
  }

  Future<int> delete(String table,
      {String? where, List<Object?>? whereArgs}) async {
    Database db = await database;
    return await db.delete(table, where: where, whereArgs: whereArgs);
  }

  Future<void> saveStrategyParameters(StrategyParameters params) async {
    Database db = await database;
    await db.insert(
      'strategy_parameters',
      params.toJson(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<StrategyParameters?> getStrategyParameters() async {
    Database db = await database;
    List<Map<String, dynamic>> results = await db.query('strategy_parameters');
    if (results.isNotEmpty) {
      return StrategyParameters.fromJson(results.first);
    }
    return null;
  }

  Future<List<Map<String, dynamic>>> getRecentTrades(int limit) async {
    Database db = await database;
    return await db.query('trades', orderBy: 'timestamp DESC', limit: limit);
  }
}

```

./lib/core/repositories/trading_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';

abstract class TradingRepository {
  Future<List<CoreTrade>> getTrades();
  Future<void> executeTrade(CoreTrade trade);
}

```

./lib/core/repositories/trading_repository_impl.dart:
```
import 'package:cost_averaging_trading_app/core/models/trade.dart';
import 'package:cost_averaging_trading_app/core/repositories/trading_repository.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';
import 'package:cost_averaging_trading_app/features/settings/models/settings_model.dart';

class TradingRepositoryImpl implements TradingRepository {
  final ApiService _apiService;
  final DatabaseService _databaseService;
  final SettingsModel _settings;

  TradingRepositoryImpl(
      this._apiService, this._databaseService, this._settings);

  @override
  Future<List<CoreTrade>> getTrades() async {
    if (_settings.isDemoMode) {
      return _getDemoTrades();
    } else {
      try {
        final json = await _apiService.get('trades');
        final trades = (json['trades'] as List)
            .map((e) => CoreTrade(
                  id: e['id'],
                  symbol: e['symbol'],
                  amount: e['amount'],
                  price: e['price'],
                  timestamp:
                      DateTime.fromMillisecondsSinceEpoch(e['timestamp']),
                  type: e['type'],
                ))
            .toList();
        return trades;
      } catch (e) {
        // If API call fails, try to get data from local database
        final data = await _databaseService.query('trades');
        return data
            .map((e) => CoreTrade(
                  id: e['id'],
                  symbol: e['symbol'],
                  amount: e['amount'],
                  price: e['price'],
                  timestamp: DateTime.fromMillisecondsSinceEpoch(
                    e['timestamp'],
                  ),
                  type: e['type'],
                ))
            .toList();
      }
    }
  }

  @override
  Future<void> executeTrade(CoreTrade trade) async {
    if (_settings.isDemoMode) {
      await _executeDemoTrade(trade);
    } else {
      try {
        await _apiService.post('trades', {
          'symbol': trade.symbol,
          'amount': trade.amount,
          'price': trade.price,
        });
      } catch (e) {
        // If API call fails, save to local database
        await _databaseService.insert('trades', {
          'id': trade.id,
          'symbol': trade.symbol,
          'amount': trade.amount,
          'price': trade.price,
          'timestamp': trade.timestamp.millisecondsSinceEpoch,
        });
      }
    }
  }

  Future<List<CoreTrade>> _getDemoTrades() async {
    // Recupera le operazioni demo dal database locale
    final data = await _databaseService.query('demo_trades');
    return data
        .map(
          (e) => CoreTrade(
            id: e['id'],
            symbol: e['symbol'],
            amount: e['amount'],
            price: e['price'],
            timestamp: DateTime.fromMillisecondsSinceEpoch(e['timestamp']),
            type: e['type'],
          ),
        )
        .toList();
  }

  Future<void> _executeDemoTrade(CoreTrade trade) async {
    // Salva l'operazione demo nel database locale
    await _databaseService.insert('demo_trades', {
      'id': trade.id,
      'symbol': trade.symbol,
      'amount': trade.amount,
      'price': trade.price,
      'timestamp': trade.timestamp.millisecondsSinceEpoch,
    });
  }
}

```

./lib/core/repositories/portfolio_repository_impl.dart:
```
import 'package:cost_averaging_trading_app/core/dtos/portfolio_dto.dart';
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';
import 'package:cost_averaging_trading_app/core/repositories/portfolio_repository.dart';
import 'package:cost_averaging_trading_app/core/services/api_service.dart';
import 'package:cost_averaging_trading_app/core/services/database_service.dart';

class PortfolioRepositoryImpl implements PortfolioRepository {
  final ApiService _apiService;
  final DatabaseService _databaseService;

  PortfolioRepositoryImpl(this._apiService, this._databaseService);

  @override
  Future<Portfolio> getPortfolio() async {
    try {
      final json = await _apiService.get('portfolio');
      final dto = PortfolioDTO.fromJson(json);
      return Portfolio(
        id: dto.id,
        assets: dto.assets,
        totalValue: dto.totalValue,
      );
    } catch (e) {
      // If API call fails, try to get data from local database
      final data = await _databaseService.query('portfolio');
      if (data.isNotEmpty) {
        final dto = PortfolioDTO.fromDatabase(data.first);
        return Portfolio(
          id: dto.id,
          assets: dto.assets,
          totalValue: dto.totalValue,
        );
      }
      throw Exception('Failed to get portfolio data');
    }
  }

  @override
  Future<void> updatePortfolio(Portfolio portfolio) async {
    final dto = PortfolioDTO(
      id: portfolio.id,
      assets: portfolio.assets,
      totalValue: portfolio.totalValue,
    );
    try {
      await _apiService.post('portfolio', dto.toJson());
    } catch (e) {
      // If API call fails, update local database
      await _databaseService.insert('portfolio', dto.toDatabase());
    }
  }
}

```

./lib/core/repositories/portfolio_repository.dart:
```
import 'package:cost_averaging_trading_app/core/models/portfolio.dart';

abstract class PortfolioRepository {
  Future<Portfolio> getPortfolio();
  Future<void> updatePortfolio(Portfolio portfolio);
}

```

./lib/core/models/portfolio.dart:
```
// lib/core/models/portfolio.dart

import 'package:equatable/equatable.dart';

class Portfolio extends Equatable {
  final String id;
  final Map<String, double> assets;
  final double totalValue;

  const Portfolio({
    required this.id,
    required this.assets,
    required this.totalValue,
  });

  @override
  List<Object?> get props => [id, assets, totalValue];

  factory Portfolio.fromJson(Map<String, dynamic> json) {
    return Portfolio(
      id: json['id'],
      assets: Map<String, double>.from(json['assets']),
      totalValue: json['totalValue'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'assets': assets,
      'totalValue': totalValue,
    };
  }
}

```

./lib/core/models/trade.dart:
```
// lib/core/models/trade.dart

import 'package:equatable/equatable.dart';

enum CoreTradeType { buy, sell }

class CoreTrade extends Equatable {
  final String id;
  final String symbol;
  final double amount;
  final double price;
  final DateTime timestamp;
  final CoreTradeType type;

  const CoreTrade({
    required this.id,
    required this.symbol,
    required this.amount,
    required this.price,
    required this.timestamp,
    required this.type,
  });

  @override
  List<Object?> get props => [id, symbol, amount, price, timestamp, type];

  CoreTrade copyWith({
    String? id,
    String? symbol,
    double? amount,
    double? price,
    DateTime? timestamp,
    CoreTradeType? type,
  }) {
    return CoreTrade(
      id: id ?? this.id,
      symbol: symbol ?? this.symbol,
      amount: amount ?? this.amount,
      price: price ?? this.price,
      timestamp: timestamp ?? this.timestamp,
      type: type ?? this.type,
    );
  }

factory CoreTrade.fromJson(Map<String, dynamic> json) {
    return CoreTrade(
      id: json['id']?.toString() ?? '',
      symbol: json['symbol'] ?? '',
      amount: double.tryParse(json['qty']?.toString() ?? '0') ?? 0.0,
      price: double.tryParse(json['price']?.toString() ?? '0') ?? 0.0,
      timestamp: json['time'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['time'] as int)
          : DateTime.now(),
      type: json['isBuyer'] == true ? CoreTradeType.buy : CoreTradeType.sell,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'symbol': symbol,
      'amount': amount,
      'price': price,
      'timestamp': timestamp.millisecondsSinceEpoch,
      'type': type == CoreTradeType.buy ? 'buy' : 'sell',
    };
  }
}

```

./lib/core/models/risk_management_settings.dart:
```
class RiskManagementSettings {
  final double maxLossPercentage;
  final int maxConcurrentTrades;
  final double maxPositionSizePercentage;
  final double dailyExposureLimit;
  final double maxAllowedVolatility;
  final int maxRebuyCount;

  RiskManagementSettings({
    required this.maxLossPercentage,
    required this.maxConcurrentTrades,
    required this.maxPositionSizePercentage,
    required this.dailyExposureLimit,
    required this.maxAllowedVolatility,
    required this.maxRebuyCount,
  });
}
```

./lib/core/models/strategy_execution_result.dart:
```
enum StrategyExecutionResult {
  success,
  tradeNotAllowed,
  insufficientTime,
  stopLossTriggered,
  error;

  bool get isSuccess => this == StrategyExecutionResult.success;
  bool get isTradeNotAllowed => this == StrategyExecutionResult.tradeNotAllowed;
  bool get isInsufficientTime => this == StrategyExecutionResult.insufficientTime;
  bool get isStopLossTriggered => this == StrategyExecutionResult.stopLossTriggered;
  bool get isError => this == StrategyExecutionResult.error;

  String get message {
    switch (this) {
      case StrategyExecutionResult.success:
        return 'Strategy executed successfully';
      case StrategyExecutionResult.tradeNotAllowed:
        return 'Trade not allowed due to risk limits';
      case StrategyExecutionResult.insufficientTime:
        return 'Insufficient time since last trade';
      case StrategyExecutionResult.stopLossTriggered:
        return 'Stop loss triggered, entire portfolio sold';
      case StrategyExecutionResult.error:
        return 'An error occurred during strategy execution';
    }
  }
}
```

./lib/core/utils/breakpoints.dart:
```
class Breakpoints {
  static const double mobileSmall = 320;
  static const double mobileMedium = 375;
  static const double mobileLarge = 425;
  static const double tablet = 768;
  static const double laptop = 1024;
  static const double laptopLarge = 1440;
  static const double desktop4K = 2560;

  static bool isMobile(double width) => width < tablet;
  static bool isTablet(double width) => width >= tablet && width < laptop;
  static bool isDesktop(double width) => width >= laptop;

  static String getDeviceType(double width) {
    if (width < mobileMedium) {
      return 'mobile_small';
    } else if (width < mobileLarge) {
      return 'mobile_medium';
    } else if (width < tablet) {
      return 'mobile_large';
    } else if (width < laptop) {
      return 'tablet';
    } else if (width < laptopLarge) {
      return 'laptop';
    } else if (width < desktop4K) {
      return 'laptop_large';
    } else {
      return 'desktop_4k';
    }
  }
}

```

./lib/core/error/error_handler.dart:
```
// lib/core/error/error_handler.dart


class ErrorHandler {
  static void logError(String message, dynamic error, StackTrace stackTrace) {
    // In un'applicazione reale, qui potresti inviare l'errore a un servizio di logging remoto
  }

  static String getUserFriendlyErrorMessage(dynamic error) {
    if (error is NetworkError) {
      return 'Si è verificato un problema di connessione. Controlla la tua connessione internet e riprova.';
    } else if (error is AuthenticationError) {
      return 'Si è verificato un problema di autenticazione. Per favore, effettua nuovamente il login.';
    } else if (error is ValidationError) {
      return 'Si è verificato un problema con i dati inseriti. Per favore, controlla i tuoi input e riprova.';
    } else if (error is ApiError) {
      return 'Si è verificato un errore durante la comunicazione con il server. Per favore, riprova più tardi.';
    } else {
      return 'Si è verificato un errore imprevisto. Per favore, riprova più tardi.';
    }
  }
}

class NetworkError implements Exception {}

class AuthenticationError implements Exception {}

class ValidationError implements Exception {}

class ApiError implements Exception {
  final String message;
  ApiError(this.message);
}

```

